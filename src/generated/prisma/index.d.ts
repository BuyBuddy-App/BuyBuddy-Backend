
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Account
 * 
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model DeviceToken
 * 
 */
export type DeviceToken = $Result.DefaultSelection<Prisma.$DeviceTokenPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Address
 * 
 */
export type Address = $Result.DefaultSelection<Prisma.$AddressPayload>
/**
 * Model Brand
 * 
 */
export type Brand = $Result.DefaultSelection<Prisma.$BrandPayload>
/**
 * Model RefreshToken
 * 
 */
export type RefreshToken = $Result.DefaultSelection<Prisma.$RefreshTokenPayload>
/**
 * Model PrivateConversation
 * 
 */
export type PrivateConversation = $Result.DefaultSelection<Prisma.$PrivateConversationPayload>
/**
 * Model PrivateConversationParticipant
 * 
 */
export type PrivateConversationParticipant = $Result.DefaultSelection<Prisma.$PrivateConversationParticipantPayload>
/**
 * Model PrivateMessage
 * 
 */
export type PrivateMessage = $Result.DefaultSelection<Prisma.$PrivateMessagePayload>
/**
 * Model PrivateMessageAttachment
 * 
 */
export type PrivateMessageAttachment = $Result.DefaultSelection<Prisma.$PrivateMessageAttachmentPayload>
/**
 * Model PrivateMessageVisibility
 * 
 */
export type PrivateMessageVisibility = $Result.DefaultSelection<Prisma.$PrivateMessageVisibilityPayload>
/**
 * Model Product
 * 
 */
export type Product = $Result.DefaultSelection<Prisma.$ProductPayload>
/**
 * Model ProductImage
 * 
 */
export type ProductImage = $Result.DefaultSelection<Prisma.$ProductImagePayload>
/**
 * Model ProductOption
 * 
 */
export type ProductOption = $Result.DefaultSelection<Prisma.$ProductOptionPayload>
/**
 * Model ProductOptionValue
 * 
 */
export type ProductOptionValue = $Result.DefaultSelection<Prisma.$ProductOptionValuePayload>
/**
 * Model VariantOption
 * 
 */
export type VariantOption = $Result.DefaultSelection<Prisma.$VariantOptionPayload>
/**
 * Model Variant
 * 
 */
export type Variant = $Result.DefaultSelection<Prisma.$VariantPayload>
/**
 * Model VariantImage
 * 
 */
export type VariantImage = $Result.DefaultSelection<Prisma.$VariantImagePayload>
/**
 * Model Tag
 * 
 */
export type Tag = $Result.DefaultSelection<Prisma.$TagPayload>
/**
 * Model ProductTag
 * 
 */
export type ProductTag = $Result.DefaultSelection<Prisma.$ProductTagPayload>
/**
 * Model ProductImageEmbedding
 * 
 */
export type ProductImageEmbedding = $Result.DefaultSelection<Prisma.$ProductImageEmbeddingPayload>
/**
 * Model Review
 * 
 */
export type Review = $Result.DefaultSelection<Prisma.$ReviewPayload>
/**
 * Model ReviewImage
 * 
 */
export type ReviewImage = $Result.DefaultSelection<Prisma.$ReviewImagePayload>
/**
 * Model ReviewVote
 * 
 */
export type ReviewVote = $Result.DefaultSelection<Prisma.$ReviewVotePayload>
/**
 * Model ReviewReport
 * 
 */
export type ReviewReport = $Result.DefaultSelection<Prisma.$ReviewReportPayload>
/**
 * Model ReviewReply
 * 
 */
export type ReviewReply = $Result.DefaultSelection<Prisma.$ReviewReplyPayload>
/**
 * Model Notification
 * Canonical notification
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model NotificationRecipient
 * Per-account read/delivery state
 */
export type NotificationRecipient = $Result.DefaultSelection<Prisma.$NotificationRecipientPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  MANAGER: 'MANAGER',
  ADMIN: 'ADMIN',
  BRAND: 'BRAND',
  USER: 'USER',
  GUEST: 'GUEST'
};

export type Role = (typeof Role)[keyof typeof Role]


export const Status: {
  UNVERIFIED: 'UNVERIFIED',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  INACTIVE: 'INACTIVE'
};

export type Status = (typeof Status)[keyof typeof Status]


export const RevokedReason: {
  ACCOUNT_LOGOUT: 'ACCOUNT_LOGOUT',
  EXPIRED: 'EXPIRED',
  ADMIN_REVOKED: 'ADMIN_REVOKED',
  PASSWORD_CHANGE: 'PASSWORD_CHANGE',
  TOKEN_REUSE_DETECTED: 'TOKEN_REUSE_DETECTED',
  ROTATED: 'ROTATED',
  OTHER: 'OTHER'
};

export type RevokedReason = (typeof RevokedReason)[keyof typeof RevokedReason]


export const Provider: {
  LOCAL: 'LOCAL',
  GOOGLE: 'GOOGLE'
};

export type Provider = (typeof Provider)[keyof typeof Provider]


export const BrandStatus: {
  DRAFT: 'DRAFT',
  PENDING: 'PENDING',
  ACTIVE: 'ACTIVE',
  SUSPENDED: 'SUSPENDED',
  REJECTED: 'REJECTED',
  INACTIVE: 'INACTIVE'
};

export type BrandStatus = (typeof BrandStatus)[keyof typeof BrandStatus]


export const ProductStatus: {
  DRAFT: 'DRAFT',
  ARCHIVED: 'ARCHIVED',
  PUBLISHED: 'PUBLISHED'
};

export type ProductStatus = (typeof ProductStatus)[keyof typeof ProductStatus]


export const PaymentMethod: {
  CREDIT_CARD: 'CREDIT_CARD',
  DEBIT_CARD: 'DEBIT_CARD',
  BANK_TRANSFER: 'BANK_TRANSFER',
  PAYPAL: 'PAYPAL',
  STRIPE: 'STRIPE',
  CASH_ON_DELIVERY: 'CASH_ON_DELIVERY',
  APPLE_PAY: 'APPLE_PAY',
  GOOGLE_PAY: 'GOOGLE_PAY',
  FAWRY: 'FAWRY',
  OTHER: 'OTHER'
};

export type PaymentMethod = (typeof PaymentMethod)[keyof typeof PaymentMethod]


export const Category: {
  FASHION: 'FASHION',
  HOME: 'HOME',
  BEAUTY: 'BEAUTY',
  OTHER: 'OTHER'
};

export type Category = (typeof Category)[keyof typeof Category]


export const Gender: {
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type Gender = (typeof Gender)[keyof typeof Gender]


export const ContentType: {
  TEXT: 'TEXT',
  IMAGE: 'IMAGE'
};

export type ContentType = (typeof ContentType)[keyof typeof ContentType]


export const ReactionType: {
  LIKE: 'LIKE',
  LOVE: 'LOVE',
  ADMIRE: 'ADMIRE'
};

export type ReactionType = (typeof ReactionType)[keyof typeof ReactionType]


export const ReviewVisibility: {
  PUBLISHED: 'PUBLISHED',
  HIDDEN: 'HIDDEN'
};

export type ReviewVisibility = (typeof ReviewVisibility)[keyof typeof ReviewVisibility]


export const VoteType: {
  UP: 'UP',
  DOWN: 'DOWN'
};

export type VoteType = (typeof VoteType)[keyof typeof VoteType]


export const ReportReason: {
  SPAM: 'SPAM',
  OFFENSIVE: 'OFFENSIVE',
  INAPPROPRIATE: 'INAPPROPRIATE',
  MISLEADING: 'MISLEADING',
  FAKE_REVIEW: 'FAKE_REVIEW',
  OTHER: 'OTHER'
};

export type ReportReason = (typeof ReportReason)[keyof typeof ReportReason]


export const NotificationType: {
  MESSAGE: 'MESSAGE',
  ORDER: 'ORDER',
  PROMOTION: 'PROMOTION',
  SYSTEM: 'SYSTEM',
  SECURITY: 'SECURITY',
  REVIEW: 'REVIEW',
  SHIPPING: 'SHIPPING',
  OTHER: 'OTHER'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type Status = $Enums.Status

export const Status: typeof $Enums.Status

export type RevokedReason = $Enums.RevokedReason

export const RevokedReason: typeof $Enums.RevokedReason

export type Provider = $Enums.Provider

export const Provider: typeof $Enums.Provider

export type BrandStatus = $Enums.BrandStatus

export const BrandStatus: typeof $Enums.BrandStatus

export type ProductStatus = $Enums.ProductStatus

export const ProductStatus: typeof $Enums.ProductStatus

export type PaymentMethod = $Enums.PaymentMethod

export const PaymentMethod: typeof $Enums.PaymentMethod

export type Category = $Enums.Category

export const Category: typeof $Enums.Category

export type Gender = $Enums.Gender

export const Gender: typeof $Enums.Gender

export type ContentType = $Enums.ContentType

export const ContentType: typeof $Enums.ContentType

export type ReactionType = $Enums.ReactionType

export const ReactionType: typeof $Enums.ReactionType

export type ReviewVisibility = $Enums.ReviewVisibility

export const ReviewVisibility: typeof $Enums.ReviewVisibility

export type VoteType = $Enums.VoteType

export const VoteType: typeof $Enums.VoteType

export type ReportReason = $Enums.ReportReason

export const ReportReason: typeof $Enums.ReportReason

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Accounts
 * const accounts = await prisma.account.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Accounts
   * const accounts = await prisma.account.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.deviceToken`: Exposes CRUD operations for the **DeviceToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DeviceTokens
    * const deviceTokens = await prisma.deviceToken.findMany()
    * ```
    */
  get deviceToken(): Prisma.DeviceTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.address`: Exposes CRUD operations for the **Address** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Addresses
    * const addresses = await prisma.address.findMany()
    * ```
    */
  get address(): Prisma.AddressDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brand`: Exposes CRUD operations for the **Brand** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brand.findMany()
    * ```
    */
  get brand(): Prisma.BrandDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.refreshToken`: Exposes CRUD operations for the **RefreshToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RefreshTokens
    * const refreshTokens = await prisma.refreshToken.findMany()
    * ```
    */
  get refreshToken(): Prisma.RefreshTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateConversation`: Exposes CRUD operations for the **PrivateConversation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateConversations
    * const privateConversations = await prisma.privateConversation.findMany()
    * ```
    */
  get privateConversation(): Prisma.PrivateConversationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateConversationParticipant`: Exposes CRUD operations for the **PrivateConversationParticipant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateConversationParticipants
    * const privateConversationParticipants = await prisma.privateConversationParticipant.findMany()
    * ```
    */
  get privateConversationParticipant(): Prisma.PrivateConversationParticipantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateMessage`: Exposes CRUD operations for the **PrivateMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateMessages
    * const privateMessages = await prisma.privateMessage.findMany()
    * ```
    */
  get privateMessage(): Prisma.PrivateMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateMessageAttachment`: Exposes CRUD operations for the **PrivateMessageAttachment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateMessageAttachments
    * const privateMessageAttachments = await prisma.privateMessageAttachment.findMany()
    * ```
    */
  get privateMessageAttachment(): Prisma.PrivateMessageAttachmentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.privateMessageVisibility`: Exposes CRUD operations for the **PrivateMessageVisibility** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PrivateMessageVisibilities
    * const privateMessageVisibilities = await prisma.privateMessageVisibility.findMany()
    * ```
    */
  get privateMessageVisibility(): Prisma.PrivateMessageVisibilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImage`: Exposes CRUD operations for the **ProductImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImages
    * const productImages = await prisma.productImage.findMany()
    * ```
    */
  get productImage(): Prisma.ProductImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productOption`: Exposes CRUD operations for the **ProductOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductOptions
    * const productOptions = await prisma.productOption.findMany()
    * ```
    */
  get productOption(): Prisma.ProductOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productOptionValue`: Exposes CRUD operations for the **ProductOptionValue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductOptionValues
    * const productOptionValues = await prisma.productOptionValue.findMany()
    * ```
    */
  get productOptionValue(): Prisma.ProductOptionValueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variantOption`: Exposes CRUD operations for the **VariantOption** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariantOptions
    * const variantOptions = await prisma.variantOption.findMany()
    * ```
    */
  get variantOption(): Prisma.VariantOptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variant`: Exposes CRUD operations for the **Variant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variant.findMany()
    * ```
    */
  get variant(): Prisma.VariantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variantImage`: Exposes CRUD operations for the **VariantImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VariantImages
    * const variantImages = await prisma.variantImage.findMany()
    * ```
    */
  get variantImage(): Prisma.VariantImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.tag`: Exposes CRUD operations for the **Tag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tags
    * const tags = await prisma.tag.findMany()
    * ```
    */
  get tag(): Prisma.TagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productTag`: Exposes CRUD operations for the **ProductTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductTags
    * const productTags = await prisma.productTag.findMany()
    * ```
    */
  get productTag(): Prisma.ProductTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.productImageEmbedding`: Exposes CRUD operations for the **ProductImageEmbedding** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProductImageEmbeddings
    * const productImageEmbeddings = await prisma.productImageEmbedding.findMany()
    * ```
    */
  get productImageEmbedding(): Prisma.ProductImageEmbeddingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.review`: Exposes CRUD operations for the **Review** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reviews
    * const reviews = await prisma.review.findMany()
    * ```
    */
  get review(): Prisma.ReviewDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewImage`: Exposes CRUD operations for the **ReviewImage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewImages
    * const reviewImages = await prisma.reviewImage.findMany()
    * ```
    */
  get reviewImage(): Prisma.ReviewImageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewVote`: Exposes CRUD operations for the **ReviewVote** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewVotes
    * const reviewVotes = await prisma.reviewVote.findMany()
    * ```
    */
  get reviewVote(): Prisma.ReviewVoteDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewReport`: Exposes CRUD operations for the **ReviewReport** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewReports
    * const reviewReports = await prisma.reviewReport.findMany()
    * ```
    */
  get reviewReport(): Prisma.ReviewReportDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.reviewReply`: Exposes CRUD operations for the **ReviewReply** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ReviewReplies
    * const reviewReplies = await prisma.reviewReply.findMany()
    * ```
    */
  get reviewReply(): Prisma.ReviewReplyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notificationRecipient`: Exposes CRUD operations for the **NotificationRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NotificationRecipients
    * const notificationRecipients = await prisma.notificationRecipient.findMany()
    * ```
    */
  get notificationRecipient(): Prisma.NotificationRecipientDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Account: 'Account',
    DeviceToken: 'DeviceToken',
    User: 'User',
    Address: 'Address',
    Brand: 'Brand',
    RefreshToken: 'RefreshToken',
    PrivateConversation: 'PrivateConversation',
    PrivateConversationParticipant: 'PrivateConversationParticipant',
    PrivateMessage: 'PrivateMessage',
    PrivateMessageAttachment: 'PrivateMessageAttachment',
    PrivateMessageVisibility: 'PrivateMessageVisibility',
    Product: 'Product',
    ProductImage: 'ProductImage',
    ProductOption: 'ProductOption',
    ProductOptionValue: 'ProductOptionValue',
    VariantOption: 'VariantOption',
    Variant: 'Variant',
    VariantImage: 'VariantImage',
    Tag: 'Tag',
    ProductTag: 'ProductTag',
    ProductImageEmbedding: 'ProductImageEmbedding',
    Review: 'Review',
    ReviewImage: 'ReviewImage',
    ReviewVote: 'ReviewVote',
    ReviewReport: 'ReviewReport',
    ReviewReply: 'ReviewReply',
    Notification: 'Notification',
    NotificationRecipient: 'NotificationRecipient'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "account" | "deviceToken" | "user" | "address" | "brand" | "refreshToken" | "privateConversation" | "privateConversationParticipant" | "privateMessage" | "privateMessageAttachment" | "privateMessageVisibility" | "product" | "productImage" | "productOption" | "productOptionValue" | "variantOption" | "variant" | "variantImage" | "tag" | "productTag" | "productImageEmbedding" | "review" | "reviewImage" | "reviewVote" | "reviewReport" | "reviewReply" | "notification" | "notificationRecipient"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      DeviceToken: {
        payload: Prisma.$DeviceTokenPayload<ExtArgs>
        fields: Prisma.DeviceTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findFirst: {
            args: Prisma.DeviceTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          findMany: {
            args: Prisma.DeviceTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          create: {
            args: Prisma.DeviceTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          createMany: {
            args: Prisma.DeviceTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          delete: {
            args: Prisma.DeviceTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          update: {
            args: Prisma.DeviceTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          deleteMany: {
            args: Prisma.DeviceTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>[]
          }
          upsert: {
            args: Prisma.DeviceTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DeviceTokenPayload>
          }
          aggregate: {
            args: Prisma.DeviceTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDeviceToken>
          }
          groupBy: {
            args: Prisma.DeviceTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceTokenCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceTokenCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Address: {
        payload: Prisma.$AddressPayload<ExtArgs>
        fields: Prisma.AddressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AddressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AddressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findFirst: {
            args: Prisma.AddressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AddressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          findMany: {
            args: Prisma.AddressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          create: {
            args: Prisma.AddressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          createMany: {
            args: Prisma.AddressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AddressCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          delete: {
            args: Prisma.AddressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          update: {
            args: Prisma.AddressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          deleteMany: {
            args: Prisma.AddressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AddressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AddressUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>[]
          }
          upsert: {
            args: Prisma.AddressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AddressPayload>
          }
          aggregate: {
            args: Prisma.AddressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAddress>
          }
          groupBy: {
            args: Prisma.AddressGroupByArgs<ExtArgs>
            result: $Utils.Optional<AddressGroupByOutputType>[]
          }
          count: {
            args: Prisma.AddressCountArgs<ExtArgs>
            result: $Utils.Optional<AddressCountAggregateOutputType> | number
          }
        }
      }
      Brand: {
        payload: Prisma.$BrandPayload<ExtArgs>
        fields: Prisma.BrandFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BrandFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BrandFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findFirst: {
            args: Prisma.BrandFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BrandFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          findMany: {
            args: Prisma.BrandFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          create: {
            args: Prisma.BrandCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          createMany: {
            args: Prisma.BrandCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BrandCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          delete: {
            args: Prisma.BrandDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          update: {
            args: Prisma.BrandUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          deleteMany: {
            args: Prisma.BrandDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BrandUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BrandUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>[]
          }
          upsert: {
            args: Prisma.BrandUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BrandPayload>
          }
          aggregate: {
            args: Prisma.BrandAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrand>
          }
          groupBy: {
            args: Prisma.BrandGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandGroupByOutputType>[]
          }
          count: {
            args: Prisma.BrandCountArgs<ExtArgs>
            result: $Utils.Optional<BrandCountAggregateOutputType> | number
          }
        }
      }
      RefreshToken: {
        payload: Prisma.$RefreshTokenPayload<ExtArgs>
        fields: Prisma.RefreshTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RefreshTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RefreshTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findFirst: {
            args: Prisma.RefreshTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RefreshTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          findMany: {
            args: Prisma.RefreshTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          create: {
            args: Prisma.RefreshTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          createMany: {
            args: Prisma.RefreshTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RefreshTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          delete: {
            args: Prisma.RefreshTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          update: {
            args: Prisma.RefreshTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          deleteMany: {
            args: Prisma.RefreshTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RefreshTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RefreshTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>[]
          }
          upsert: {
            args: Prisma.RefreshTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RefreshTokenPayload>
          }
          aggregate: {
            args: Prisma.RefreshTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRefreshToken>
          }
          groupBy: {
            args: Prisma.RefreshTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.RefreshTokenCountArgs<ExtArgs>
            result: $Utils.Optional<RefreshTokenCountAggregateOutputType> | number
          }
        }
      }
      PrivateConversation: {
        payload: Prisma.$PrivateConversationPayload<ExtArgs>
        fields: Prisma.PrivateConversationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateConversationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateConversationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          findFirst: {
            args: Prisma.PrivateConversationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateConversationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          findMany: {
            args: Prisma.PrivateConversationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>[]
          }
          create: {
            args: Prisma.PrivateConversationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          createMany: {
            args: Prisma.PrivateConversationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateConversationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>[]
          }
          delete: {
            args: Prisma.PrivateConversationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          update: {
            args: Prisma.PrivateConversationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          deleteMany: {
            args: Prisma.PrivateConversationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateConversationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateConversationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>[]
          }
          upsert: {
            args: Prisma.PrivateConversationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationPayload>
          }
          aggregate: {
            args: Prisma.PrivateConversationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateConversation>
          }
          groupBy: {
            args: Prisma.PrivateConversationGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateConversationGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateConversationCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateConversationCountAggregateOutputType> | number
          }
        }
      }
      PrivateConversationParticipant: {
        payload: Prisma.$PrivateConversationParticipantPayload<ExtArgs>
        fields: Prisma.PrivateConversationParticipantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateConversationParticipantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateConversationParticipantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          findFirst: {
            args: Prisma.PrivateConversationParticipantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateConversationParticipantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          findMany: {
            args: Prisma.PrivateConversationParticipantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>[]
          }
          create: {
            args: Prisma.PrivateConversationParticipantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          createMany: {
            args: Prisma.PrivateConversationParticipantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateConversationParticipantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>[]
          }
          delete: {
            args: Prisma.PrivateConversationParticipantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          update: {
            args: Prisma.PrivateConversationParticipantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          deleteMany: {
            args: Prisma.PrivateConversationParticipantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateConversationParticipantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateConversationParticipantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>[]
          }
          upsert: {
            args: Prisma.PrivateConversationParticipantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateConversationParticipantPayload>
          }
          aggregate: {
            args: Prisma.PrivateConversationParticipantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateConversationParticipant>
          }
          groupBy: {
            args: Prisma.PrivateConversationParticipantGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateConversationParticipantGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateConversationParticipantCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateConversationParticipantCountAggregateOutputType> | number
          }
        }
      }
      PrivateMessage: {
        payload: Prisma.$PrivateMessagePayload<ExtArgs>
        fields: Prisma.PrivateMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          findFirst: {
            args: Prisma.PrivateMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          findMany: {
            args: Prisma.PrivateMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>[]
          }
          create: {
            args: Prisma.PrivateMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          createMany: {
            args: Prisma.PrivateMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>[]
          }
          delete: {
            args: Prisma.PrivateMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          update: {
            args: Prisma.PrivateMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          deleteMany: {
            args: Prisma.PrivateMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>[]
          }
          upsert: {
            args: Prisma.PrivateMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessagePayload>
          }
          aggregate: {
            args: Prisma.PrivateMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateMessage>
          }
          groupBy: {
            args: Prisma.PrivateMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateMessageCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageCountAggregateOutputType> | number
          }
        }
      }
      PrivateMessageAttachment: {
        payload: Prisma.$PrivateMessageAttachmentPayload<ExtArgs>
        fields: Prisma.PrivateMessageAttachmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateMessageAttachmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateMessageAttachmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          findFirst: {
            args: Prisma.PrivateMessageAttachmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateMessageAttachmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          findMany: {
            args: Prisma.PrivateMessageAttachmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>[]
          }
          create: {
            args: Prisma.PrivateMessageAttachmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          createMany: {
            args: Prisma.PrivateMessageAttachmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateMessageAttachmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>[]
          }
          delete: {
            args: Prisma.PrivateMessageAttachmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          update: {
            args: Prisma.PrivateMessageAttachmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          deleteMany: {
            args: Prisma.PrivateMessageAttachmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateMessageAttachmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateMessageAttachmentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>[]
          }
          upsert: {
            args: Prisma.PrivateMessageAttachmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageAttachmentPayload>
          }
          aggregate: {
            args: Prisma.PrivateMessageAttachmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateMessageAttachment>
          }
          groupBy: {
            args: Prisma.PrivateMessageAttachmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageAttachmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateMessageAttachmentCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageAttachmentCountAggregateOutputType> | number
          }
        }
      }
      PrivateMessageVisibility: {
        payload: Prisma.$PrivateMessageVisibilityPayload<ExtArgs>
        fields: Prisma.PrivateMessageVisibilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PrivateMessageVisibilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PrivateMessageVisibilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          findFirst: {
            args: Prisma.PrivateMessageVisibilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PrivateMessageVisibilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          findMany: {
            args: Prisma.PrivateMessageVisibilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>[]
          }
          create: {
            args: Prisma.PrivateMessageVisibilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          createMany: {
            args: Prisma.PrivateMessageVisibilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PrivateMessageVisibilityCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>[]
          }
          delete: {
            args: Prisma.PrivateMessageVisibilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          update: {
            args: Prisma.PrivateMessageVisibilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          deleteMany: {
            args: Prisma.PrivateMessageVisibilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PrivateMessageVisibilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PrivateMessageVisibilityUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>[]
          }
          upsert: {
            args: Prisma.PrivateMessageVisibilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PrivateMessageVisibilityPayload>
          }
          aggregate: {
            args: Prisma.PrivateMessageVisibilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePrivateMessageVisibility>
          }
          groupBy: {
            args: Prisma.PrivateMessageVisibilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageVisibilityGroupByOutputType>[]
          }
          count: {
            args: Prisma.PrivateMessageVisibilityCountArgs<ExtArgs>
            result: $Utils.Optional<PrivateMessageVisibilityCountAggregateOutputType> | number
          }
        }
      }
      Product: {
        payload: Prisma.$ProductPayload<ExtArgs>
        fields: Prisma.ProductFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findFirst: {
            args: Prisma.ProductFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          findMany: {
            args: Prisma.ProductFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          create: {
            args: Prisma.ProductCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          createMany: {
            args: Prisma.ProductCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          delete: {
            args: Prisma.ProductDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          update: {
            args: Prisma.ProductUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          deleteMany: {
            args: Prisma.ProductDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>[]
          }
          upsert: {
            args: Prisma.ProductUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductPayload>
          }
          aggregate: {
            args: Prisma.ProductAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProduct>
          }
          groupBy: {
            args: Prisma.ProductGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductCountArgs<ExtArgs>
            result: $Utils.Optional<ProductCountAggregateOutputType> | number
          }
        }
      }
      ProductImage: {
        payload: Prisma.$ProductImagePayload<ExtArgs>
        fields: Prisma.ProductImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findFirst: {
            args: Prisma.ProductImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          findMany: {
            args: Prisma.ProductImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          create: {
            args: Prisma.ProductImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          createMany: {
            args: Prisma.ProductImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          delete: {
            args: Prisma.ProductImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          update: {
            args: Prisma.ProductImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          deleteMany: {
            args: Prisma.ProductImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>[]
          }
          upsert: {
            args: Prisma.ProductImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImagePayload>
          }
          aggregate: {
            args: Prisma.ProductImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImage>
          }
          groupBy: {
            args: Prisma.ProductImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageCountAggregateOutputType> | number
          }
        }
      }
      ProductOption: {
        payload: Prisma.$ProductOptionPayload<ExtArgs>
        fields: Prisma.ProductOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          findFirst: {
            args: Prisma.ProductOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          findMany: {
            args: Prisma.ProductOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          create: {
            args: Prisma.ProductOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          createMany: {
            args: Prisma.ProductOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          delete: {
            args: Prisma.ProductOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          update: {
            args: Prisma.ProductOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          deleteMany: {
            args: Prisma.ProductOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>[]
          }
          upsert: {
            args: Prisma.ProductOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionPayload>
          }
          aggregate: {
            args: Prisma.ProductOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductOption>
          }
          groupBy: {
            args: Prisma.ProductOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductOptionCountArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionCountAggregateOutputType> | number
          }
        }
      }
      ProductOptionValue: {
        payload: Prisma.$ProductOptionValuePayload<ExtArgs>
        fields: Prisma.ProductOptionValueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductOptionValueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductOptionValueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          findFirst: {
            args: Prisma.ProductOptionValueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductOptionValueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          findMany: {
            args: Prisma.ProductOptionValueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>[]
          }
          create: {
            args: Prisma.ProductOptionValueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          createMany: {
            args: Prisma.ProductOptionValueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductOptionValueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>[]
          }
          delete: {
            args: Prisma.ProductOptionValueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          update: {
            args: Prisma.ProductOptionValueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          deleteMany: {
            args: Prisma.ProductOptionValueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductOptionValueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductOptionValueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>[]
          }
          upsert: {
            args: Prisma.ProductOptionValueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductOptionValuePayload>
          }
          aggregate: {
            args: Prisma.ProductOptionValueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductOptionValue>
          }
          groupBy: {
            args: Prisma.ProductOptionValueGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionValueGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductOptionValueCountArgs<ExtArgs>
            result: $Utils.Optional<ProductOptionValueCountAggregateOutputType> | number
          }
        }
      }
      VariantOption: {
        payload: Prisma.$VariantOptionPayload<ExtArgs>
        fields: Prisma.VariantOptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantOptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantOptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          findFirst: {
            args: Prisma.VariantOptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantOptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          findMany: {
            args: Prisma.VariantOptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>[]
          }
          create: {
            args: Prisma.VariantOptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          createMany: {
            args: Prisma.VariantOptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantOptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>[]
          }
          delete: {
            args: Prisma.VariantOptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          update: {
            args: Prisma.VariantOptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          deleteMany: {
            args: Prisma.VariantOptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantOptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariantOptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>[]
          }
          upsert: {
            args: Prisma.VariantOptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantOptionPayload>
          }
          aggregate: {
            args: Prisma.VariantOptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariantOption>
          }
          groupBy: {
            args: Prisma.VariantOptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantOptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantOptionCountArgs<ExtArgs>
            result: $Utils.Optional<VariantOptionCountAggregateOutputType> | number
          }
        }
      }
      Variant: {
        payload: Prisma.$VariantPayload<ExtArgs>
        fields: Prisma.VariantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findFirst: {
            args: Prisma.VariantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          findMany: {
            args: Prisma.VariantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          create: {
            args: Prisma.VariantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          createMany: {
            args: Prisma.VariantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          delete: {
            args: Prisma.VariantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          update: {
            args: Prisma.VariantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          deleteMany: {
            args: Prisma.VariantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariantUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>[]
          }
          upsert: {
            args: Prisma.VariantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantPayload>
          }
          aggregate: {
            args: Prisma.VariantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariant>
          }
          groupBy: {
            args: Prisma.VariantGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantCountArgs<ExtArgs>
            result: $Utils.Optional<VariantCountAggregateOutputType> | number
          }
        }
      }
      VariantImage: {
        payload: Prisma.$VariantImagePayload<ExtArgs>
        fields: Prisma.VariantImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VariantImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VariantImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          findFirst: {
            args: Prisma.VariantImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VariantImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          findMany: {
            args: Prisma.VariantImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
          }
          create: {
            args: Prisma.VariantImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          createMany: {
            args: Prisma.VariantImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VariantImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
          }
          delete: {
            args: Prisma.VariantImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          update: {
            args: Prisma.VariantImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          deleteMany: {
            args: Prisma.VariantImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VariantImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VariantImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>[]
          }
          upsert: {
            args: Prisma.VariantImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VariantImagePayload>
          }
          aggregate: {
            args: Prisma.VariantImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariantImage>
          }
          groupBy: {
            args: Prisma.VariantImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.VariantImageCountArgs<ExtArgs>
            result: $Utils.Optional<VariantImageCountAggregateOutputType> | number
          }
        }
      }
      Tag: {
        payload: Prisma.$TagPayload<ExtArgs>
        fields: Prisma.TagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findFirst: {
            args: Prisma.TagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          findMany: {
            args: Prisma.TagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          create: {
            args: Prisma.TagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          createMany: {
            args: Prisma.TagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          delete: {
            args: Prisma.TagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          update: {
            args: Prisma.TagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          deleteMany: {
            args: Prisma.TagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>[]
          }
          upsert: {
            args: Prisma.TagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TagPayload>
          }
          aggregate: {
            args: Prisma.TagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTag>
          }
          groupBy: {
            args: Prisma.TagGroupByArgs<ExtArgs>
            result: $Utils.Optional<TagGroupByOutputType>[]
          }
          count: {
            args: Prisma.TagCountArgs<ExtArgs>
            result: $Utils.Optional<TagCountAggregateOutputType> | number
          }
        }
      }
      ProductTag: {
        payload: Prisma.$ProductTagPayload<ExtArgs>
        fields: Prisma.ProductTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          findFirst: {
            args: Prisma.ProductTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          findMany: {
            args: Prisma.ProductTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
          }
          create: {
            args: Prisma.ProductTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          createMany: {
            args: Prisma.ProductTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProductTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
          }
          delete: {
            args: Prisma.ProductTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          update: {
            args: Prisma.ProductTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          deleteMany: {
            args: Prisma.ProductTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>[]
          }
          upsert: {
            args: Prisma.ProductTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductTagPayload>
          }
          aggregate: {
            args: Prisma.ProductTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductTag>
          }
          groupBy: {
            args: Prisma.ProductTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductTagCountArgs<ExtArgs>
            result: $Utils.Optional<ProductTagCountAggregateOutputType> | number
          }
        }
      }
      ProductImageEmbedding: {
        payload: Prisma.$ProductImageEmbeddingPayload<ExtArgs>
        fields: Prisma.ProductImageEmbeddingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProductImageEmbeddingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProductImageEmbeddingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>
          }
          findFirst: {
            args: Prisma.ProductImageEmbeddingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProductImageEmbeddingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>
          }
          findMany: {
            args: Prisma.ProductImageEmbeddingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>[]
          }
          delete: {
            args: Prisma.ProductImageEmbeddingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>
          }
          update: {
            args: Prisma.ProductImageEmbeddingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>
          }
          deleteMany: {
            args: Prisma.ProductImageEmbeddingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProductImageEmbeddingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProductImageEmbeddingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProductImageEmbeddingPayload>[]
          }
          aggregate: {
            args: Prisma.ProductImageEmbeddingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProductImageEmbedding>
          }
          groupBy: {
            args: Prisma.ProductImageEmbeddingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProductImageEmbeddingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProductImageEmbeddingCountArgs<ExtArgs>
            result: $Utils.Optional<ProductImageEmbeddingCountAggregateOutputType> | number
          }
        }
      }
      Review: {
        payload: Prisma.$ReviewPayload<ExtArgs>
        fields: Prisma.ReviewFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findFirst: {
            args: Prisma.ReviewFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          findMany: {
            args: Prisma.ReviewFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          create: {
            args: Prisma.ReviewCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          createMany: {
            args: Prisma.ReviewCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          delete: {
            args: Prisma.ReviewDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          update: {
            args: Prisma.ReviewUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          deleteMany: {
            args: Prisma.ReviewDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>[]
          }
          upsert: {
            args: Prisma.ReviewUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewPayload>
          }
          aggregate: {
            args: Prisma.ReviewAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReview>
          }
          groupBy: {
            args: Prisma.ReviewGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewCountAggregateOutputType> | number
          }
        }
      }
      ReviewImage: {
        payload: Prisma.$ReviewImagePayload<ExtArgs>
        fields: Prisma.ReviewImageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewImageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewImageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          findFirst: {
            args: Prisma.ReviewImageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewImageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          findMany: {
            args: Prisma.ReviewImageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>[]
          }
          create: {
            args: Prisma.ReviewImageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          createMany: {
            args: Prisma.ReviewImageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewImageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>[]
          }
          delete: {
            args: Prisma.ReviewImageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          update: {
            args: Prisma.ReviewImageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          deleteMany: {
            args: Prisma.ReviewImageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewImageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewImageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>[]
          }
          upsert: {
            args: Prisma.ReviewImageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewImagePayload>
          }
          aggregate: {
            args: Prisma.ReviewImageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewImage>
          }
          groupBy: {
            args: Prisma.ReviewImageGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewImageGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewImageCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewImageCountAggregateOutputType> | number
          }
        }
      }
      ReviewVote: {
        payload: Prisma.$ReviewVotePayload<ExtArgs>
        fields: Prisma.ReviewVoteFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewVoteFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewVoteFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findFirst: {
            args: Prisma.ReviewVoteFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewVoteFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          findMany: {
            args: Prisma.ReviewVoteFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          create: {
            args: Prisma.ReviewVoteCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          createMany: {
            args: Prisma.ReviewVoteCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewVoteCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          delete: {
            args: Prisma.ReviewVoteDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          update: {
            args: Prisma.ReviewVoteUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          deleteMany: {
            args: Prisma.ReviewVoteDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewVoteUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewVoteUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>[]
          }
          upsert: {
            args: Prisma.ReviewVoteUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewVotePayload>
          }
          aggregate: {
            args: Prisma.ReviewVoteAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewVote>
          }
          groupBy: {
            args: Prisma.ReviewVoteGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewVoteCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewVoteCountAggregateOutputType> | number
          }
        }
      }
      ReviewReport: {
        payload: Prisma.$ReviewReportPayload<ExtArgs>
        fields: Prisma.ReviewReportFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewReportFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewReportFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          findFirst: {
            args: Prisma.ReviewReportFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewReportFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          findMany: {
            args: Prisma.ReviewReportFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          create: {
            args: Prisma.ReviewReportCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          createMany: {
            args: Prisma.ReviewReportCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewReportCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          delete: {
            args: Prisma.ReviewReportDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          update: {
            args: Prisma.ReviewReportUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          deleteMany: {
            args: Prisma.ReviewReportDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewReportUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewReportUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>[]
          }
          upsert: {
            args: Prisma.ReviewReportUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReportPayload>
          }
          aggregate: {
            args: Prisma.ReviewReportAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewReport>
          }
          groupBy: {
            args: Prisma.ReviewReportGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewReportGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewReportCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewReportCountAggregateOutputType> | number
          }
        }
      }
      ReviewReply: {
        payload: Prisma.$ReviewReplyPayload<ExtArgs>
        fields: Prisma.ReviewReplyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReviewReplyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReviewReplyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          findFirst: {
            args: Prisma.ReviewReplyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReviewReplyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          findMany: {
            args: Prisma.ReviewReplyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          create: {
            args: Prisma.ReviewReplyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          createMany: {
            args: Prisma.ReviewReplyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReviewReplyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          delete: {
            args: Prisma.ReviewReplyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          update: {
            args: Prisma.ReviewReplyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          deleteMany: {
            args: Prisma.ReviewReplyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReviewReplyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ReviewReplyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>[]
          }
          upsert: {
            args: Prisma.ReviewReplyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReviewReplyPayload>
          }
          aggregate: {
            args: Prisma.ReviewReplyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReviewReply>
          }
          groupBy: {
            args: Prisma.ReviewReplyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReviewReplyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReviewReplyCountArgs<ExtArgs>
            result: $Utils.Optional<ReviewReplyCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      NotificationRecipient: {
        payload: Prisma.$NotificationRecipientPayload<ExtArgs>
        fields: Prisma.NotificationRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          findFirst: {
            args: Prisma.NotificationRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          findMany: {
            args: Prisma.NotificationRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          create: {
            args: Prisma.NotificationRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          createMany: {
            args: Prisma.NotificationRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          delete: {
            args: Prisma.NotificationRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          update: {
            args: Prisma.NotificationRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          deleteMany: {
            args: Prisma.NotificationRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>[]
          }
          upsert: {
            args: Prisma.NotificationRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationRecipientPayload>
          }
          aggregate: {
            args: Prisma.NotificationRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotificationRecipient>
          }
          groupBy: {
            args: Prisma.NotificationRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationRecipientCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    account?: AccountOmit
    deviceToken?: DeviceTokenOmit
    user?: UserOmit
    address?: AddressOmit
    brand?: BrandOmit
    refreshToken?: RefreshTokenOmit
    privateConversation?: PrivateConversationOmit
    privateConversationParticipant?: PrivateConversationParticipantOmit
    privateMessage?: PrivateMessageOmit
    privateMessageAttachment?: PrivateMessageAttachmentOmit
    privateMessageVisibility?: PrivateMessageVisibilityOmit
    product?: ProductOmit
    productImage?: ProductImageOmit
    productOption?: ProductOptionOmit
    productOptionValue?: ProductOptionValueOmit
    variantOption?: VariantOptionOmit
    variant?: VariantOmit
    variantImage?: VariantImageOmit
    tag?: TagOmit
    productTag?: ProductTagOmit
    productImageEmbedding?: ProductImageEmbeddingOmit
    review?: ReviewOmit
    reviewImage?: ReviewImageOmit
    reviewVote?: ReviewVoteOmit
    reviewReport?: ReviewReportOmit
    reviewReply?: ReviewReplyOmit
    notification?: NotificationOmit
    notificationRecipient?: NotificationRecipientOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AccountCountOutputType
   */

  export type AccountCountOutputType = {
    refreshTokens: number
    ConversationParticipant: number
    sentPrivateMessages: number
    reactedMessages: number
    privateMessageVisibilities: number
    Notification: number
    NotificationRecipient: number
    deviceTokens: number
  }

  export type AccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | AccountCountOutputTypeCountRefreshTokensArgs
    ConversationParticipant?: boolean | AccountCountOutputTypeCountConversationParticipantArgs
    sentPrivateMessages?: boolean | AccountCountOutputTypeCountSentPrivateMessagesArgs
    reactedMessages?: boolean | AccountCountOutputTypeCountReactedMessagesArgs
    privateMessageVisibilities?: boolean | AccountCountOutputTypeCountPrivateMessageVisibilitiesArgs
    Notification?: boolean | AccountCountOutputTypeCountNotificationArgs
    NotificationRecipient?: boolean | AccountCountOutputTypeCountNotificationRecipientArgs
    deviceTokens?: boolean | AccountCountOutputTypeCountDeviceTokensArgs
  }

  // Custom InputTypes
  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccountCountOutputType
     */
    select?: AccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountRefreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateConversationParticipantWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountSentPrivateMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountReactedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountPrivateMessageVisibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageVisibilityWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountNotificationRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
  }

  /**
   * AccountCountOutputType without action
   */
  export type AccountCountOutputTypeCountDeviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    addresses: number
    reviews: number
    reviewVotes: number
    reviewReports: number
    reviewReplays: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    addresses?: boolean | UserCountOutputTypeCountAddressesArgs
    reviews?: boolean | UserCountOutputTypeCountReviewsArgs
    reviewVotes?: boolean | UserCountOutputTypeCountReviewVotesArgs
    reviewReports?: boolean | UserCountOutputTypeCountReviewReportsArgs
    reviewReplays?: boolean | UserCountOutputTypeCountReviewReplaysArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAddressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReviewReplaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
  }


  /**
   * Count Type BrandCountOutputType
   */

  export type BrandCountOutputType = {
    Products: number
  }

  export type BrandCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Products?: boolean | BrandCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandCountOutputType
     */
    select?: BrandCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandCountOutputType without action
   */
  export type BrandCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
  }


  /**
   * Count Type PrivateConversationCountOutputType
   */

  export type PrivateConversationCountOutputType = {
    participants: number
    messages: number
  }

  export type PrivateConversationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | PrivateConversationCountOutputTypeCountParticipantsArgs
    messages?: boolean | PrivateConversationCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * PrivateConversationCountOutputType without action
   */
  export type PrivateConversationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationCountOutputType
     */
    select?: PrivateConversationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrivateConversationCountOutputType without action
   */
  export type PrivateConversationCountOutputTypeCountParticipantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateConversationParticipantWhereInput
  }

  /**
   * PrivateConversationCountOutputType without action
   */
  export type PrivateConversationCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageWhereInput
  }


  /**
   * Count Type PrivateMessageCountOutputType
   */

  export type PrivateMessageCountOutputType = {
    attachments: number
    visibilities: number
  }

  export type PrivateMessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attachments?: boolean | PrivateMessageCountOutputTypeCountAttachmentsArgs
    visibilities?: boolean | PrivateMessageCountOutputTypeCountVisibilitiesArgs
  }

  // Custom InputTypes
  /**
   * PrivateMessageCountOutputType without action
   */
  export type PrivateMessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageCountOutputType
     */
    select?: PrivateMessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PrivateMessageCountOutputType without action
   */
  export type PrivateMessageCountOutputTypeCountAttachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageAttachmentWhereInput
  }

  /**
   * PrivateMessageCountOutputType without action
   */
  export type PrivateMessageCountOutputTypeCountVisibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageVisibilityWhereInput
  }


  /**
   * Count Type ProductCountOutputType
   */

  export type ProductCountOutputType = {
    images: number
    variants: number
    options: number
    tags: number
    reviews: number
    imageVectors: number
  }

  export type ProductCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ProductCountOutputTypeCountImagesArgs
    variants?: boolean | ProductCountOutputTypeCountVariantsArgs
    options?: boolean | ProductCountOutputTypeCountOptionsArgs
    tags?: boolean | ProductCountOutputTypeCountTagsArgs
    reviews?: boolean | ProductCountOutputTypeCountReviewsArgs
    imageVectors?: boolean | ProductCountOutputTypeCountImageVectorsArgs
  }

  // Custom InputTypes
  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     */
    select?: ProductCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountTagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountReviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
  }

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeCountImageVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageEmbeddingWhereInput
  }


  /**
   * Count Type ProductOptionCountOutputType
   */

  export type ProductOptionCountOutputType = {
    values: number
    VariantOption: number
  }

  export type ProductOptionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    values?: boolean | ProductOptionCountOutputTypeCountValuesArgs
    VariantOption?: boolean | ProductOptionCountOutputTypeCountVariantOptionArgs
  }

  // Custom InputTypes
  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionCountOutputType
     */
    select?: ProductOptionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeCountValuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionValueWhereInput
  }

  /**
   * ProductOptionCountOutputType without action
   */
  export type ProductOptionCountOutputTypeCountVariantOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantOptionWhereInput
  }


  /**
   * Count Type ProductOptionValueCountOutputType
   */

  export type ProductOptionValueCountOutputType = {
    variantLinks: number
  }

  export type ProductOptionValueCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variantLinks?: boolean | ProductOptionValueCountOutputTypeCountVariantLinksArgs
  }

  // Custom InputTypes
  /**
   * ProductOptionValueCountOutputType without action
   */
  export type ProductOptionValueCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValueCountOutputType
     */
    select?: ProductOptionValueCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProductOptionValueCountOutputType without action
   */
  export type ProductOptionValueCountOutputTypeCountVariantLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantOptionWhereInput
  }


  /**
   * Count Type VariantCountOutputType
   */

  export type VariantCountOutputType = {
    images: number
    options: number
  }

  export type VariantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | VariantCountOutputTypeCountImagesArgs
    options?: boolean | VariantCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantCountOutputType
     */
    select?: VariantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantImageWhereInput
  }

  /**
   * VariantCountOutputType without action
   */
  export type VariantCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantOptionWhereInput
  }


  /**
   * Count Type TagCountOutputType
   */

  export type TagCountOutputType = {
    products: number
  }

  export type TagCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | TagCountOutputTypeCountProductsArgs
  }

  // Custom InputTypes
  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TagCountOutputType
     */
    select?: TagCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TagCountOutputType without action
   */
  export type TagCountOutputTypeCountProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
  }


  /**
   * Count Type ReviewCountOutputType
   */

  export type ReviewCountOutputType = {
    images: number
    votes: number
    reports: number
    replies: number
  }

  export type ReviewCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | ReviewCountOutputTypeCountImagesArgs
    votes?: boolean | ReviewCountOutputTypeCountVotesArgs
    reports?: boolean | ReviewCountOutputTypeCountReportsArgs
    replies?: boolean | ReviewCountOutputTypeCountRepliesArgs
  }

  // Custom InputTypes
  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewCountOutputType
     */
    select?: ReviewCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewImageWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
  }

  /**
   * ReviewCountOutputType without action
   */
  export type ReviewCountOutputTypeCountRepliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
  }


  /**
   * Count Type NotificationCountOutputType
   */

  export type NotificationCountOutputType = {
    recipients: number
  }

  export type NotificationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | NotificationCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationCountOutputType
     */
    select?: NotificationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * NotificationCountOutputType without action
   */
  export type NotificationCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.Status | null
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    passwordResetCode: string | null
    passwordResetCodeExpiresAt: Date | null
    provider: $Enums.Provider | null
    providerId: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email: string | null
    password: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
    status: $Enums.Status | null
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    passwordResetCode: string | null
    passwordResetCodeExpiresAt: Date | null
    provider: $Enums.Provider | null
    providerId: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    name: number
    email: number
    password: number
    role: number
    createdAt: number
    updatedAt: number
    status: number
    verificationCode: number
    verificationCodeExpiresAt: number
    passwordResetCode: number
    passwordResetCodeExpiresAt: number
    provider: number
    providerId: number
    _all: number
  }


  export type AccountMinAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    passwordResetCode?: true
    passwordResetCodeExpiresAt?: true
    provider?: true
    providerId?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    passwordResetCode?: true
    passwordResetCodeExpiresAt?: true
    provider?: true
    providerId?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    name?: true
    email?: true
    password?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    status?: true
    verificationCode?: true
    verificationCodeExpiresAt?: true
    passwordResetCode?: true
    passwordResetCodeExpiresAt?: true
    provider?: true
    providerId?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    name: string
    email: string
    password: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    status: $Enums.Status
    verificationCode: string | null
    verificationCodeExpiresAt: Date | null
    passwordResetCode: string | null
    passwordResetCodeExpiresAt: Date | null
    provider: $Enums.Provider
    providerId: string | null
    _count: AccountCountAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    passwordResetCode?: boolean
    passwordResetCodeExpiresAt?: boolean
    provider?: boolean
    providerId?: boolean
    refreshTokens?: boolean | Account$refreshTokensArgs<ExtArgs>
    user?: boolean | Account$userArgs<ExtArgs>
    brand?: boolean | Account$brandArgs<ExtArgs>
    ConversationParticipant?: boolean | Account$ConversationParticipantArgs<ExtArgs>
    sentPrivateMessages?: boolean | Account$sentPrivateMessagesArgs<ExtArgs>
    reactedMessages?: boolean | Account$reactedMessagesArgs<ExtArgs>
    privateMessageVisibilities?: boolean | Account$privateMessageVisibilitiesArgs<ExtArgs>
    Notification?: boolean | Account$NotificationArgs<ExtArgs>
    NotificationRecipient?: boolean | Account$NotificationRecipientArgs<ExtArgs>
    deviceTokens?: boolean | Account$deviceTokensArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    passwordResetCode?: boolean
    passwordResetCodeExpiresAt?: boolean
    provider?: boolean
    providerId?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    passwordResetCode?: boolean
    passwordResetCodeExpiresAt?: boolean
    provider?: boolean
    providerId?: boolean
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    name?: boolean
    email?: boolean
    password?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    status?: boolean
    verificationCode?: boolean
    verificationCodeExpiresAt?: boolean
    passwordResetCode?: boolean
    passwordResetCodeExpiresAt?: boolean
    provider?: boolean
    providerId?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email" | "password" | "role" | "createdAt" | "updatedAt" | "status" | "verificationCode" | "verificationCodeExpiresAt" | "passwordResetCode" | "passwordResetCodeExpiresAt" | "provider" | "providerId", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    refreshTokens?: boolean | Account$refreshTokensArgs<ExtArgs>
    user?: boolean | Account$userArgs<ExtArgs>
    brand?: boolean | Account$brandArgs<ExtArgs>
    ConversationParticipant?: boolean | Account$ConversationParticipantArgs<ExtArgs>
    sentPrivateMessages?: boolean | Account$sentPrivateMessagesArgs<ExtArgs>
    reactedMessages?: boolean | Account$reactedMessagesArgs<ExtArgs>
    privateMessageVisibilities?: boolean | Account$privateMessageVisibilitiesArgs<ExtArgs>
    Notification?: boolean | Account$NotificationArgs<ExtArgs>
    NotificationRecipient?: boolean | Account$NotificationRecipientArgs<ExtArgs>
    deviceTokens?: boolean | Account$deviceTokensArgs<ExtArgs>
    _count?: boolean | AccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      refreshTokens: Prisma.$RefreshTokenPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs> | null
      brand: Prisma.$BrandPayload<ExtArgs> | null
      ConversationParticipant: Prisma.$PrivateConversationParticipantPayload<ExtArgs>[]
      sentPrivateMessages: Prisma.$PrivateMessagePayload<ExtArgs>[]
      reactedMessages: Prisma.$PrivateMessagePayload<ExtArgs>[]
      privateMessageVisibilities: Prisma.$PrivateMessageVisibilityPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      NotificationRecipient: Prisma.$NotificationRecipientPayload<ExtArgs>[]
      deviceTokens: Prisma.$DeviceTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email: string
      password: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
      status: $Enums.Status
      verificationCode: string | null
      verificationCodeExpiresAt: Date | null
      passwordResetCode: string | null
      passwordResetCodeExpiresAt: Date | null
      provider: $Enums.Provider
      providerId: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    refreshTokens<T extends Account$refreshTokensArgs<ExtArgs> = {}>(args?: Subset<T, Account$refreshTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends Account$userArgs<ExtArgs> = {}>(args?: Subset<T, Account$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    brand<T extends Account$brandArgs<ExtArgs> = {}>(args?: Subset<T, Account$brandArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    ConversationParticipant<T extends Account$ConversationParticipantArgs<ExtArgs> = {}>(args?: Subset<T, Account$ConversationParticipantArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentPrivateMessages<T extends Account$sentPrivateMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Account$sentPrivateMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactedMessages<T extends Account$reactedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, Account$reactedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    privateMessageVisibilities<T extends Account$privateMessageVisibilitiesArgs<ExtArgs> = {}>(args?: Subset<T, Account$privateMessageVisibilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    Notification<T extends Account$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Account$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    NotificationRecipient<T extends Account$NotificationRecipientArgs<ExtArgs> = {}>(args?: Subset<T, Account$NotificationRecipientArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    deviceTokens<T extends Account$deviceTokensArgs<ExtArgs> = {}>(args?: Subset<T, Account$deviceTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly name: FieldRef<"Account", 'String'>
    readonly email: FieldRef<"Account", 'String'>
    readonly password: FieldRef<"Account", 'String'>
    readonly role: FieldRef<"Account", 'Role'>
    readonly createdAt: FieldRef<"Account", 'DateTime'>
    readonly updatedAt: FieldRef<"Account", 'DateTime'>
    readonly status: FieldRef<"Account", 'Status'>
    readonly verificationCode: FieldRef<"Account", 'String'>
    readonly verificationCodeExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly passwordResetCode: FieldRef<"Account", 'String'>
    readonly passwordResetCodeExpiresAt: FieldRef<"Account", 'DateTime'>
    readonly provider: FieldRef<"Account", 'Provider'>
    readonly providerId: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account.refreshTokens
   */
  export type Account$refreshTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    cursor?: RefreshTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * Account.user
   */
  export type Account$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Account.brand
   */
  export type Account$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    where?: BrandWhereInput
  }

  /**
   * Account.ConversationParticipant
   */
  export type Account$ConversationParticipantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    where?: PrivateConversationParticipantWhereInput
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    cursor?: PrivateConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateConversationParticipantScalarFieldEnum | PrivateConversationParticipantScalarFieldEnum[]
  }

  /**
   * Account.sentPrivateMessages
   */
  export type Account$sentPrivateMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    where?: PrivateMessageWhereInput
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    cursor?: PrivateMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * Account.reactedMessages
   */
  export type Account$reactedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    where?: PrivateMessageWhereInput
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    cursor?: PrivateMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * Account.privateMessageVisibilities
   */
  export type Account$privateMessageVisibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    where?: PrivateMessageVisibilityWhereInput
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageVisibilityScalarFieldEnum | PrivateMessageVisibilityScalarFieldEnum[]
  }

  /**
   * Account.Notification
   */
  export type Account$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Account.NotificationRecipient
   */
  export type Account$NotificationRecipientArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    cursor?: NotificationRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * Account.deviceTokens
   */
  export type Account$deviceTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    cursor?: DeviceTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model DeviceToken
   */

  export type AggregateDeviceToken = {
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  export type DeviceTokenMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    lastSeenAt: Date | null
  }

  export type DeviceTokenMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isActive: boolean | null
    lastSeenAt: Date | null
  }

  export type DeviceTokenCountAggregateOutputType = {
    id: number
    accountId: number
    token: number
    createdAt: number
    updatedAt: number
    isActive: number
    lastSeenAt: number
    _all: number
  }


  export type DeviceTokenMinAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    lastSeenAt?: true
  }

  export type DeviceTokenMaxAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    lastSeenAt?: true
  }

  export type DeviceTokenCountAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    createdAt?: true
    updatedAt?: true
    isActive?: true
    lastSeenAt?: true
    _all?: true
  }

  export type DeviceTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceToken to aggregate.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DeviceTokens
    **/
    _count?: true | DeviceTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type GetDeviceTokenAggregateType<T extends DeviceTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDeviceToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDeviceToken[P]>
      : GetScalarType<T[P], AggregateDeviceToken[P]>
  }




  export type DeviceTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceTokenWhereInput
    orderBy?: DeviceTokenOrderByWithAggregationInput | DeviceTokenOrderByWithAggregationInput[]
    by: DeviceTokenScalarFieldEnum[] | DeviceTokenScalarFieldEnum
    having?: DeviceTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceTokenCountAggregateInputType | true
    _min?: DeviceTokenMinAggregateInputType
    _max?: DeviceTokenMaxAggregateInputType
  }

  export type DeviceTokenGroupByOutputType = {
    id: string
    accountId: string
    token: string
    createdAt: Date
    updatedAt: Date
    isActive: boolean
    lastSeenAt: Date
    _count: DeviceTokenCountAggregateOutputType | null
    _min: DeviceTokenMinAggregateOutputType | null
    _max: DeviceTokenMaxAggregateOutputType | null
  }

  type GetDeviceTokenGroupByPayload<T extends DeviceTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceTokenGroupByOutputType[P]>
        }
      >
    >


  export type DeviceTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    lastSeenAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    lastSeenAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    lastSeenAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["deviceToken"]>

  export type DeviceTokenSelectScalar = {
    id?: boolean
    accountId?: boolean
    token?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isActive?: boolean
    lastSeenAt?: boolean
  }

  export type DeviceTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "token" | "createdAt" | "updatedAt" | "isActive" | "lastSeenAt", ExtArgs["result"]["deviceToken"]>
  export type DeviceTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type DeviceTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $DeviceTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DeviceToken"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      token: string
      createdAt: Date
      updatedAt: Date
      isActive: boolean
      lastSeenAt: Date
    }, ExtArgs["result"]["deviceToken"]>
    composites: {}
  }

  type DeviceTokenGetPayload<S extends boolean | null | undefined | DeviceTokenDefaultArgs> = $Result.GetResult<Prisma.$DeviceTokenPayload, S>

  type DeviceTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceTokenCountAggregateInputType | true
    }

  export interface DeviceTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DeviceToken'], meta: { name: 'DeviceToken' } }
    /**
     * Find zero or one DeviceToken that matches the filter.
     * @param {DeviceTokenFindUniqueArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceTokenFindUniqueArgs>(args: SelectSubset<T, DeviceTokenFindUniqueArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DeviceToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceTokenFindUniqueOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceTokenFindFirstArgs>(args?: SelectSubset<T, DeviceTokenFindFirstArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DeviceToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindFirstOrThrowArgs} args - Arguments to find a DeviceToken
     * @example
     * // Get one DeviceToken
     * const deviceToken = await prisma.deviceToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DeviceTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany()
     * 
     * // Get first 10 DeviceTokens
     * const deviceTokens = await prisma.deviceToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceTokenFindManyArgs>(args?: SelectSubset<T, DeviceTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DeviceToken.
     * @param {DeviceTokenCreateArgs} args - Arguments to create a DeviceToken.
     * @example
     * // Create one DeviceToken
     * const DeviceToken = await prisma.deviceToken.create({
     *   data: {
     *     // ... data to create a DeviceToken
     *   }
     * })
     * 
     */
    create<T extends DeviceTokenCreateArgs>(args: SelectSubset<T, DeviceTokenCreateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DeviceTokens.
     * @param {DeviceTokenCreateManyArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceTokenCreateManyArgs>(args?: SelectSubset<T, DeviceTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DeviceTokens and returns the data saved in the database.
     * @param {DeviceTokenCreateManyAndReturnArgs} args - Arguments to create many DeviceTokens.
     * @example
     * // Create many DeviceTokens
     * const deviceToken = await prisma.deviceToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DeviceToken.
     * @param {DeviceTokenDeleteArgs} args - Arguments to delete one DeviceToken.
     * @example
     * // Delete one DeviceToken
     * const DeviceToken = await prisma.deviceToken.delete({
     *   where: {
     *     // ... filter to delete one DeviceToken
     *   }
     * })
     * 
     */
    delete<T extends DeviceTokenDeleteArgs>(args: SelectSubset<T, DeviceTokenDeleteArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DeviceToken.
     * @param {DeviceTokenUpdateArgs} args - Arguments to update one DeviceToken.
     * @example
     * // Update one DeviceToken
     * const deviceToken = await prisma.deviceToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceTokenUpdateArgs>(args: SelectSubset<T, DeviceTokenUpdateArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DeviceTokens.
     * @param {DeviceTokenDeleteManyArgs} args - Arguments to filter DeviceTokens to delete.
     * @example
     * // Delete a few DeviceTokens
     * const { count } = await prisma.deviceToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceTokenDeleteManyArgs>(args?: SelectSubset<T, DeviceTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceTokenUpdateManyArgs>(args: SelectSubset<T, DeviceTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DeviceTokens and returns the data updated in the database.
     * @param {DeviceTokenUpdateManyAndReturnArgs} args - Arguments to update many DeviceTokens.
     * @example
     * // Update many DeviceTokens
     * const deviceToken = await prisma.deviceToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DeviceTokens and only return the `id`
     * const deviceTokenWithIdOnly = await prisma.deviceToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DeviceToken.
     * @param {DeviceTokenUpsertArgs} args - Arguments to update or create a DeviceToken.
     * @example
     * // Update or create a DeviceToken
     * const deviceToken = await prisma.deviceToken.upsert({
     *   create: {
     *     // ... data to create a DeviceToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DeviceToken we want to update
     *   }
     * })
     */
    upsert<T extends DeviceTokenUpsertArgs>(args: SelectSubset<T, DeviceTokenUpsertArgs<ExtArgs>>): Prisma__DeviceTokenClient<$Result.GetResult<Prisma.$DeviceTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DeviceTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenCountArgs} args - Arguments to filter DeviceTokens to count.
     * @example
     * // Count the number of DeviceTokens
     * const count = await prisma.deviceToken.count({
     *   where: {
     *     // ... the filter for the DeviceTokens we want to count
     *   }
     * })
    **/
    count<T extends DeviceTokenCountArgs>(
      args?: Subset<T, DeviceTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceTokenAggregateArgs>(args: Subset<T, DeviceTokenAggregateArgs>): Prisma.PrismaPromise<GetDeviceTokenAggregateType<T>>

    /**
     * Group by DeviceToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceTokenGroupByArgs['orderBy'] }
        : { orderBy?: DeviceTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DeviceToken model
   */
  readonly fields: DeviceTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DeviceToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DeviceToken model
   */
  interface DeviceTokenFieldRefs {
    readonly id: FieldRef<"DeviceToken", 'String'>
    readonly accountId: FieldRef<"DeviceToken", 'String'>
    readonly token: FieldRef<"DeviceToken", 'String'>
    readonly createdAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly updatedAt: FieldRef<"DeviceToken", 'DateTime'>
    readonly isActive: FieldRef<"DeviceToken", 'Boolean'>
    readonly lastSeenAt: FieldRef<"DeviceToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DeviceToken findUnique
   */
  export type DeviceTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findUniqueOrThrow
   */
  export type DeviceTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken findFirst
   */
  export type DeviceTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findFirstOrThrow
   */
  export type DeviceTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceToken to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DeviceTokens.
     */
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken findMany
   */
  export type DeviceTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter, which DeviceTokens to fetch.
     */
    where?: DeviceTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DeviceTokens to fetch.
     */
    orderBy?: DeviceTokenOrderByWithRelationInput | DeviceTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DeviceTokens.
     */
    cursor?: DeviceTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DeviceTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DeviceTokens.
     */
    skip?: number
    distinct?: DeviceTokenScalarFieldEnum | DeviceTokenScalarFieldEnum[]
  }

  /**
   * DeviceToken create
   */
  export type DeviceTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a DeviceToken.
     */
    data: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
  }

  /**
   * DeviceToken createMany
   */
  export type DeviceTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DeviceToken createManyAndReturn
   */
  export type DeviceTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to create many DeviceTokens.
     */
    data: DeviceTokenCreateManyInput | DeviceTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken update
   */
  export type DeviceTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a DeviceToken.
     */
    data: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
    /**
     * Choose, which DeviceToken to update.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken updateMany
   */
  export type DeviceTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
  }

  /**
   * DeviceToken updateManyAndReturn
   */
  export type DeviceTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * The data used to update DeviceTokens.
     */
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyInput>
    /**
     * Filter which DeviceTokens to update
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DeviceToken upsert
   */
  export type DeviceTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the DeviceToken to update in case it exists.
     */
    where: DeviceTokenWhereUniqueInput
    /**
     * In case the DeviceToken found by the `where` argument doesn't exist, create a new DeviceToken with this data.
     */
    create: XOR<DeviceTokenCreateInput, DeviceTokenUncheckedCreateInput>
    /**
     * In case the DeviceToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceTokenUpdateInput, DeviceTokenUncheckedUpdateInput>
  }

  /**
   * DeviceToken delete
   */
  export type DeviceTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
    /**
     * Filter which DeviceToken to delete.
     */
    where: DeviceTokenWhereUniqueInput
  }

  /**
   * DeviceToken deleteMany
   */
  export type DeviceTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DeviceTokens to delete
     */
    where?: DeviceTokenWhereInput
    /**
     * Limit how many DeviceTokens to delete.
     */
    limit?: number
  }

  /**
   * DeviceToken without action
   */
  export type DeviceTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DeviceToken
     */
    select?: DeviceTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DeviceToken
     */
    omit?: DeviceTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceTokenInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    userName: string | null
    photo: string | null
    phone: string | null
    photoPublicId: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    userName: string | null
    photo: string | null
    phone: string | null
    photoPublicId: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    accountId: number
    userName: number
    photo: number
    phone: number
    photoPublicId: number
    gender: number
    birthDate: number
    createdAt: number
    updatedAt: number
    paymentMethods: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    accountId?: true
    userName?: true
    photo?: true
    phone?: true
    photoPublicId?: true
    gender?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    accountId?: true
    userName?: true
    photo?: true
    phone?: true
    photoPublicId?: true
    gender?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    accountId?: true
    userName?: true
    photo?: true
    phone?: true
    photoPublicId?: true
    gender?: true
    birthDate?: true
    createdAt?: true
    updatedAt?: true
    paymentMethods?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    accountId: string
    userName: string
    photo: string | null
    phone: string | null
    photoPublicId: string | null
    gender: $Enums.Gender | null
    birthDate: Date | null
    createdAt: Date
    updatedAt: Date
    paymentMethods: $Enums.PaymentMethod[]
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userName?: boolean
    photo?: boolean
    phone?: boolean
    photoPublicId?: boolean
    gender?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethods?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    reviewReports?: boolean | User$reviewReportsArgs<ExtArgs>
    reviewReplays?: boolean | User$reviewReplaysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userName?: boolean
    photo?: boolean
    phone?: boolean
    photoPublicId?: boolean
    gender?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethods?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    userName?: boolean
    photo?: boolean
    phone?: boolean
    photoPublicId?: boolean
    gender?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethods?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    accountId?: boolean
    userName?: boolean
    photo?: boolean
    phone?: boolean
    photoPublicId?: boolean
    gender?: boolean
    birthDate?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    paymentMethods?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "userName" | "photo" | "phone" | "photoPublicId" | "gender" | "birthDate" | "createdAt" | "updatedAt" | "paymentMethods", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    addresses?: boolean | User$addressesArgs<ExtArgs>
    reviews?: boolean | User$reviewsArgs<ExtArgs>
    reviewVotes?: boolean | User$reviewVotesArgs<ExtArgs>
    reviewReports?: boolean | User$reviewReportsArgs<ExtArgs>
    reviewReplays?: boolean | User$reviewReplaysArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      addresses: Prisma.$AddressPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      reviewVotes: Prisma.$ReviewVotePayload<ExtArgs>[]
      reviewReports: Prisma.$ReviewReportPayload<ExtArgs>[]
      reviewReplays: Prisma.$ReviewReplyPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      userName: string
      photo: string | null
      phone: string | null
      photoPublicId: string | null
      gender: $Enums.Gender | null
      birthDate: Date | null
      createdAt: Date
      updatedAt: Date
      paymentMethods: $Enums.PaymentMethod[]
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    addresses<T extends User$addressesArgs<ExtArgs> = {}>(args?: Subset<T, User$addressesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends User$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewVotes<T extends User$reviewVotesArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewVotesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewReports<T extends User$reviewReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviewReplays<T extends User$reviewReplaysArgs<ExtArgs> = {}>(args?: Subset<T, User$reviewReplaysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly accountId: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly photo: FieldRef<"User", 'String'>
    readonly phone: FieldRef<"User", 'String'>
    readonly photoPublicId: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'Gender'>
    readonly birthDate: FieldRef<"User", 'DateTime'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly paymentMethods: FieldRef<"User", 'PaymentMethod[]'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.addresses
   */
  export type User$addressesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    cursor?: AddressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * User.reviews
   */
  export type User$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * User.reviewVotes
   */
  export type User$reviewVotesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * User.reviewReports
   */
  export type User$reviewReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    cursor?: ReviewReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * User.reviewReplays
   */
  export type User$reviewReplaysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    cursor?: ReviewReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Address
   */

  export type AggregateAddress = {
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  export type AddressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    government: string | null
    city: string | null
    addressLine: string | null
    landmark: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    government: string | null
    city: string | null
    addressLine: string | null
    landmark: string | null
    isPrimary: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AddressCountAggregateOutputType = {
    id: number
    userId: number
    government: number
    city: number
    addressLine: number
    landmark: number
    isPrimary: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AddressMinAggregateInputType = {
    id?: true
    userId?: true
    government?: true
    city?: true
    addressLine?: true
    landmark?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressMaxAggregateInputType = {
    id?: true
    userId?: true
    government?: true
    city?: true
    addressLine?: true
    landmark?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AddressCountAggregateInputType = {
    id?: true
    userId?: true
    government?: true
    city?: true
    addressLine?: true
    landmark?: true
    isPrimary?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AddressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Address to aggregate.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Addresses
    **/
    _count?: true | AddressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AddressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AddressMaxAggregateInputType
  }

  export type GetAddressAggregateType<T extends AddressAggregateArgs> = {
        [P in keyof T & keyof AggregateAddress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAddress[P]>
      : GetScalarType<T[P], AggregateAddress[P]>
  }




  export type AddressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AddressWhereInput
    orderBy?: AddressOrderByWithAggregationInput | AddressOrderByWithAggregationInput[]
    by: AddressScalarFieldEnum[] | AddressScalarFieldEnum
    having?: AddressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AddressCountAggregateInputType | true
    _min?: AddressMinAggregateInputType
    _max?: AddressMaxAggregateInputType
  }

  export type AddressGroupByOutputType = {
    id: string
    userId: string
    government: string | null
    city: string | null
    addressLine: string | null
    landmark: string | null
    isPrimary: boolean
    createdAt: Date
    updatedAt: Date
    _count: AddressCountAggregateOutputType | null
    _min: AddressMinAggregateOutputType | null
    _max: AddressMaxAggregateOutputType | null
  }

  type GetAddressGroupByPayload<T extends AddressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AddressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AddressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AddressGroupByOutputType[P]>
            : GetScalarType<T[P], AddressGroupByOutputType[P]>
        }
      >
    >


  export type AddressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    government?: boolean
    city?: boolean
    addressLine?: boolean
    landmark?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    government?: boolean
    city?: boolean
    addressLine?: boolean
    landmark?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    government?: boolean
    city?: boolean
    addressLine?: boolean
    landmark?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["address"]>

  export type AddressSelectScalar = {
    id?: boolean
    userId?: boolean
    government?: boolean
    city?: boolean
    addressLine?: boolean
    landmark?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AddressOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "government" | "city" | "addressLine" | "landmark" | "isPrimary" | "createdAt" | "updatedAt", ExtArgs["result"]["address"]>
  export type AddressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AddressIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AddressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Address"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      government: string | null
      city: string | null
      addressLine: string | null
      landmark: string | null
      isPrimary: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["address"]>
    composites: {}
  }

  type AddressGetPayload<S extends boolean | null | undefined | AddressDefaultArgs> = $Result.GetResult<Prisma.$AddressPayload, S>

  type AddressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AddressFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AddressCountAggregateInputType | true
    }

  export interface AddressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Address'], meta: { name: 'Address' } }
    /**
     * Find zero or one Address that matches the filter.
     * @param {AddressFindUniqueArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AddressFindUniqueArgs>(args: SelectSubset<T, AddressFindUniqueArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Address that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AddressFindUniqueOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AddressFindUniqueOrThrowArgs>(args: SelectSubset<T, AddressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AddressFindFirstArgs>(args?: SelectSubset<T, AddressFindFirstArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Address that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindFirstOrThrowArgs} args - Arguments to find a Address
     * @example
     * // Get one Address
     * const address = await prisma.address.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AddressFindFirstOrThrowArgs>(args?: SelectSubset<T, AddressFindFirstOrThrowArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Addresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Addresses
     * const addresses = await prisma.address.findMany()
     * 
     * // Get first 10 Addresses
     * const addresses = await prisma.address.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const addressWithIdOnly = await prisma.address.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AddressFindManyArgs>(args?: SelectSubset<T, AddressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Address.
     * @param {AddressCreateArgs} args - Arguments to create a Address.
     * @example
     * // Create one Address
     * const Address = await prisma.address.create({
     *   data: {
     *     // ... data to create a Address
     *   }
     * })
     * 
     */
    create<T extends AddressCreateArgs>(args: SelectSubset<T, AddressCreateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Addresses.
     * @param {AddressCreateManyArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AddressCreateManyArgs>(args?: SelectSubset<T, AddressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Addresses and returns the data saved in the database.
     * @param {AddressCreateManyAndReturnArgs} args - Arguments to create many Addresses.
     * @example
     * // Create many Addresses
     * const address = await prisma.address.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AddressCreateManyAndReturnArgs>(args?: SelectSubset<T, AddressCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Address.
     * @param {AddressDeleteArgs} args - Arguments to delete one Address.
     * @example
     * // Delete one Address
     * const Address = await prisma.address.delete({
     *   where: {
     *     // ... filter to delete one Address
     *   }
     * })
     * 
     */
    delete<T extends AddressDeleteArgs>(args: SelectSubset<T, AddressDeleteArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Address.
     * @param {AddressUpdateArgs} args - Arguments to update one Address.
     * @example
     * // Update one Address
     * const address = await prisma.address.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AddressUpdateArgs>(args: SelectSubset<T, AddressUpdateArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Addresses.
     * @param {AddressDeleteManyArgs} args - Arguments to filter Addresses to delete.
     * @example
     * // Delete a few Addresses
     * const { count } = await prisma.address.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AddressDeleteManyArgs>(args?: SelectSubset<T, AddressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AddressUpdateManyArgs>(args: SelectSubset<T, AddressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Addresses and returns the data updated in the database.
     * @param {AddressUpdateManyAndReturnArgs} args - Arguments to update many Addresses.
     * @example
     * // Update many Addresses
     * const address = await prisma.address.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Addresses and only return the `id`
     * const addressWithIdOnly = await prisma.address.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AddressUpdateManyAndReturnArgs>(args: SelectSubset<T, AddressUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Address.
     * @param {AddressUpsertArgs} args - Arguments to update or create a Address.
     * @example
     * // Update or create a Address
     * const address = await prisma.address.upsert({
     *   create: {
     *     // ... data to create a Address
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Address we want to update
     *   }
     * })
     */
    upsert<T extends AddressUpsertArgs>(args: SelectSubset<T, AddressUpsertArgs<ExtArgs>>): Prisma__AddressClient<$Result.GetResult<Prisma.$AddressPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Addresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressCountArgs} args - Arguments to filter Addresses to count.
     * @example
     * // Count the number of Addresses
     * const count = await prisma.address.count({
     *   where: {
     *     // ... the filter for the Addresses we want to count
     *   }
     * })
    **/
    count<T extends AddressCountArgs>(
      args?: Subset<T, AddressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AddressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AddressAggregateArgs>(args: Subset<T, AddressAggregateArgs>): Prisma.PrismaPromise<GetAddressAggregateType<T>>

    /**
     * Group by Address.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AddressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AddressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AddressGroupByArgs['orderBy'] }
        : { orderBy?: AddressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AddressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAddressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Address model
   */
  readonly fields: AddressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Address.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AddressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Address model
   */
  interface AddressFieldRefs {
    readonly id: FieldRef<"Address", 'String'>
    readonly userId: FieldRef<"Address", 'String'>
    readonly government: FieldRef<"Address", 'String'>
    readonly city: FieldRef<"Address", 'String'>
    readonly addressLine: FieldRef<"Address", 'String'>
    readonly landmark: FieldRef<"Address", 'String'>
    readonly isPrimary: FieldRef<"Address", 'Boolean'>
    readonly createdAt: FieldRef<"Address", 'DateTime'>
    readonly updatedAt: FieldRef<"Address", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Address findUnique
   */
  export type AddressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findUniqueOrThrow
   */
  export type AddressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address findFirst
   */
  export type AddressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findFirstOrThrow
   */
  export type AddressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Address to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Addresses.
     */
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address findMany
   */
  export type AddressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter, which Addresses to fetch.
     */
    where?: AddressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Addresses to fetch.
     */
    orderBy?: AddressOrderByWithRelationInput | AddressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Addresses.
     */
    cursor?: AddressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Addresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Addresses.
     */
    skip?: number
    distinct?: AddressScalarFieldEnum | AddressScalarFieldEnum[]
  }

  /**
   * Address create
   */
  export type AddressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to create a Address.
     */
    data: XOR<AddressCreateInput, AddressUncheckedCreateInput>
  }

  /**
   * Address createMany
   */
  export type AddressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Address createManyAndReturn
   */
  export type AddressCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to create many Addresses.
     */
    data: AddressCreateManyInput | AddressCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address update
   */
  export type AddressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The data needed to update a Address.
     */
    data: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
    /**
     * Choose, which Address to update.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address updateMany
   */
  export type AddressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
  }

  /**
   * Address updateManyAndReturn
   */
  export type AddressUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * The data used to update Addresses.
     */
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyInput>
    /**
     * Filter which Addresses to update
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Address upsert
   */
  export type AddressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * The filter to search for the Address to update in case it exists.
     */
    where: AddressWhereUniqueInput
    /**
     * In case the Address found by the `where` argument doesn't exist, create a new Address with this data.
     */
    create: XOR<AddressCreateInput, AddressUncheckedCreateInput>
    /**
     * In case the Address was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AddressUpdateInput, AddressUncheckedUpdateInput>
  }

  /**
   * Address delete
   */
  export type AddressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
    /**
     * Filter which Address to delete.
     */
    where: AddressWhereUniqueInput
  }

  /**
   * Address deleteMany
   */
  export type AddressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Addresses to delete
     */
    where?: AddressWhereInput
    /**
     * Limit how many Addresses to delete.
     */
    limit?: number
  }

  /**
   * Address without action
   */
  export type AddressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Address
     */
    select?: AddressSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Address
     */
    omit?: AddressOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AddressInclude<ExtArgs> | null
  }


  /**
   * Model Brand
   */

  export type AggregateBrand = {
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  export type BrandMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    description: string | null
    logo: string | null
    status: $Enums.BrandStatus | null
    instagramUrl: string | null
    tiktokUrl: string | null
    businessPhone: string | null
    ownerName: string | null
    ownerNationalId: string | null
    ownerPhone: string | null
    crn: string | null
    taxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    description: string | null
    logo: string | null
    status: $Enums.BrandStatus | null
    instagramUrl: string | null
    tiktokUrl: string | null
    businessPhone: string | null
    ownerName: string | null
    ownerNationalId: string | null
    ownerPhone: string | null
    crn: string | null
    taxId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandCountAggregateOutputType = {
    id: number
    accountId: number
    description: number
    logo: number
    categories: number
    status: number
    instagramUrl: number
    tiktokUrl: number
    businessPhone: number
    ownerName: number
    ownerNationalId: number
    ownerPhone: number
    crn: number
    taxId: number
    paymentMethods: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandMinAggregateInputType = {
    id?: true
    accountId?: true
    description?: true
    logo?: true
    status?: true
    instagramUrl?: true
    tiktokUrl?: true
    businessPhone?: true
    ownerName?: true
    ownerNationalId?: true
    ownerPhone?: true
    crn?: true
    taxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandMaxAggregateInputType = {
    id?: true
    accountId?: true
    description?: true
    logo?: true
    status?: true
    instagramUrl?: true
    tiktokUrl?: true
    businessPhone?: true
    ownerName?: true
    ownerNationalId?: true
    ownerPhone?: true
    crn?: true
    taxId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandCountAggregateInputType = {
    id?: true
    accountId?: true
    description?: true
    logo?: true
    categories?: true
    status?: true
    instagramUrl?: true
    tiktokUrl?: true
    businessPhone?: true
    ownerName?: true
    ownerNationalId?: true
    ownerPhone?: true
    crn?: true
    taxId?: true
    paymentMethods?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brand to aggregate.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Brands
    **/
    _count?: true | BrandCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandMaxAggregateInputType
  }

  export type GetBrandAggregateType<T extends BrandAggregateArgs> = {
        [P in keyof T & keyof AggregateBrand]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrand[P]>
      : GetScalarType<T[P], AggregateBrand[P]>
  }




  export type BrandGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BrandWhereInput
    orderBy?: BrandOrderByWithAggregationInput | BrandOrderByWithAggregationInput[]
    by: BrandScalarFieldEnum[] | BrandScalarFieldEnum
    having?: BrandScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandCountAggregateInputType | true
    _min?: BrandMinAggregateInputType
    _max?: BrandMaxAggregateInputType
  }

  export type BrandGroupByOutputType = {
    id: string
    accountId: string
    description: string | null
    logo: string | null
    categories: $Enums.Category[]
    status: $Enums.BrandStatus
    instagramUrl: string | null
    tiktokUrl: string | null
    businessPhone: string | null
    ownerName: string | null
    ownerNationalId: string | null
    ownerPhone: string | null
    crn: string | null
    taxId: string | null
    paymentMethods: $Enums.PaymentMethod[]
    createdAt: Date
    updatedAt: Date
    _count: BrandCountAggregateOutputType | null
    _min: BrandMinAggregateOutputType | null
    _max: BrandMaxAggregateOutputType | null
  }

  type GetBrandGroupByPayload<T extends BrandGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandGroupByOutputType[P]>
            : GetScalarType<T[P], BrandGroupByOutputType[P]>
        }
      >
    >


  export type BrandSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    description?: boolean
    logo?: boolean
    categories?: boolean
    status?: boolean
    instagramUrl?: boolean
    tiktokUrl?: boolean
    businessPhone?: boolean
    ownerName?: boolean
    ownerNationalId?: boolean
    ownerPhone?: boolean
    crn?: boolean
    taxId?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
    Products?: boolean | Brand$ProductsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    description?: boolean
    logo?: boolean
    categories?: boolean
    status?: boolean
    instagramUrl?: boolean
    tiktokUrl?: boolean
    businessPhone?: boolean
    ownerName?: boolean
    ownerNationalId?: boolean
    ownerPhone?: boolean
    crn?: boolean
    taxId?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    description?: boolean
    logo?: boolean
    categories?: boolean
    status?: boolean
    instagramUrl?: boolean
    tiktokUrl?: boolean
    businessPhone?: boolean
    ownerName?: boolean
    ownerNationalId?: boolean
    ownerPhone?: boolean
    crn?: boolean
    taxId?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brand"]>

  export type BrandSelectScalar = {
    id?: boolean
    accountId?: boolean
    description?: boolean
    logo?: boolean
    categories?: boolean
    status?: boolean
    instagramUrl?: boolean
    tiktokUrl?: boolean
    businessPhone?: boolean
    ownerName?: boolean
    ownerNationalId?: boolean
    ownerPhone?: boolean
    crn?: boolean
    taxId?: boolean
    paymentMethods?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BrandOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "description" | "logo" | "categories" | "status" | "instagramUrl" | "tiktokUrl" | "businessPhone" | "ownerName" | "ownerNationalId" | "ownerPhone" | "crn" | "taxId" | "paymentMethods" | "createdAt" | "updatedAt", ExtArgs["result"]["brand"]>
  export type BrandInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
    Products?: boolean | Brand$ProductsArgs<ExtArgs>
    _count?: boolean | BrandCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BrandIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type BrandIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $BrandPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Brand"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
      Products: Prisma.$ProductPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      description: string | null
      logo: string | null
      categories: $Enums.Category[]
      status: $Enums.BrandStatus
      instagramUrl: string | null
      tiktokUrl: string | null
      businessPhone: string | null
      ownerName: string | null
      ownerNationalId: string | null
      ownerPhone: string | null
      crn: string | null
      taxId: string | null
      paymentMethods: $Enums.PaymentMethod[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brand"]>
    composites: {}
  }

  type BrandGetPayload<S extends boolean | null | undefined | BrandDefaultArgs> = $Result.GetResult<Prisma.$BrandPayload, S>

  type BrandCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BrandFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandCountAggregateInputType | true
    }

  export interface BrandDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Brand'], meta: { name: 'Brand' } }
    /**
     * Find zero or one Brand that matches the filter.
     * @param {BrandFindUniqueArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BrandFindUniqueArgs>(args: SelectSubset<T, BrandFindUniqueArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brand that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BrandFindUniqueOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BrandFindUniqueOrThrowArgs>(args: SelectSubset<T, BrandFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BrandFindFirstArgs>(args?: SelectSubset<T, BrandFindFirstArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brand that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindFirstOrThrowArgs} args - Arguments to find a Brand
     * @example
     * // Get one Brand
     * const brand = await prisma.brand.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BrandFindFirstOrThrowArgs>(args?: SelectSubset<T, BrandFindFirstOrThrowArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brand.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brand.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandWithIdOnly = await prisma.brand.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BrandFindManyArgs>(args?: SelectSubset<T, BrandFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brand.
     * @param {BrandCreateArgs} args - Arguments to create a Brand.
     * @example
     * // Create one Brand
     * const Brand = await prisma.brand.create({
     *   data: {
     *     // ... data to create a Brand
     *   }
     * })
     * 
     */
    create<T extends BrandCreateArgs>(args: SelectSubset<T, BrandCreateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {BrandCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BrandCreateManyArgs>(args?: SelectSubset<T, BrandCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Brands and returns the data saved in the database.
     * @param {BrandCreateManyAndReturnArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brand = await prisma.brand.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BrandCreateManyAndReturnArgs>(args?: SelectSubset<T, BrandCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Brand.
     * @param {BrandDeleteArgs} args - Arguments to delete one Brand.
     * @example
     * // Delete one Brand
     * const Brand = await prisma.brand.delete({
     *   where: {
     *     // ... filter to delete one Brand
     *   }
     * })
     * 
     */
    delete<T extends BrandDeleteArgs>(args: SelectSubset<T, BrandDeleteArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brand.
     * @param {BrandUpdateArgs} args - Arguments to update one Brand.
     * @example
     * // Update one Brand
     * const brand = await prisma.brand.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BrandUpdateArgs>(args: SelectSubset<T, BrandUpdateArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {BrandDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brand.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BrandDeleteManyArgs>(args?: SelectSubset<T, BrandDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BrandUpdateManyArgs>(args: SelectSubset<T, BrandUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands and returns the data updated in the database.
     * @param {BrandUpdateManyAndReturnArgs} args - Arguments to update many Brands.
     * @example
     * // Update many Brands
     * const brand = await prisma.brand.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Brands and only return the `id`
     * const brandWithIdOnly = await prisma.brand.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BrandUpdateManyAndReturnArgs>(args: SelectSubset<T, BrandUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Brand.
     * @param {BrandUpsertArgs} args - Arguments to update or create a Brand.
     * @example
     * // Update or create a Brand
     * const brand = await prisma.brand.upsert({
     *   create: {
     *     // ... data to create a Brand
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brand we want to update
     *   }
     * })
     */
    upsert<T extends BrandUpsertArgs>(args: SelectSubset<T, BrandUpsertArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brand.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends BrandCountArgs>(
      args?: Subset<T, BrandCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandAggregateArgs>(args: Subset<T, BrandAggregateArgs>): Prisma.PrismaPromise<GetBrandAggregateType<T>>

    /**
     * Group by Brand.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BrandGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BrandGroupByArgs['orderBy'] }
        : { orderBy?: BrandGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BrandGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Brand model
   */
  readonly fields: BrandFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Brand.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BrandClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    Products<T extends Brand$ProductsArgs<ExtArgs> = {}>(args?: Subset<T, Brand$ProductsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Brand model
   */
  interface BrandFieldRefs {
    readonly id: FieldRef<"Brand", 'String'>
    readonly accountId: FieldRef<"Brand", 'String'>
    readonly description: FieldRef<"Brand", 'String'>
    readonly logo: FieldRef<"Brand", 'String'>
    readonly categories: FieldRef<"Brand", 'Category[]'>
    readonly status: FieldRef<"Brand", 'BrandStatus'>
    readonly instagramUrl: FieldRef<"Brand", 'String'>
    readonly tiktokUrl: FieldRef<"Brand", 'String'>
    readonly businessPhone: FieldRef<"Brand", 'String'>
    readonly ownerName: FieldRef<"Brand", 'String'>
    readonly ownerNationalId: FieldRef<"Brand", 'String'>
    readonly ownerPhone: FieldRef<"Brand", 'String'>
    readonly crn: FieldRef<"Brand", 'String'>
    readonly taxId: FieldRef<"Brand", 'String'>
    readonly paymentMethods: FieldRef<"Brand", 'PaymentMethod[]'>
    readonly createdAt: FieldRef<"Brand", 'DateTime'>
    readonly updatedAt: FieldRef<"Brand", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Brand findUnique
   */
  export type BrandFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findUniqueOrThrow
   */
  export type BrandFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand findFirst
   */
  export type BrandFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findFirstOrThrow
   */
  export type BrandFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brand to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Brands.
     */
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand findMany
   */
  export type BrandFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter, which Brands to fetch.
     */
    where?: BrandWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Brands to fetch.
     */
    orderBy?: BrandOrderByWithRelationInput | BrandOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Brands.
     */
    cursor?: BrandWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Brands.
     */
    skip?: number
    distinct?: BrandScalarFieldEnum | BrandScalarFieldEnum[]
  }

  /**
   * Brand create
   */
  export type BrandCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to create a Brand.
     */
    data: XOR<BrandCreateInput, BrandUncheckedCreateInput>
  }

  /**
   * Brand createMany
   */
  export type BrandCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Brand createManyAndReturn
   */
  export type BrandCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to create many Brands.
     */
    data: BrandCreateManyInput | BrandCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand update
   */
  export type BrandUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The data needed to update a Brand.
     */
    data: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
    /**
     * Choose, which Brand to update.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand updateMany
   */
  export type BrandUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
  }

  /**
   * Brand updateManyAndReturn
   */
  export type BrandUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * The data used to update Brands.
     */
    data: XOR<BrandUpdateManyMutationInput, BrandUncheckedUpdateManyInput>
    /**
     * Filter which Brands to update
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Brand upsert
   */
  export type BrandUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * The filter to search for the Brand to update in case it exists.
     */
    where: BrandWhereUniqueInput
    /**
     * In case the Brand found by the `where` argument doesn't exist, create a new Brand with this data.
     */
    create: XOR<BrandCreateInput, BrandUncheckedCreateInput>
    /**
     * In case the Brand was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BrandUpdateInput, BrandUncheckedUpdateInput>
  }

  /**
   * Brand delete
   */
  export type BrandDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
    /**
     * Filter which Brand to delete.
     */
    where: BrandWhereUniqueInput
  }

  /**
   * Brand deleteMany
   */
  export type BrandDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Brands to delete
     */
    where?: BrandWhereInput
    /**
     * Limit how many Brands to delete.
     */
    limit?: number
  }

  /**
   * Brand.Products
   */
  export type Brand$ProductsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    cursor?: ProductWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Brand without action
   */
  export type BrandDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Brand
     */
    select?: BrandSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Brand
     */
    omit?: BrandOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BrandInclude<ExtArgs> | null
  }


  /**
   * Model RefreshToken
   */

  export type AggregateRefreshToken = {
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  export type RefreshTokenMinAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    revokedReason: $Enums.RevokedReason | null
    jti: string | null
  }

  export type RefreshTokenMaxAggregateOutputType = {
    id: string | null
    accountId: string | null
    token: string | null
    expiresAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    revokedAt: Date | null
    revokedReason: $Enums.RevokedReason | null
    jti: string | null
  }

  export type RefreshTokenCountAggregateOutputType = {
    id: number
    accountId: number
    token: number
    expiresAt: number
    createdAt: number
    updatedAt: number
    revokedAt: number
    revokedReason: number
    jti: number
    _all: number
  }


  export type RefreshTokenMinAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    revokedReason?: true
    jti?: true
  }

  export type RefreshTokenMaxAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    revokedReason?: true
    jti?: true
  }

  export type RefreshTokenCountAggregateInputType = {
    id?: true
    accountId?: true
    token?: true
    expiresAt?: true
    createdAt?: true
    updatedAt?: true
    revokedAt?: true
    revokedReason?: true
    jti?: true
    _all?: true
  }

  export type RefreshTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshToken to aggregate.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RefreshTokens
    **/
    _count?: true | RefreshTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RefreshTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type GetRefreshTokenAggregateType<T extends RefreshTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateRefreshToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRefreshToken[P]>
      : GetScalarType<T[P], AggregateRefreshToken[P]>
  }




  export type RefreshTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RefreshTokenWhereInput
    orderBy?: RefreshTokenOrderByWithAggregationInput | RefreshTokenOrderByWithAggregationInput[]
    by: RefreshTokenScalarFieldEnum[] | RefreshTokenScalarFieldEnum
    having?: RefreshTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RefreshTokenCountAggregateInputType | true
    _min?: RefreshTokenMinAggregateInputType
    _max?: RefreshTokenMaxAggregateInputType
  }

  export type RefreshTokenGroupByOutputType = {
    id: string
    accountId: string
    token: string
    expiresAt: Date
    createdAt: Date
    updatedAt: Date
    revokedAt: Date | null
    revokedReason: $Enums.RevokedReason | null
    jti: string
    _count: RefreshTokenCountAggregateOutputType | null
    _min: RefreshTokenMinAggregateOutputType | null
    _max: RefreshTokenMaxAggregateOutputType | null
  }

  type GetRefreshTokenGroupByPayload<T extends RefreshTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RefreshTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RefreshTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
            : GetScalarType<T[P], RefreshTokenGroupByOutputType[P]>
        }
      >
    >


  export type RefreshTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    jti?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    jti?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    jti?: boolean
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["refreshToken"]>

  export type RefreshTokenSelectScalar = {
    id?: boolean
    accountId?: boolean
    token?: boolean
    expiresAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    revokedAt?: boolean
    revokedReason?: boolean
    jti?: boolean
  }

  export type RefreshTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "accountId" | "token" | "expiresAt" | "createdAt" | "updatedAt" | "revokedAt" | "revokedReason" | "jti", ExtArgs["result"]["refreshToken"]>
  export type RefreshTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type RefreshTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $RefreshTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RefreshToken"
    objects: {
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      accountId: string
      token: string
      expiresAt: Date
      createdAt: Date
      updatedAt: Date
      revokedAt: Date | null
      revokedReason: $Enums.RevokedReason | null
      jti: string
    }, ExtArgs["result"]["refreshToken"]>
    composites: {}
  }

  type RefreshTokenGetPayload<S extends boolean | null | undefined | RefreshTokenDefaultArgs> = $Result.GetResult<Prisma.$RefreshTokenPayload, S>

  type RefreshTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RefreshTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RefreshTokenCountAggregateInputType | true
    }

  export interface RefreshTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RefreshToken'], meta: { name: 'RefreshToken' } }
    /**
     * Find zero or one RefreshToken that matches the filter.
     * @param {RefreshTokenFindUniqueArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RefreshTokenFindUniqueArgs>(args: SelectSubset<T, RefreshTokenFindUniqueArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RefreshToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RefreshTokenFindUniqueOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RefreshTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, RefreshTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RefreshTokenFindFirstArgs>(args?: SelectSubset<T, RefreshTokenFindFirstArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RefreshToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindFirstOrThrowArgs} args - Arguments to find a RefreshToken
     * @example
     * // Get one RefreshToken
     * const refreshToken = await prisma.refreshToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RefreshTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, RefreshTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RefreshTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany()
     * 
     * // Get first 10 RefreshTokens
     * const refreshTokens = await prisma.refreshToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RefreshTokenFindManyArgs>(args?: SelectSubset<T, RefreshTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RefreshToken.
     * @param {RefreshTokenCreateArgs} args - Arguments to create a RefreshToken.
     * @example
     * // Create one RefreshToken
     * const RefreshToken = await prisma.refreshToken.create({
     *   data: {
     *     // ... data to create a RefreshToken
     *   }
     * })
     * 
     */
    create<T extends RefreshTokenCreateArgs>(args: SelectSubset<T, RefreshTokenCreateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RefreshTokens.
     * @param {RefreshTokenCreateManyArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RefreshTokenCreateManyArgs>(args?: SelectSubset<T, RefreshTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RefreshTokens and returns the data saved in the database.
     * @param {RefreshTokenCreateManyAndReturnArgs} args - Arguments to create many RefreshTokens.
     * @example
     * // Create many RefreshTokens
     * const refreshToken = await prisma.refreshToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RefreshTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, RefreshTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RefreshToken.
     * @param {RefreshTokenDeleteArgs} args - Arguments to delete one RefreshToken.
     * @example
     * // Delete one RefreshToken
     * const RefreshToken = await prisma.refreshToken.delete({
     *   where: {
     *     // ... filter to delete one RefreshToken
     *   }
     * })
     * 
     */
    delete<T extends RefreshTokenDeleteArgs>(args: SelectSubset<T, RefreshTokenDeleteArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RefreshToken.
     * @param {RefreshTokenUpdateArgs} args - Arguments to update one RefreshToken.
     * @example
     * // Update one RefreshToken
     * const refreshToken = await prisma.refreshToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RefreshTokenUpdateArgs>(args: SelectSubset<T, RefreshTokenUpdateArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RefreshTokens.
     * @param {RefreshTokenDeleteManyArgs} args - Arguments to filter RefreshTokens to delete.
     * @example
     * // Delete a few RefreshTokens
     * const { count } = await prisma.refreshToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RefreshTokenDeleteManyArgs>(args?: SelectSubset<T, RefreshTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RefreshTokenUpdateManyArgs>(args: SelectSubset<T, RefreshTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RefreshTokens and returns the data updated in the database.
     * @param {RefreshTokenUpdateManyAndReturnArgs} args - Arguments to update many RefreshTokens.
     * @example
     * // Update many RefreshTokens
     * const refreshToken = await prisma.refreshToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RefreshTokens and only return the `id`
     * const refreshTokenWithIdOnly = await prisma.refreshToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RefreshTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, RefreshTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RefreshToken.
     * @param {RefreshTokenUpsertArgs} args - Arguments to update or create a RefreshToken.
     * @example
     * // Update or create a RefreshToken
     * const refreshToken = await prisma.refreshToken.upsert({
     *   create: {
     *     // ... data to create a RefreshToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RefreshToken we want to update
     *   }
     * })
     */
    upsert<T extends RefreshTokenUpsertArgs>(args: SelectSubset<T, RefreshTokenUpsertArgs<ExtArgs>>): Prisma__RefreshTokenClient<$Result.GetResult<Prisma.$RefreshTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RefreshTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenCountArgs} args - Arguments to filter RefreshTokens to count.
     * @example
     * // Count the number of RefreshTokens
     * const count = await prisma.refreshToken.count({
     *   where: {
     *     // ... the filter for the RefreshTokens we want to count
     *   }
     * })
    **/
    count<T extends RefreshTokenCountArgs>(
      args?: Subset<T, RefreshTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RefreshTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RefreshTokenAggregateArgs>(args: Subset<T, RefreshTokenAggregateArgs>): Prisma.PrismaPromise<GetRefreshTokenAggregateType<T>>

    /**
     * Group by RefreshToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RefreshTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RefreshTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RefreshTokenGroupByArgs['orderBy'] }
        : { orderBy?: RefreshTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RefreshTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRefreshTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RefreshToken model
   */
  readonly fields: RefreshTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RefreshToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RefreshTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RefreshToken model
   */
  interface RefreshTokenFieldRefs {
    readonly id: FieldRef<"RefreshToken", 'String'>
    readonly accountId: FieldRef<"RefreshToken", 'String'>
    readonly token: FieldRef<"RefreshToken", 'String'>
    readonly expiresAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly createdAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly updatedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedAt: FieldRef<"RefreshToken", 'DateTime'>
    readonly revokedReason: FieldRef<"RefreshToken", 'RevokedReason'>
    readonly jti: FieldRef<"RefreshToken", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RefreshToken findUnique
   */
  export type RefreshTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findUniqueOrThrow
   */
  export type RefreshTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken findFirst
   */
  export type RefreshTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findFirstOrThrow
   */
  export type RefreshTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshToken to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RefreshTokens.
     */
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken findMany
   */
  export type RefreshTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter, which RefreshTokens to fetch.
     */
    where?: RefreshTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RefreshTokens to fetch.
     */
    orderBy?: RefreshTokenOrderByWithRelationInput | RefreshTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RefreshTokens.
     */
    cursor?: RefreshTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RefreshTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RefreshTokens.
     */
    skip?: number
    distinct?: RefreshTokenScalarFieldEnum | RefreshTokenScalarFieldEnum[]
  }

  /**
   * RefreshToken create
   */
  export type RefreshTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a RefreshToken.
     */
    data: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
  }

  /**
   * RefreshToken createMany
   */
  export type RefreshTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RefreshToken createManyAndReturn
   */
  export type RefreshTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to create many RefreshTokens.
     */
    data: RefreshTokenCreateManyInput | RefreshTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken update
   */
  export type RefreshTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a RefreshToken.
     */
    data: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
    /**
     * Choose, which RefreshToken to update.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken updateMany
   */
  export type RefreshTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
  }

  /**
   * RefreshToken updateManyAndReturn
   */
  export type RefreshTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * The data used to update RefreshTokens.
     */
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyInput>
    /**
     * Filter which RefreshTokens to update
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * RefreshToken upsert
   */
  export type RefreshTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the RefreshToken to update in case it exists.
     */
    where: RefreshTokenWhereUniqueInput
    /**
     * In case the RefreshToken found by the `where` argument doesn't exist, create a new RefreshToken with this data.
     */
    create: XOR<RefreshTokenCreateInput, RefreshTokenUncheckedCreateInput>
    /**
     * In case the RefreshToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RefreshTokenUpdateInput, RefreshTokenUncheckedUpdateInput>
  }

  /**
   * RefreshToken delete
   */
  export type RefreshTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
    /**
     * Filter which RefreshToken to delete.
     */
    where: RefreshTokenWhereUniqueInput
  }

  /**
   * RefreshToken deleteMany
   */
  export type RefreshTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RefreshTokens to delete
     */
    where?: RefreshTokenWhereInput
    /**
     * Limit how many RefreshTokens to delete.
     */
    limit?: number
  }

  /**
   * RefreshToken without action
   */
  export type RefreshTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RefreshToken
     */
    select?: RefreshTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RefreshToken
     */
    omit?: RefreshTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RefreshTokenInclude<ExtArgs> | null
  }


  /**
   * Model PrivateConversation
   */

  export type AggregatePrivateConversation = {
    _count: PrivateConversationCountAggregateOutputType | null
    _min: PrivateConversationMinAggregateOutputType | null
    _max: PrivateConversationMaxAggregateOutputType | null
  }

  export type PrivateConversationMinAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archivedAt: Date | null
  }

  export type PrivateConversationMaxAggregateOutputType = {
    id: string | null
    createdAt: Date | null
    updatedAt: Date | null
    archivedAt: Date | null
  }

  export type PrivateConversationCountAggregateOutputType = {
    id: number
    createdAt: number
    updatedAt: number
    archivedAt: number
    _all: number
  }


  export type PrivateConversationMinAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
  }

  export type PrivateConversationMaxAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
  }

  export type PrivateConversationCountAggregateInputType = {
    id?: true
    createdAt?: true
    updatedAt?: true
    archivedAt?: true
    _all?: true
  }

  export type PrivateConversationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateConversation to aggregate.
     */
    where?: PrivateConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversations to fetch.
     */
    orderBy?: PrivateConversationOrderByWithRelationInput | PrivateConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateConversations
    **/
    _count?: true | PrivateConversationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateConversationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateConversationMaxAggregateInputType
  }

  export type GetPrivateConversationAggregateType<T extends PrivateConversationAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateConversation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateConversation[P]>
      : GetScalarType<T[P], AggregatePrivateConversation[P]>
  }




  export type PrivateConversationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateConversationWhereInput
    orderBy?: PrivateConversationOrderByWithAggregationInput | PrivateConversationOrderByWithAggregationInput[]
    by: PrivateConversationScalarFieldEnum[] | PrivateConversationScalarFieldEnum
    having?: PrivateConversationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateConversationCountAggregateInputType | true
    _min?: PrivateConversationMinAggregateInputType
    _max?: PrivateConversationMaxAggregateInputType
  }

  export type PrivateConversationGroupByOutputType = {
    id: string
    createdAt: Date
    updatedAt: Date
    archivedAt: Date | null
    _count: PrivateConversationCountAggregateOutputType | null
    _min: PrivateConversationMinAggregateOutputType | null
    _max: PrivateConversationMaxAggregateOutputType | null
  }

  type GetPrivateConversationGroupByPayload<T extends PrivateConversationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateConversationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateConversationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateConversationGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateConversationGroupByOutputType[P]>
        }
      >
    >


  export type PrivateConversationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
    participants?: boolean | PrivateConversation$participantsArgs<ExtArgs>
    messages?: boolean | PrivateConversation$messagesArgs<ExtArgs>
    _count?: boolean | PrivateConversationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateConversation"]>

  export type PrivateConversationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
  }, ExtArgs["result"]["privateConversation"]>

  export type PrivateConversationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
  }, ExtArgs["result"]["privateConversation"]>

  export type PrivateConversationSelectScalar = {
    id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    archivedAt?: boolean
  }

  export type PrivateConversationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "createdAt" | "updatedAt" | "archivedAt", ExtArgs["result"]["privateConversation"]>
  export type PrivateConversationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    participants?: boolean | PrivateConversation$participantsArgs<ExtArgs>
    messages?: boolean | PrivateConversation$messagesArgs<ExtArgs>
    _count?: boolean | PrivateConversationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrivateConversationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PrivateConversationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PrivateConversationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateConversation"
    objects: {
      participants: Prisma.$PrivateConversationParticipantPayload<ExtArgs>[]
      messages: Prisma.$PrivateMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      createdAt: Date
      updatedAt: Date
      archivedAt: Date | null
    }, ExtArgs["result"]["privateConversation"]>
    composites: {}
  }

  type PrivateConversationGetPayload<S extends boolean | null | undefined | PrivateConversationDefaultArgs> = $Result.GetResult<Prisma.$PrivateConversationPayload, S>

  type PrivateConversationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateConversationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateConversationCountAggregateInputType | true
    }

  export interface PrivateConversationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateConversation'], meta: { name: 'PrivateConversation' } }
    /**
     * Find zero or one PrivateConversation that matches the filter.
     * @param {PrivateConversationFindUniqueArgs} args - Arguments to find a PrivateConversation
     * @example
     * // Get one PrivateConversation
     * const privateConversation = await prisma.privateConversation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateConversationFindUniqueArgs>(args: SelectSubset<T, PrivateConversationFindUniqueArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateConversation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateConversationFindUniqueOrThrowArgs} args - Arguments to find a PrivateConversation
     * @example
     * // Get one PrivateConversation
     * const privateConversation = await prisma.privateConversation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateConversationFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateConversationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateConversation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationFindFirstArgs} args - Arguments to find a PrivateConversation
     * @example
     * // Get one PrivateConversation
     * const privateConversation = await prisma.privateConversation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateConversationFindFirstArgs>(args?: SelectSubset<T, PrivateConversationFindFirstArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateConversation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationFindFirstOrThrowArgs} args - Arguments to find a PrivateConversation
     * @example
     * // Get one PrivateConversation
     * const privateConversation = await prisma.privateConversation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateConversationFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateConversationFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateConversations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateConversations
     * const privateConversations = await prisma.privateConversation.findMany()
     * 
     * // Get first 10 PrivateConversations
     * const privateConversations = await prisma.privateConversation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateConversationWithIdOnly = await prisma.privateConversation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateConversationFindManyArgs>(args?: SelectSubset<T, PrivateConversationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateConversation.
     * @param {PrivateConversationCreateArgs} args - Arguments to create a PrivateConversation.
     * @example
     * // Create one PrivateConversation
     * const PrivateConversation = await prisma.privateConversation.create({
     *   data: {
     *     // ... data to create a PrivateConversation
     *   }
     * })
     * 
     */
    create<T extends PrivateConversationCreateArgs>(args: SelectSubset<T, PrivateConversationCreateArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateConversations.
     * @param {PrivateConversationCreateManyArgs} args - Arguments to create many PrivateConversations.
     * @example
     * // Create many PrivateConversations
     * const privateConversation = await prisma.privateConversation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateConversationCreateManyArgs>(args?: SelectSubset<T, PrivateConversationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateConversations and returns the data saved in the database.
     * @param {PrivateConversationCreateManyAndReturnArgs} args - Arguments to create many PrivateConversations.
     * @example
     * // Create many PrivateConversations
     * const privateConversation = await prisma.privateConversation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateConversations and only return the `id`
     * const privateConversationWithIdOnly = await prisma.privateConversation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateConversationCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateConversationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateConversation.
     * @param {PrivateConversationDeleteArgs} args - Arguments to delete one PrivateConversation.
     * @example
     * // Delete one PrivateConversation
     * const PrivateConversation = await prisma.privateConversation.delete({
     *   where: {
     *     // ... filter to delete one PrivateConversation
     *   }
     * })
     * 
     */
    delete<T extends PrivateConversationDeleteArgs>(args: SelectSubset<T, PrivateConversationDeleteArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateConversation.
     * @param {PrivateConversationUpdateArgs} args - Arguments to update one PrivateConversation.
     * @example
     * // Update one PrivateConversation
     * const privateConversation = await prisma.privateConversation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateConversationUpdateArgs>(args: SelectSubset<T, PrivateConversationUpdateArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateConversations.
     * @param {PrivateConversationDeleteManyArgs} args - Arguments to filter PrivateConversations to delete.
     * @example
     * // Delete a few PrivateConversations
     * const { count } = await prisma.privateConversation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateConversationDeleteManyArgs>(args?: SelectSubset<T, PrivateConversationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateConversations
     * const privateConversation = await prisma.privateConversation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateConversationUpdateManyArgs>(args: SelectSubset<T, PrivateConversationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateConversations and returns the data updated in the database.
     * @param {PrivateConversationUpdateManyAndReturnArgs} args - Arguments to update many PrivateConversations.
     * @example
     * // Update many PrivateConversations
     * const privateConversation = await prisma.privateConversation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateConversations and only return the `id`
     * const privateConversationWithIdOnly = await prisma.privateConversation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateConversationUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateConversationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateConversation.
     * @param {PrivateConversationUpsertArgs} args - Arguments to update or create a PrivateConversation.
     * @example
     * // Update or create a PrivateConversation
     * const privateConversation = await prisma.privateConversation.upsert({
     *   create: {
     *     // ... data to create a PrivateConversation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateConversation we want to update
     *   }
     * })
     */
    upsert<T extends PrivateConversationUpsertArgs>(args: SelectSubset<T, PrivateConversationUpsertArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateConversations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationCountArgs} args - Arguments to filter PrivateConversations to count.
     * @example
     * // Count the number of PrivateConversations
     * const count = await prisma.privateConversation.count({
     *   where: {
     *     // ... the filter for the PrivateConversations we want to count
     *   }
     * })
    **/
    count<T extends PrivateConversationCountArgs>(
      args?: Subset<T, PrivateConversationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateConversationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateConversationAggregateArgs>(args: Subset<T, PrivateConversationAggregateArgs>): Prisma.PrismaPromise<GetPrivateConversationAggregateType<T>>

    /**
     * Group by PrivateConversation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateConversationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateConversationGroupByArgs['orderBy'] }
        : { orderBy?: PrivateConversationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateConversationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateConversationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateConversation model
   */
  readonly fields: PrivateConversationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateConversation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateConversationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    participants<T extends PrivateConversation$participantsArgs<ExtArgs> = {}>(args?: Subset<T, PrivateConversation$participantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends PrivateConversation$messagesArgs<ExtArgs> = {}>(args?: Subset<T, PrivateConversation$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateConversation model
   */
  interface PrivateConversationFieldRefs {
    readonly id: FieldRef<"PrivateConversation", 'String'>
    readonly createdAt: FieldRef<"PrivateConversation", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateConversation", 'DateTime'>
    readonly archivedAt: FieldRef<"PrivateConversation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateConversation findUnique
   */
  export type PrivateConversationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversation to fetch.
     */
    where: PrivateConversationWhereUniqueInput
  }

  /**
   * PrivateConversation findUniqueOrThrow
   */
  export type PrivateConversationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversation to fetch.
     */
    where: PrivateConversationWhereUniqueInput
  }

  /**
   * PrivateConversation findFirst
   */
  export type PrivateConversationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversation to fetch.
     */
    where?: PrivateConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversations to fetch.
     */
    orderBy?: PrivateConversationOrderByWithRelationInput | PrivateConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateConversations.
     */
    cursor?: PrivateConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateConversations.
     */
    distinct?: PrivateConversationScalarFieldEnum | PrivateConversationScalarFieldEnum[]
  }

  /**
   * PrivateConversation findFirstOrThrow
   */
  export type PrivateConversationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversation to fetch.
     */
    where?: PrivateConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversations to fetch.
     */
    orderBy?: PrivateConversationOrderByWithRelationInput | PrivateConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateConversations.
     */
    cursor?: PrivateConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateConversations.
     */
    distinct?: PrivateConversationScalarFieldEnum | PrivateConversationScalarFieldEnum[]
  }

  /**
   * PrivateConversation findMany
   */
  export type PrivateConversationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversations to fetch.
     */
    where?: PrivateConversationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversations to fetch.
     */
    orderBy?: PrivateConversationOrderByWithRelationInput | PrivateConversationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateConversations.
     */
    cursor?: PrivateConversationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversations.
     */
    skip?: number
    distinct?: PrivateConversationScalarFieldEnum | PrivateConversationScalarFieldEnum[]
  }

  /**
   * PrivateConversation create
   */
  export type PrivateConversationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateConversation.
     */
    data: XOR<PrivateConversationCreateInput, PrivateConversationUncheckedCreateInput>
  }

  /**
   * PrivateConversation createMany
   */
  export type PrivateConversationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateConversations.
     */
    data: PrivateConversationCreateManyInput | PrivateConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateConversation createManyAndReturn
   */
  export type PrivateConversationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateConversations.
     */
    data: PrivateConversationCreateManyInput | PrivateConversationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateConversation update
   */
  export type PrivateConversationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateConversation.
     */
    data: XOR<PrivateConversationUpdateInput, PrivateConversationUncheckedUpdateInput>
    /**
     * Choose, which PrivateConversation to update.
     */
    where: PrivateConversationWhereUniqueInput
  }

  /**
   * PrivateConversation updateMany
   */
  export type PrivateConversationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateConversations.
     */
    data: XOR<PrivateConversationUpdateManyMutationInput, PrivateConversationUncheckedUpdateManyInput>
    /**
     * Filter which PrivateConversations to update
     */
    where?: PrivateConversationWhereInput
    /**
     * Limit how many PrivateConversations to update.
     */
    limit?: number
  }

  /**
   * PrivateConversation updateManyAndReturn
   */
  export type PrivateConversationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * The data used to update PrivateConversations.
     */
    data: XOR<PrivateConversationUpdateManyMutationInput, PrivateConversationUncheckedUpdateManyInput>
    /**
     * Filter which PrivateConversations to update
     */
    where?: PrivateConversationWhereInput
    /**
     * Limit how many PrivateConversations to update.
     */
    limit?: number
  }

  /**
   * PrivateConversation upsert
   */
  export type PrivateConversationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateConversation to update in case it exists.
     */
    where: PrivateConversationWhereUniqueInput
    /**
     * In case the PrivateConversation found by the `where` argument doesn't exist, create a new PrivateConversation with this data.
     */
    create: XOR<PrivateConversationCreateInput, PrivateConversationUncheckedCreateInput>
    /**
     * In case the PrivateConversation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateConversationUpdateInput, PrivateConversationUncheckedUpdateInput>
  }

  /**
   * PrivateConversation delete
   */
  export type PrivateConversationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
    /**
     * Filter which PrivateConversation to delete.
     */
    where: PrivateConversationWhereUniqueInput
  }

  /**
   * PrivateConversation deleteMany
   */
  export type PrivateConversationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateConversations to delete
     */
    where?: PrivateConversationWhereInput
    /**
     * Limit how many PrivateConversations to delete.
     */
    limit?: number
  }

  /**
   * PrivateConversation.participants
   */
  export type PrivateConversation$participantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    where?: PrivateConversationParticipantWhereInput
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    cursor?: PrivateConversationParticipantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateConversationParticipantScalarFieldEnum | PrivateConversationParticipantScalarFieldEnum[]
  }

  /**
   * PrivateConversation.messages
   */
  export type PrivateConversation$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    where?: PrivateMessageWhereInput
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    cursor?: PrivateMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * PrivateConversation without action
   */
  export type PrivateConversationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversation
     */
    select?: PrivateConversationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversation
     */
    omit?: PrivateConversationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationInclude<ExtArgs> | null
  }


  /**
   * Model PrivateConversationParticipant
   */

  export type AggregatePrivateConversationParticipant = {
    _count: PrivateConversationParticipantCountAggregateOutputType | null
    _avg: PrivateConversationParticipantAvgAggregateOutputType | null
    _sum: PrivateConversationParticipantSumAggregateOutputType | null
    _min: PrivateConversationParticipantMinAggregateOutputType | null
    _max: PrivateConversationParticipantMaxAggregateOutputType | null
  }

  export type PrivateConversationParticipantAvgAggregateOutputType = {
    unreadCount: number | null
  }

  export type PrivateConversationParticipantSumAggregateOutputType = {
    unreadCount: number | null
  }

  export type PrivateConversationParticipantMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    accountId: string | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateConversationParticipantMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    accountId: string | null
    unreadCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateConversationParticipantCountAggregateOutputType = {
    id: number
    conversationId: number
    accountId: number
    unreadCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivateConversationParticipantAvgAggregateInputType = {
    unreadCount?: true
  }

  export type PrivateConversationParticipantSumAggregateInputType = {
    unreadCount?: true
  }

  export type PrivateConversationParticipantMinAggregateInputType = {
    id?: true
    conversationId?: true
    accountId?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateConversationParticipantMaxAggregateInputType = {
    id?: true
    conversationId?: true
    accountId?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateConversationParticipantCountAggregateInputType = {
    id?: true
    conversationId?: true
    accountId?: true
    unreadCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivateConversationParticipantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateConversationParticipant to aggregate.
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversationParticipants to fetch.
     */
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateConversationParticipants
    **/
    _count?: true | PrivateConversationParticipantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PrivateConversationParticipantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PrivateConversationParticipantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateConversationParticipantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateConversationParticipantMaxAggregateInputType
  }

  export type GetPrivateConversationParticipantAggregateType<T extends PrivateConversationParticipantAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateConversationParticipant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateConversationParticipant[P]>
      : GetScalarType<T[P], AggregatePrivateConversationParticipant[P]>
  }




  export type PrivateConversationParticipantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateConversationParticipantWhereInput
    orderBy?: PrivateConversationParticipantOrderByWithAggregationInput | PrivateConversationParticipantOrderByWithAggregationInput[]
    by: PrivateConversationParticipantScalarFieldEnum[] | PrivateConversationParticipantScalarFieldEnum
    having?: PrivateConversationParticipantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateConversationParticipantCountAggregateInputType | true
    _avg?: PrivateConversationParticipantAvgAggregateInputType
    _sum?: PrivateConversationParticipantSumAggregateInputType
    _min?: PrivateConversationParticipantMinAggregateInputType
    _max?: PrivateConversationParticipantMaxAggregateInputType
  }

  export type PrivateConversationParticipantGroupByOutputType = {
    id: string
    conversationId: string
    accountId: string
    unreadCount: number
    createdAt: Date
    updatedAt: Date
    _count: PrivateConversationParticipantCountAggregateOutputType | null
    _avg: PrivateConversationParticipantAvgAggregateOutputType | null
    _sum: PrivateConversationParticipantSumAggregateOutputType | null
    _min: PrivateConversationParticipantMinAggregateOutputType | null
    _max: PrivateConversationParticipantMaxAggregateOutputType | null
  }

  type GetPrivateConversationParticipantGroupByPayload<T extends PrivateConversationParticipantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateConversationParticipantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateConversationParticipantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateConversationParticipantGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateConversationParticipantGroupByOutputType[P]>
        }
      >
    >


  export type PrivateConversationParticipantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    accountId?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateConversationParticipant"]>

  export type PrivateConversationParticipantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    accountId?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateConversationParticipant"]>

  export type PrivateConversationParticipantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    accountId?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateConversationParticipant"]>

  export type PrivateConversationParticipantSelectScalar = {
    id?: boolean
    conversationId?: boolean
    accountId?: boolean
    unreadCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivateConversationParticipantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "accountId" | "unreadCount" | "createdAt" | "updatedAt", ExtArgs["result"]["privateConversationParticipant"]>
  export type PrivateConversationParticipantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type PrivateConversationParticipantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type PrivateConversationParticipantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $PrivateConversationParticipantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateConversationParticipant"
    objects: {
      conversation: Prisma.$PrivateConversationPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      accountId: string
      unreadCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privateConversationParticipant"]>
    composites: {}
  }

  type PrivateConversationParticipantGetPayload<S extends boolean | null | undefined | PrivateConversationParticipantDefaultArgs> = $Result.GetResult<Prisma.$PrivateConversationParticipantPayload, S>

  type PrivateConversationParticipantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateConversationParticipantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateConversationParticipantCountAggregateInputType | true
    }

  export interface PrivateConversationParticipantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateConversationParticipant'], meta: { name: 'PrivateConversationParticipant' } }
    /**
     * Find zero or one PrivateConversationParticipant that matches the filter.
     * @param {PrivateConversationParticipantFindUniqueArgs} args - Arguments to find a PrivateConversationParticipant
     * @example
     * // Get one PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateConversationParticipantFindUniqueArgs>(args: SelectSubset<T, PrivateConversationParticipantFindUniqueArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateConversationParticipant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateConversationParticipantFindUniqueOrThrowArgs} args - Arguments to find a PrivateConversationParticipant
     * @example
     * // Get one PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateConversationParticipantFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateConversationParticipantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateConversationParticipant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantFindFirstArgs} args - Arguments to find a PrivateConversationParticipant
     * @example
     * // Get one PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateConversationParticipantFindFirstArgs>(args?: SelectSubset<T, PrivateConversationParticipantFindFirstArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateConversationParticipant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantFindFirstOrThrowArgs} args - Arguments to find a PrivateConversationParticipant
     * @example
     * // Get one PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateConversationParticipantFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateConversationParticipantFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateConversationParticipants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateConversationParticipants
     * const privateConversationParticipants = await prisma.privateConversationParticipant.findMany()
     * 
     * // Get first 10 PrivateConversationParticipants
     * const privateConversationParticipants = await prisma.privateConversationParticipant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateConversationParticipantWithIdOnly = await prisma.privateConversationParticipant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateConversationParticipantFindManyArgs>(args?: SelectSubset<T, PrivateConversationParticipantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateConversationParticipant.
     * @param {PrivateConversationParticipantCreateArgs} args - Arguments to create a PrivateConversationParticipant.
     * @example
     * // Create one PrivateConversationParticipant
     * const PrivateConversationParticipant = await prisma.privateConversationParticipant.create({
     *   data: {
     *     // ... data to create a PrivateConversationParticipant
     *   }
     * })
     * 
     */
    create<T extends PrivateConversationParticipantCreateArgs>(args: SelectSubset<T, PrivateConversationParticipantCreateArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateConversationParticipants.
     * @param {PrivateConversationParticipantCreateManyArgs} args - Arguments to create many PrivateConversationParticipants.
     * @example
     * // Create many PrivateConversationParticipants
     * const privateConversationParticipant = await prisma.privateConversationParticipant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateConversationParticipantCreateManyArgs>(args?: SelectSubset<T, PrivateConversationParticipantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateConversationParticipants and returns the data saved in the database.
     * @param {PrivateConversationParticipantCreateManyAndReturnArgs} args - Arguments to create many PrivateConversationParticipants.
     * @example
     * // Create many PrivateConversationParticipants
     * const privateConversationParticipant = await prisma.privateConversationParticipant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateConversationParticipants and only return the `id`
     * const privateConversationParticipantWithIdOnly = await prisma.privateConversationParticipant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateConversationParticipantCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateConversationParticipantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateConversationParticipant.
     * @param {PrivateConversationParticipantDeleteArgs} args - Arguments to delete one PrivateConversationParticipant.
     * @example
     * // Delete one PrivateConversationParticipant
     * const PrivateConversationParticipant = await prisma.privateConversationParticipant.delete({
     *   where: {
     *     // ... filter to delete one PrivateConversationParticipant
     *   }
     * })
     * 
     */
    delete<T extends PrivateConversationParticipantDeleteArgs>(args: SelectSubset<T, PrivateConversationParticipantDeleteArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateConversationParticipant.
     * @param {PrivateConversationParticipantUpdateArgs} args - Arguments to update one PrivateConversationParticipant.
     * @example
     * // Update one PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateConversationParticipantUpdateArgs>(args: SelectSubset<T, PrivateConversationParticipantUpdateArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateConversationParticipants.
     * @param {PrivateConversationParticipantDeleteManyArgs} args - Arguments to filter PrivateConversationParticipants to delete.
     * @example
     * // Delete a few PrivateConversationParticipants
     * const { count } = await prisma.privateConversationParticipant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateConversationParticipantDeleteManyArgs>(args?: SelectSubset<T, PrivateConversationParticipantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateConversationParticipants
     * const privateConversationParticipant = await prisma.privateConversationParticipant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateConversationParticipantUpdateManyArgs>(args: SelectSubset<T, PrivateConversationParticipantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateConversationParticipants and returns the data updated in the database.
     * @param {PrivateConversationParticipantUpdateManyAndReturnArgs} args - Arguments to update many PrivateConversationParticipants.
     * @example
     * // Update many PrivateConversationParticipants
     * const privateConversationParticipant = await prisma.privateConversationParticipant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateConversationParticipants and only return the `id`
     * const privateConversationParticipantWithIdOnly = await prisma.privateConversationParticipant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateConversationParticipantUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateConversationParticipantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateConversationParticipant.
     * @param {PrivateConversationParticipantUpsertArgs} args - Arguments to update or create a PrivateConversationParticipant.
     * @example
     * // Update or create a PrivateConversationParticipant
     * const privateConversationParticipant = await prisma.privateConversationParticipant.upsert({
     *   create: {
     *     // ... data to create a PrivateConversationParticipant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateConversationParticipant we want to update
     *   }
     * })
     */
    upsert<T extends PrivateConversationParticipantUpsertArgs>(args: SelectSubset<T, PrivateConversationParticipantUpsertArgs<ExtArgs>>): Prisma__PrivateConversationParticipantClient<$Result.GetResult<Prisma.$PrivateConversationParticipantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateConversationParticipants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantCountArgs} args - Arguments to filter PrivateConversationParticipants to count.
     * @example
     * // Count the number of PrivateConversationParticipants
     * const count = await prisma.privateConversationParticipant.count({
     *   where: {
     *     // ... the filter for the PrivateConversationParticipants we want to count
     *   }
     * })
    **/
    count<T extends PrivateConversationParticipantCountArgs>(
      args?: Subset<T, PrivateConversationParticipantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateConversationParticipantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateConversationParticipantAggregateArgs>(args: Subset<T, PrivateConversationParticipantAggregateArgs>): Prisma.PrismaPromise<GetPrivateConversationParticipantAggregateType<T>>

    /**
     * Group by PrivateConversationParticipant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateConversationParticipantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateConversationParticipantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateConversationParticipantGroupByArgs['orderBy'] }
        : { orderBy?: PrivateConversationParticipantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateConversationParticipantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateConversationParticipantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateConversationParticipant model
   */
  readonly fields: PrivateConversationParticipantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateConversationParticipant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateConversationParticipantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends PrivateConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivateConversationDefaultArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateConversationParticipant model
   */
  interface PrivateConversationParticipantFieldRefs {
    readonly id: FieldRef<"PrivateConversationParticipant", 'String'>
    readonly conversationId: FieldRef<"PrivateConversationParticipant", 'String'>
    readonly accountId: FieldRef<"PrivateConversationParticipant", 'String'>
    readonly unreadCount: FieldRef<"PrivateConversationParticipant", 'Int'>
    readonly createdAt: FieldRef<"PrivateConversationParticipant", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateConversationParticipant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateConversationParticipant findUnique
   */
  export type PrivateConversationParticipantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversationParticipant to fetch.
     */
    where: PrivateConversationParticipantWhereUniqueInput
  }

  /**
   * PrivateConversationParticipant findUniqueOrThrow
   */
  export type PrivateConversationParticipantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversationParticipant to fetch.
     */
    where: PrivateConversationParticipantWhereUniqueInput
  }

  /**
   * PrivateConversationParticipant findFirst
   */
  export type PrivateConversationParticipantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversationParticipant to fetch.
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversationParticipants to fetch.
     */
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateConversationParticipants.
     */
    cursor?: PrivateConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateConversationParticipants.
     */
    distinct?: PrivateConversationParticipantScalarFieldEnum | PrivateConversationParticipantScalarFieldEnum[]
  }

  /**
   * PrivateConversationParticipant findFirstOrThrow
   */
  export type PrivateConversationParticipantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversationParticipant to fetch.
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversationParticipants to fetch.
     */
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateConversationParticipants.
     */
    cursor?: PrivateConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversationParticipants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateConversationParticipants.
     */
    distinct?: PrivateConversationParticipantScalarFieldEnum | PrivateConversationParticipantScalarFieldEnum[]
  }

  /**
   * PrivateConversationParticipant findMany
   */
  export type PrivateConversationParticipantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter, which PrivateConversationParticipants to fetch.
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateConversationParticipants to fetch.
     */
    orderBy?: PrivateConversationParticipantOrderByWithRelationInput | PrivateConversationParticipantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateConversationParticipants.
     */
    cursor?: PrivateConversationParticipantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateConversationParticipants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateConversationParticipants.
     */
    skip?: number
    distinct?: PrivateConversationParticipantScalarFieldEnum | PrivateConversationParticipantScalarFieldEnum[]
  }

  /**
   * PrivateConversationParticipant create
   */
  export type PrivateConversationParticipantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateConversationParticipant.
     */
    data: XOR<PrivateConversationParticipantCreateInput, PrivateConversationParticipantUncheckedCreateInput>
  }

  /**
   * PrivateConversationParticipant createMany
   */
  export type PrivateConversationParticipantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateConversationParticipants.
     */
    data: PrivateConversationParticipantCreateManyInput | PrivateConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateConversationParticipant createManyAndReturn
   */
  export type PrivateConversationParticipantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateConversationParticipants.
     */
    data: PrivateConversationParticipantCreateManyInput | PrivateConversationParticipantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateConversationParticipant update
   */
  export type PrivateConversationParticipantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateConversationParticipant.
     */
    data: XOR<PrivateConversationParticipantUpdateInput, PrivateConversationParticipantUncheckedUpdateInput>
    /**
     * Choose, which PrivateConversationParticipant to update.
     */
    where: PrivateConversationParticipantWhereUniqueInput
  }

  /**
   * PrivateConversationParticipant updateMany
   */
  export type PrivateConversationParticipantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateConversationParticipants.
     */
    data: XOR<PrivateConversationParticipantUpdateManyMutationInput, PrivateConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which PrivateConversationParticipants to update
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * Limit how many PrivateConversationParticipants to update.
     */
    limit?: number
  }

  /**
   * PrivateConversationParticipant updateManyAndReturn
   */
  export type PrivateConversationParticipantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * The data used to update PrivateConversationParticipants.
     */
    data: XOR<PrivateConversationParticipantUpdateManyMutationInput, PrivateConversationParticipantUncheckedUpdateManyInput>
    /**
     * Filter which PrivateConversationParticipants to update
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * Limit how many PrivateConversationParticipants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateConversationParticipant upsert
   */
  export type PrivateConversationParticipantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateConversationParticipant to update in case it exists.
     */
    where: PrivateConversationParticipantWhereUniqueInput
    /**
     * In case the PrivateConversationParticipant found by the `where` argument doesn't exist, create a new PrivateConversationParticipant with this data.
     */
    create: XOR<PrivateConversationParticipantCreateInput, PrivateConversationParticipantUncheckedCreateInput>
    /**
     * In case the PrivateConversationParticipant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateConversationParticipantUpdateInput, PrivateConversationParticipantUncheckedUpdateInput>
  }

  /**
   * PrivateConversationParticipant delete
   */
  export type PrivateConversationParticipantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
    /**
     * Filter which PrivateConversationParticipant to delete.
     */
    where: PrivateConversationParticipantWhereUniqueInput
  }

  /**
   * PrivateConversationParticipant deleteMany
   */
  export type PrivateConversationParticipantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateConversationParticipants to delete
     */
    where?: PrivateConversationParticipantWhereInput
    /**
     * Limit how many PrivateConversationParticipants to delete.
     */
    limit?: number
  }

  /**
   * PrivateConversationParticipant without action
   */
  export type PrivateConversationParticipantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateConversationParticipant
     */
    select?: PrivateConversationParticipantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateConversationParticipant
     */
    omit?: PrivateConversationParticipantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateConversationParticipantInclude<ExtArgs> | null
  }


  /**
   * Model PrivateMessage
   */

  export type AggregatePrivateMessage = {
    _count: PrivateMessageCountAggregateOutputType | null
    _min: PrivateMessageMinAggregateOutputType | null
    _max: PrivateMessageMaxAggregateOutputType | null
  }

  export type PrivateMessageMinAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    contentType: $Enums.ContentType | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    reactionType: $Enums.ReactionType | null
    reactedById: string | null
  }

  export type PrivateMessageMaxAggregateOutputType = {
    id: string | null
    conversationId: string | null
    senderId: string | null
    content: string | null
    contentType: $Enums.ContentType | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    reactionType: $Enums.ReactionType | null
    reactedById: string | null
  }

  export type PrivateMessageCountAggregateOutputType = {
    id: number
    conversationId: number
    senderId: number
    content: number
    contentType: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    reactionType: number
    reactedById: number
    _all: number
  }


  export type PrivateMessageMinAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    contentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    reactionType?: true
    reactedById?: true
  }

  export type PrivateMessageMaxAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    contentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    reactionType?: true
    reactedById?: true
  }

  export type PrivateMessageCountAggregateInputType = {
    id?: true
    conversationId?: true
    senderId?: true
    content?: true
    contentType?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    reactionType?: true
    reactedById?: true
    _all?: true
  }

  export type PrivateMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessage to aggregate.
     */
    where?: PrivateMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateMessages
    **/
    _count?: true | PrivateMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateMessageMaxAggregateInputType
  }

  export type GetPrivateMessageAggregateType<T extends PrivateMessageAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateMessage[P]>
      : GetScalarType<T[P], AggregatePrivateMessage[P]>
  }




  export type PrivateMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageWhereInput
    orderBy?: PrivateMessageOrderByWithAggregationInput | PrivateMessageOrderByWithAggregationInput[]
    by: PrivateMessageScalarFieldEnum[] | PrivateMessageScalarFieldEnum
    having?: PrivateMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateMessageCountAggregateInputType | true
    _min?: PrivateMessageMinAggregateInputType
    _max?: PrivateMessageMaxAggregateInputType
  }

  export type PrivateMessageGroupByOutputType = {
    id: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    reactionType: $Enums.ReactionType | null
    reactedById: string | null
    _count: PrivateMessageCountAggregateOutputType | null
    _min: PrivateMessageMinAggregateOutputType | null
    _max: PrivateMessageMaxAggregateOutputType | null
  }

  type GetPrivateMessageGroupByPayload<T extends PrivateMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateMessageGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateMessageGroupByOutputType[P]>
        }
      >
    >


  export type PrivateMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    contentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    reactionType?: boolean
    reactedById?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    attachments?: boolean | PrivateMessage$attachmentsArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
    visibilities?: boolean | PrivateMessage$visibilitiesArgs<ExtArgs>
    _count?: boolean | PrivateMessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessage"]>

  export type PrivateMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    contentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    reactionType?: boolean
    reactedById?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessage"]>

  export type PrivateMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    contentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    reactionType?: boolean
    reactedById?: boolean
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessage"]>

  export type PrivateMessageSelectScalar = {
    id?: boolean
    conversationId?: boolean
    senderId?: boolean
    content?: boolean
    contentType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    reactionType?: boolean
    reactedById?: boolean
  }

  export type PrivateMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "conversationId" | "senderId" | "content" | "contentType" | "createdAt" | "updatedAt" | "deletedAt" | "reactionType" | "reactedById", ExtArgs["result"]["privateMessage"]>
  export type PrivateMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    attachments?: boolean | PrivateMessage$attachmentsArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
    visibilities?: boolean | PrivateMessage$visibilitiesArgs<ExtArgs>
    _count?: boolean | PrivateMessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PrivateMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
  }
  export type PrivateMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    conversation?: boolean | PrivateConversationDefaultArgs<ExtArgs>
    sender?: boolean | AccountDefaultArgs<ExtArgs>
    reactedBy?: boolean | PrivateMessage$reactedByArgs<ExtArgs>
  }

  export type $PrivateMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateMessage"
    objects: {
      conversation: Prisma.$PrivateConversationPayload<ExtArgs>
      sender: Prisma.$AccountPayload<ExtArgs>
      attachments: Prisma.$PrivateMessageAttachmentPayload<ExtArgs>[]
      reactedBy: Prisma.$AccountPayload<ExtArgs> | null
      visibilities: Prisma.$PrivateMessageVisibilityPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      conversationId: string
      senderId: string
      content: string
      contentType: $Enums.ContentType
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      reactionType: $Enums.ReactionType | null
      reactedById: string | null
    }, ExtArgs["result"]["privateMessage"]>
    composites: {}
  }

  type PrivateMessageGetPayload<S extends boolean | null | undefined | PrivateMessageDefaultArgs> = $Result.GetResult<Prisma.$PrivateMessagePayload, S>

  type PrivateMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateMessageCountAggregateInputType | true
    }

  export interface PrivateMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateMessage'], meta: { name: 'PrivateMessage' } }
    /**
     * Find zero or one PrivateMessage that matches the filter.
     * @param {PrivateMessageFindUniqueArgs} args - Arguments to find a PrivateMessage
     * @example
     * // Get one PrivateMessage
     * const privateMessage = await prisma.privateMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateMessageFindUniqueArgs>(args: SelectSubset<T, PrivateMessageFindUniqueArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateMessageFindUniqueOrThrowArgs} args - Arguments to find a PrivateMessage
     * @example
     * // Get one PrivateMessage
     * const privateMessage = await prisma.privateMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageFindFirstArgs} args - Arguments to find a PrivateMessage
     * @example
     * // Get one PrivateMessage
     * const privateMessage = await prisma.privateMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateMessageFindFirstArgs>(args?: SelectSubset<T, PrivateMessageFindFirstArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageFindFirstOrThrowArgs} args - Arguments to find a PrivateMessage
     * @example
     * // Get one PrivateMessage
     * const privateMessage = await prisma.privateMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateMessages
     * const privateMessages = await prisma.privateMessage.findMany()
     * 
     * // Get first 10 PrivateMessages
     * const privateMessages = await prisma.privateMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateMessageWithIdOnly = await prisma.privateMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateMessageFindManyArgs>(args?: SelectSubset<T, PrivateMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateMessage.
     * @param {PrivateMessageCreateArgs} args - Arguments to create a PrivateMessage.
     * @example
     * // Create one PrivateMessage
     * const PrivateMessage = await prisma.privateMessage.create({
     *   data: {
     *     // ... data to create a PrivateMessage
     *   }
     * })
     * 
     */
    create<T extends PrivateMessageCreateArgs>(args: SelectSubset<T, PrivateMessageCreateArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateMessages.
     * @param {PrivateMessageCreateManyArgs} args - Arguments to create many PrivateMessages.
     * @example
     * // Create many PrivateMessages
     * const privateMessage = await prisma.privateMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateMessageCreateManyArgs>(args?: SelectSubset<T, PrivateMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateMessages and returns the data saved in the database.
     * @param {PrivateMessageCreateManyAndReturnArgs} args - Arguments to create many PrivateMessages.
     * @example
     * // Create many PrivateMessages
     * const privateMessage = await prisma.privateMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateMessages and only return the `id`
     * const privateMessageWithIdOnly = await prisma.privateMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateMessage.
     * @param {PrivateMessageDeleteArgs} args - Arguments to delete one PrivateMessage.
     * @example
     * // Delete one PrivateMessage
     * const PrivateMessage = await prisma.privateMessage.delete({
     *   where: {
     *     // ... filter to delete one PrivateMessage
     *   }
     * })
     * 
     */
    delete<T extends PrivateMessageDeleteArgs>(args: SelectSubset<T, PrivateMessageDeleteArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateMessage.
     * @param {PrivateMessageUpdateArgs} args - Arguments to update one PrivateMessage.
     * @example
     * // Update one PrivateMessage
     * const privateMessage = await prisma.privateMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateMessageUpdateArgs>(args: SelectSubset<T, PrivateMessageUpdateArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateMessages.
     * @param {PrivateMessageDeleteManyArgs} args - Arguments to filter PrivateMessages to delete.
     * @example
     * // Delete a few PrivateMessages
     * const { count } = await prisma.privateMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateMessageDeleteManyArgs>(args?: SelectSubset<T, PrivateMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateMessages
     * const privateMessage = await prisma.privateMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateMessageUpdateManyArgs>(args: SelectSubset<T, PrivateMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessages and returns the data updated in the database.
     * @param {PrivateMessageUpdateManyAndReturnArgs} args - Arguments to update many PrivateMessages.
     * @example
     * // Update many PrivateMessages
     * const privateMessage = await prisma.privateMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateMessages and only return the `id`
     * const privateMessageWithIdOnly = await prisma.privateMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateMessage.
     * @param {PrivateMessageUpsertArgs} args - Arguments to update or create a PrivateMessage.
     * @example
     * // Update or create a PrivateMessage
     * const privateMessage = await prisma.privateMessage.upsert({
     *   create: {
     *     // ... data to create a PrivateMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateMessage we want to update
     *   }
     * })
     */
    upsert<T extends PrivateMessageUpsertArgs>(args: SelectSubset<T, PrivateMessageUpsertArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageCountArgs} args - Arguments to filter PrivateMessages to count.
     * @example
     * // Count the number of PrivateMessages
     * const count = await prisma.privateMessage.count({
     *   where: {
     *     // ... the filter for the PrivateMessages we want to count
     *   }
     * })
    **/
    count<T extends PrivateMessageCountArgs>(
      args?: Subset<T, PrivateMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateMessageAggregateArgs>(args: Subset<T, PrivateMessageAggregateArgs>): Prisma.PrismaPromise<GetPrivateMessageAggregateType<T>>

    /**
     * Group by PrivateMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateMessageGroupByArgs['orderBy'] }
        : { orderBy?: PrivateMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateMessage model
   */
  readonly fields: PrivateMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    conversation<T extends PrivateConversationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivateConversationDefaultArgs<ExtArgs>>): Prisma__PrivateConversationClient<$Result.GetResult<Prisma.$PrivateConversationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    attachments<T extends PrivateMessage$attachmentsArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessage$attachmentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reactedBy<T extends PrivateMessage$reactedByArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessage$reactedByArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    visibilities<T extends PrivateMessage$visibilitiesArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessage$visibilitiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateMessage model
   */
  interface PrivateMessageFieldRefs {
    readonly id: FieldRef<"PrivateMessage", 'String'>
    readonly conversationId: FieldRef<"PrivateMessage", 'String'>
    readonly senderId: FieldRef<"PrivateMessage", 'String'>
    readonly content: FieldRef<"PrivateMessage", 'String'>
    readonly contentType: FieldRef<"PrivateMessage", 'ContentType'>
    readonly createdAt: FieldRef<"PrivateMessage", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateMessage", 'DateTime'>
    readonly deletedAt: FieldRef<"PrivateMessage", 'DateTime'>
    readonly reactionType: FieldRef<"PrivateMessage", 'ReactionType'>
    readonly reactedById: FieldRef<"PrivateMessage", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PrivateMessage findUnique
   */
  export type PrivateMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessage to fetch.
     */
    where: PrivateMessageWhereUniqueInput
  }

  /**
   * PrivateMessage findUniqueOrThrow
   */
  export type PrivateMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessage to fetch.
     */
    where: PrivateMessageWhereUniqueInput
  }

  /**
   * PrivateMessage findFirst
   */
  export type PrivateMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessage to fetch.
     */
    where?: PrivateMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessages.
     */
    cursor?: PrivateMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessages.
     */
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * PrivateMessage findFirstOrThrow
   */
  export type PrivateMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessage to fetch.
     */
    where?: PrivateMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessages.
     */
    cursor?: PrivateMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessages.
     */
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * PrivateMessage findMany
   */
  export type PrivateMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessages to fetch.
     */
    where?: PrivateMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessages to fetch.
     */
    orderBy?: PrivateMessageOrderByWithRelationInput | PrivateMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateMessages.
     */
    cursor?: PrivateMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessages.
     */
    skip?: number
    distinct?: PrivateMessageScalarFieldEnum | PrivateMessageScalarFieldEnum[]
  }

  /**
   * PrivateMessage create
   */
  export type PrivateMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateMessage.
     */
    data: XOR<PrivateMessageCreateInput, PrivateMessageUncheckedCreateInput>
  }

  /**
   * PrivateMessage createMany
   */
  export type PrivateMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateMessages.
     */
    data: PrivateMessageCreateManyInput | PrivateMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateMessage createManyAndReturn
   */
  export type PrivateMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateMessages.
     */
    data: PrivateMessageCreateManyInput | PrivateMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessage update
   */
  export type PrivateMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateMessage.
     */
    data: XOR<PrivateMessageUpdateInput, PrivateMessageUncheckedUpdateInput>
    /**
     * Choose, which PrivateMessage to update.
     */
    where: PrivateMessageWhereUniqueInput
  }

  /**
   * PrivateMessage updateMany
   */
  export type PrivateMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateMessages.
     */
    data: XOR<PrivateMessageUpdateManyMutationInput, PrivateMessageUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessages to update
     */
    where?: PrivateMessageWhereInput
    /**
     * Limit how many PrivateMessages to update.
     */
    limit?: number
  }

  /**
   * PrivateMessage updateManyAndReturn
   */
  export type PrivateMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * The data used to update PrivateMessages.
     */
    data: XOR<PrivateMessageUpdateManyMutationInput, PrivateMessageUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessages to update
     */
    where?: PrivateMessageWhereInput
    /**
     * Limit how many PrivateMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessage upsert
   */
  export type PrivateMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateMessage to update in case it exists.
     */
    where: PrivateMessageWhereUniqueInput
    /**
     * In case the PrivateMessage found by the `where` argument doesn't exist, create a new PrivateMessage with this data.
     */
    create: XOR<PrivateMessageCreateInput, PrivateMessageUncheckedCreateInput>
    /**
     * In case the PrivateMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateMessageUpdateInput, PrivateMessageUncheckedUpdateInput>
  }

  /**
   * PrivateMessage delete
   */
  export type PrivateMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
    /**
     * Filter which PrivateMessage to delete.
     */
    where: PrivateMessageWhereUniqueInput
  }

  /**
   * PrivateMessage deleteMany
   */
  export type PrivateMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessages to delete
     */
    where?: PrivateMessageWhereInput
    /**
     * Limit how many PrivateMessages to delete.
     */
    limit?: number
  }

  /**
   * PrivateMessage.attachments
   */
  export type PrivateMessage$attachmentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    where?: PrivateMessageAttachmentWhereInput
    orderBy?: PrivateMessageAttachmentOrderByWithRelationInput | PrivateMessageAttachmentOrderByWithRelationInput[]
    cursor?: PrivateMessageAttachmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageAttachmentScalarFieldEnum | PrivateMessageAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessage.reactedBy
   */
  export type PrivateMessage$reactedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * PrivateMessage.visibilities
   */
  export type PrivateMessage$visibilitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    where?: PrivateMessageVisibilityWhereInput
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PrivateMessageVisibilityScalarFieldEnum | PrivateMessageVisibilityScalarFieldEnum[]
  }

  /**
   * PrivateMessage without action
   */
  export type PrivateMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessage
     */
    select?: PrivateMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessage
     */
    omit?: PrivateMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageInclude<ExtArgs> | null
  }


  /**
   * Model PrivateMessageAttachment
   */

  export type AggregatePrivateMessageAttachment = {
    _count: PrivateMessageAttachmentCountAggregateOutputType | null
    _min: PrivateMessageAttachmentMinAggregateOutputType | null
    _max: PrivateMessageAttachmentMaxAggregateOutputType | null
  }

  export type PrivateMessageAttachmentMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateMessageAttachmentMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    url: string | null
    mimeType: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateMessageAttachmentCountAggregateOutputType = {
    id: number
    messageId: number
    url: number
    mimeType: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivateMessageAttachmentMinAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateMessageAttachmentMaxAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateMessageAttachmentCountAggregateInputType = {
    id?: true
    messageId?: true
    url?: true
    mimeType?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivateMessageAttachmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessageAttachment to aggregate.
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageAttachments to fetch.
     */
    orderBy?: PrivateMessageAttachmentOrderByWithRelationInput | PrivateMessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateMessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateMessageAttachments
    **/
    _count?: true | PrivateMessageAttachmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateMessageAttachmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateMessageAttachmentMaxAggregateInputType
  }

  export type GetPrivateMessageAttachmentAggregateType<T extends PrivateMessageAttachmentAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateMessageAttachment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateMessageAttachment[P]>
      : GetScalarType<T[P], AggregatePrivateMessageAttachment[P]>
  }




  export type PrivateMessageAttachmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageAttachmentWhereInput
    orderBy?: PrivateMessageAttachmentOrderByWithAggregationInput | PrivateMessageAttachmentOrderByWithAggregationInput[]
    by: PrivateMessageAttachmentScalarFieldEnum[] | PrivateMessageAttachmentScalarFieldEnum
    having?: PrivateMessageAttachmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateMessageAttachmentCountAggregateInputType | true
    _min?: PrivateMessageAttachmentMinAggregateInputType
    _max?: PrivateMessageAttachmentMaxAggregateInputType
  }

  export type PrivateMessageAttachmentGroupByOutputType = {
    id: string
    messageId: string
    url: string
    mimeType: string | null
    createdAt: Date
    updatedAt: Date
    _count: PrivateMessageAttachmentCountAggregateOutputType | null
    _min: PrivateMessageAttachmentMinAggregateOutputType | null
    _max: PrivateMessageAttachmentMaxAggregateOutputType | null
  }

  type GetPrivateMessageAttachmentGroupByPayload<T extends PrivateMessageAttachmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateMessageAttachmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateMessageAttachmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateMessageAttachmentGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateMessageAttachmentGroupByOutputType[P]>
        }
      >
    >


  export type PrivateMessageAttachmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageAttachment"]>

  export type PrivateMessageAttachmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageAttachment"]>

  export type PrivateMessageAttachmentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageAttachment"]>

  export type PrivateMessageAttachmentSelectScalar = {
    id?: boolean
    messageId?: boolean
    url?: boolean
    mimeType?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivateMessageAttachmentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "url" | "mimeType" | "createdAt" | "updatedAt", ExtArgs["result"]["privateMessageAttachment"]>
  export type PrivateMessageAttachmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }
  export type PrivateMessageAttachmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }
  export type PrivateMessageAttachmentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
  }

  export type $PrivateMessageAttachmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateMessageAttachment"
    objects: {
      message: Prisma.$PrivateMessagePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      url: string
      mimeType: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privateMessageAttachment"]>
    composites: {}
  }

  type PrivateMessageAttachmentGetPayload<S extends boolean | null | undefined | PrivateMessageAttachmentDefaultArgs> = $Result.GetResult<Prisma.$PrivateMessageAttachmentPayload, S>

  type PrivateMessageAttachmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateMessageAttachmentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateMessageAttachmentCountAggregateInputType | true
    }

  export interface PrivateMessageAttachmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateMessageAttachment'], meta: { name: 'PrivateMessageAttachment' } }
    /**
     * Find zero or one PrivateMessageAttachment that matches the filter.
     * @param {PrivateMessageAttachmentFindUniqueArgs} args - Arguments to find a PrivateMessageAttachment
     * @example
     * // Get one PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateMessageAttachmentFindUniqueArgs>(args: SelectSubset<T, PrivateMessageAttachmentFindUniqueArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateMessageAttachment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateMessageAttachmentFindUniqueOrThrowArgs} args - Arguments to find a PrivateMessageAttachment
     * @example
     * // Get one PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateMessageAttachmentFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateMessageAttachmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessageAttachment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentFindFirstArgs} args - Arguments to find a PrivateMessageAttachment
     * @example
     * // Get one PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateMessageAttachmentFindFirstArgs>(args?: SelectSubset<T, PrivateMessageAttachmentFindFirstArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessageAttachment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentFindFirstOrThrowArgs} args - Arguments to find a PrivateMessageAttachment
     * @example
     * // Get one PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateMessageAttachmentFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateMessageAttachmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateMessageAttachments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateMessageAttachments
     * const privateMessageAttachments = await prisma.privateMessageAttachment.findMany()
     * 
     * // Get first 10 PrivateMessageAttachments
     * const privateMessageAttachments = await prisma.privateMessageAttachment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateMessageAttachmentWithIdOnly = await prisma.privateMessageAttachment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateMessageAttachmentFindManyArgs>(args?: SelectSubset<T, PrivateMessageAttachmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateMessageAttachment.
     * @param {PrivateMessageAttachmentCreateArgs} args - Arguments to create a PrivateMessageAttachment.
     * @example
     * // Create one PrivateMessageAttachment
     * const PrivateMessageAttachment = await prisma.privateMessageAttachment.create({
     *   data: {
     *     // ... data to create a PrivateMessageAttachment
     *   }
     * })
     * 
     */
    create<T extends PrivateMessageAttachmentCreateArgs>(args: SelectSubset<T, PrivateMessageAttachmentCreateArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateMessageAttachments.
     * @param {PrivateMessageAttachmentCreateManyArgs} args - Arguments to create many PrivateMessageAttachments.
     * @example
     * // Create many PrivateMessageAttachments
     * const privateMessageAttachment = await prisma.privateMessageAttachment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateMessageAttachmentCreateManyArgs>(args?: SelectSubset<T, PrivateMessageAttachmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateMessageAttachments and returns the data saved in the database.
     * @param {PrivateMessageAttachmentCreateManyAndReturnArgs} args - Arguments to create many PrivateMessageAttachments.
     * @example
     * // Create many PrivateMessageAttachments
     * const privateMessageAttachment = await prisma.privateMessageAttachment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateMessageAttachments and only return the `id`
     * const privateMessageAttachmentWithIdOnly = await prisma.privateMessageAttachment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateMessageAttachmentCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateMessageAttachmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateMessageAttachment.
     * @param {PrivateMessageAttachmentDeleteArgs} args - Arguments to delete one PrivateMessageAttachment.
     * @example
     * // Delete one PrivateMessageAttachment
     * const PrivateMessageAttachment = await prisma.privateMessageAttachment.delete({
     *   where: {
     *     // ... filter to delete one PrivateMessageAttachment
     *   }
     * })
     * 
     */
    delete<T extends PrivateMessageAttachmentDeleteArgs>(args: SelectSubset<T, PrivateMessageAttachmentDeleteArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateMessageAttachment.
     * @param {PrivateMessageAttachmentUpdateArgs} args - Arguments to update one PrivateMessageAttachment.
     * @example
     * // Update one PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateMessageAttachmentUpdateArgs>(args: SelectSubset<T, PrivateMessageAttachmentUpdateArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateMessageAttachments.
     * @param {PrivateMessageAttachmentDeleteManyArgs} args - Arguments to filter PrivateMessageAttachments to delete.
     * @example
     * // Delete a few PrivateMessageAttachments
     * const { count } = await prisma.privateMessageAttachment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateMessageAttachmentDeleteManyArgs>(args?: SelectSubset<T, PrivateMessageAttachmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateMessageAttachments
     * const privateMessageAttachment = await prisma.privateMessageAttachment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateMessageAttachmentUpdateManyArgs>(args: SelectSubset<T, PrivateMessageAttachmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessageAttachments and returns the data updated in the database.
     * @param {PrivateMessageAttachmentUpdateManyAndReturnArgs} args - Arguments to update many PrivateMessageAttachments.
     * @example
     * // Update many PrivateMessageAttachments
     * const privateMessageAttachment = await prisma.privateMessageAttachment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateMessageAttachments and only return the `id`
     * const privateMessageAttachmentWithIdOnly = await prisma.privateMessageAttachment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateMessageAttachmentUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateMessageAttachmentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateMessageAttachment.
     * @param {PrivateMessageAttachmentUpsertArgs} args - Arguments to update or create a PrivateMessageAttachment.
     * @example
     * // Update or create a PrivateMessageAttachment
     * const privateMessageAttachment = await prisma.privateMessageAttachment.upsert({
     *   create: {
     *     // ... data to create a PrivateMessageAttachment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateMessageAttachment we want to update
     *   }
     * })
     */
    upsert<T extends PrivateMessageAttachmentUpsertArgs>(args: SelectSubset<T, PrivateMessageAttachmentUpsertArgs<ExtArgs>>): Prisma__PrivateMessageAttachmentClient<$Result.GetResult<Prisma.$PrivateMessageAttachmentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateMessageAttachments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentCountArgs} args - Arguments to filter PrivateMessageAttachments to count.
     * @example
     * // Count the number of PrivateMessageAttachments
     * const count = await prisma.privateMessageAttachment.count({
     *   where: {
     *     // ... the filter for the PrivateMessageAttachments we want to count
     *   }
     * })
    **/
    count<T extends PrivateMessageAttachmentCountArgs>(
      args?: Subset<T, PrivateMessageAttachmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateMessageAttachmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateMessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateMessageAttachmentAggregateArgs>(args: Subset<T, PrivateMessageAttachmentAggregateArgs>): Prisma.PrismaPromise<GetPrivateMessageAttachmentAggregateType<T>>

    /**
     * Group by PrivateMessageAttachment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageAttachmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateMessageAttachmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateMessageAttachmentGroupByArgs['orderBy'] }
        : { orderBy?: PrivateMessageAttachmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateMessageAttachmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateMessageAttachmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateMessageAttachment model
   */
  readonly fields: PrivateMessageAttachmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateMessageAttachment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateMessageAttachmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends PrivateMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessageDefaultArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateMessageAttachment model
   */
  interface PrivateMessageAttachmentFieldRefs {
    readonly id: FieldRef<"PrivateMessageAttachment", 'String'>
    readonly messageId: FieldRef<"PrivateMessageAttachment", 'String'>
    readonly url: FieldRef<"PrivateMessageAttachment", 'String'>
    readonly mimeType: FieldRef<"PrivateMessageAttachment", 'String'>
    readonly createdAt: FieldRef<"PrivateMessageAttachment", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateMessageAttachment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateMessageAttachment findUnique
   */
  export type PrivateMessageAttachmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageAttachment to fetch.
     */
    where: PrivateMessageAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessageAttachment findUniqueOrThrow
   */
  export type PrivateMessageAttachmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageAttachment to fetch.
     */
    where: PrivateMessageAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessageAttachment findFirst
   */
  export type PrivateMessageAttachmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageAttachment to fetch.
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageAttachments to fetch.
     */
    orderBy?: PrivateMessageAttachmentOrderByWithRelationInput | PrivateMessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessageAttachments.
     */
    cursor?: PrivateMessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessageAttachments.
     */
    distinct?: PrivateMessageAttachmentScalarFieldEnum | PrivateMessageAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessageAttachment findFirstOrThrow
   */
  export type PrivateMessageAttachmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageAttachment to fetch.
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageAttachments to fetch.
     */
    orderBy?: PrivateMessageAttachmentOrderByWithRelationInput | PrivateMessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessageAttachments.
     */
    cursor?: PrivateMessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageAttachments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessageAttachments.
     */
    distinct?: PrivateMessageAttachmentScalarFieldEnum | PrivateMessageAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessageAttachment findMany
   */
  export type PrivateMessageAttachmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageAttachments to fetch.
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageAttachments to fetch.
     */
    orderBy?: PrivateMessageAttachmentOrderByWithRelationInput | PrivateMessageAttachmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateMessageAttachments.
     */
    cursor?: PrivateMessageAttachmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageAttachments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageAttachments.
     */
    skip?: number
    distinct?: PrivateMessageAttachmentScalarFieldEnum | PrivateMessageAttachmentScalarFieldEnum[]
  }

  /**
   * PrivateMessageAttachment create
   */
  export type PrivateMessageAttachmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateMessageAttachment.
     */
    data: XOR<PrivateMessageAttachmentCreateInput, PrivateMessageAttachmentUncheckedCreateInput>
  }

  /**
   * PrivateMessageAttachment createMany
   */
  export type PrivateMessageAttachmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateMessageAttachments.
     */
    data: PrivateMessageAttachmentCreateManyInput | PrivateMessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateMessageAttachment createManyAndReturn
   */
  export type PrivateMessageAttachmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateMessageAttachments.
     */
    data: PrivateMessageAttachmentCreateManyInput | PrivateMessageAttachmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessageAttachment update
   */
  export type PrivateMessageAttachmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateMessageAttachment.
     */
    data: XOR<PrivateMessageAttachmentUpdateInput, PrivateMessageAttachmentUncheckedUpdateInput>
    /**
     * Choose, which PrivateMessageAttachment to update.
     */
    where: PrivateMessageAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessageAttachment updateMany
   */
  export type PrivateMessageAttachmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateMessageAttachments.
     */
    data: XOR<PrivateMessageAttachmentUpdateManyMutationInput, PrivateMessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessageAttachments to update
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * Limit how many PrivateMessageAttachments to update.
     */
    limit?: number
  }

  /**
   * PrivateMessageAttachment updateManyAndReturn
   */
  export type PrivateMessageAttachmentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * The data used to update PrivateMessageAttachments.
     */
    data: XOR<PrivateMessageAttachmentUpdateManyMutationInput, PrivateMessageAttachmentUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessageAttachments to update
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * Limit how many PrivateMessageAttachments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessageAttachment upsert
   */
  export type PrivateMessageAttachmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateMessageAttachment to update in case it exists.
     */
    where: PrivateMessageAttachmentWhereUniqueInput
    /**
     * In case the PrivateMessageAttachment found by the `where` argument doesn't exist, create a new PrivateMessageAttachment with this data.
     */
    create: XOR<PrivateMessageAttachmentCreateInput, PrivateMessageAttachmentUncheckedCreateInput>
    /**
     * In case the PrivateMessageAttachment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateMessageAttachmentUpdateInput, PrivateMessageAttachmentUncheckedUpdateInput>
  }

  /**
   * PrivateMessageAttachment delete
   */
  export type PrivateMessageAttachmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
    /**
     * Filter which PrivateMessageAttachment to delete.
     */
    where: PrivateMessageAttachmentWhereUniqueInput
  }

  /**
   * PrivateMessageAttachment deleteMany
   */
  export type PrivateMessageAttachmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessageAttachments to delete
     */
    where?: PrivateMessageAttachmentWhereInput
    /**
     * Limit how many PrivateMessageAttachments to delete.
     */
    limit?: number
  }

  /**
   * PrivateMessageAttachment without action
   */
  export type PrivateMessageAttachmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageAttachment
     */
    select?: PrivateMessageAttachmentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageAttachment
     */
    omit?: PrivateMessageAttachmentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageAttachmentInclude<ExtArgs> | null
  }


  /**
   * Model PrivateMessageVisibility
   */

  export type AggregatePrivateMessageVisibility = {
    _count: PrivateMessageVisibilityCountAggregateOutputType | null
    _min: PrivateMessageVisibilityMinAggregateOutputType | null
    _max: PrivateMessageVisibilityMaxAggregateOutputType | null
  }

  export type PrivateMessageVisibilityMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    accountId: string | null
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateMessageVisibilityMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    accountId: string | null
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PrivateMessageVisibilityCountAggregateOutputType = {
    id: number
    messageId: number
    accountId: number
    readAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PrivateMessageVisibilityMinAggregateInputType = {
    id?: true
    messageId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateMessageVisibilityMaxAggregateInputType = {
    id?: true
    messageId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PrivateMessageVisibilityCountAggregateInputType = {
    id?: true
    messageId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PrivateMessageVisibilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessageVisibility to aggregate.
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageVisibilities to fetch.
     */
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageVisibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageVisibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PrivateMessageVisibilities
    **/
    _count?: true | PrivateMessageVisibilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PrivateMessageVisibilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PrivateMessageVisibilityMaxAggregateInputType
  }

  export type GetPrivateMessageVisibilityAggregateType<T extends PrivateMessageVisibilityAggregateArgs> = {
        [P in keyof T & keyof AggregatePrivateMessageVisibility]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePrivateMessageVisibility[P]>
      : GetScalarType<T[P], AggregatePrivateMessageVisibility[P]>
  }




  export type PrivateMessageVisibilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PrivateMessageVisibilityWhereInput
    orderBy?: PrivateMessageVisibilityOrderByWithAggregationInput | PrivateMessageVisibilityOrderByWithAggregationInput[]
    by: PrivateMessageVisibilityScalarFieldEnum[] | PrivateMessageVisibilityScalarFieldEnum
    having?: PrivateMessageVisibilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PrivateMessageVisibilityCountAggregateInputType | true
    _min?: PrivateMessageVisibilityMinAggregateInputType
    _max?: PrivateMessageVisibilityMaxAggregateInputType
  }

  export type PrivateMessageVisibilityGroupByOutputType = {
    id: string
    messageId: string
    accountId: string
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: PrivateMessageVisibilityCountAggregateOutputType | null
    _min: PrivateMessageVisibilityMinAggregateOutputType | null
    _max: PrivateMessageVisibilityMaxAggregateOutputType | null
  }

  type GetPrivateMessageVisibilityGroupByPayload<T extends PrivateMessageVisibilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PrivateMessageVisibilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PrivateMessageVisibilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PrivateMessageVisibilityGroupByOutputType[P]>
            : GetScalarType<T[P], PrivateMessageVisibilityGroupByOutputType[P]>
        }
      >
    >


  export type PrivateMessageVisibilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageVisibility"]>

  export type PrivateMessageVisibilitySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageVisibility"]>

  export type PrivateMessageVisibilitySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["privateMessageVisibility"]>

  export type PrivateMessageVisibilitySelectScalar = {
    id?: boolean
    messageId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PrivateMessageVisibilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "accountId" | "readAt" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["privateMessageVisibility"]>
  export type PrivateMessageVisibilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type PrivateMessageVisibilityIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type PrivateMessageVisibilityIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | PrivateMessageDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $PrivateMessageVisibilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PrivateMessageVisibility"
    objects: {
      message: Prisma.$PrivateMessagePayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      accountId: string
      readAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["privateMessageVisibility"]>
    composites: {}
  }

  type PrivateMessageVisibilityGetPayload<S extends boolean | null | undefined | PrivateMessageVisibilityDefaultArgs> = $Result.GetResult<Prisma.$PrivateMessageVisibilityPayload, S>

  type PrivateMessageVisibilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PrivateMessageVisibilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PrivateMessageVisibilityCountAggregateInputType | true
    }

  export interface PrivateMessageVisibilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PrivateMessageVisibility'], meta: { name: 'PrivateMessageVisibility' } }
    /**
     * Find zero or one PrivateMessageVisibility that matches the filter.
     * @param {PrivateMessageVisibilityFindUniqueArgs} args - Arguments to find a PrivateMessageVisibility
     * @example
     * // Get one PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PrivateMessageVisibilityFindUniqueArgs>(args: SelectSubset<T, PrivateMessageVisibilityFindUniqueArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PrivateMessageVisibility that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PrivateMessageVisibilityFindUniqueOrThrowArgs} args - Arguments to find a PrivateMessageVisibility
     * @example
     * // Get one PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PrivateMessageVisibilityFindUniqueOrThrowArgs>(args: SelectSubset<T, PrivateMessageVisibilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessageVisibility that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityFindFirstArgs} args - Arguments to find a PrivateMessageVisibility
     * @example
     * // Get one PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PrivateMessageVisibilityFindFirstArgs>(args?: SelectSubset<T, PrivateMessageVisibilityFindFirstArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PrivateMessageVisibility that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityFindFirstOrThrowArgs} args - Arguments to find a PrivateMessageVisibility
     * @example
     * // Get one PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PrivateMessageVisibilityFindFirstOrThrowArgs>(args?: SelectSubset<T, PrivateMessageVisibilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PrivateMessageVisibilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PrivateMessageVisibilities
     * const privateMessageVisibilities = await prisma.privateMessageVisibility.findMany()
     * 
     * // Get first 10 PrivateMessageVisibilities
     * const privateMessageVisibilities = await prisma.privateMessageVisibility.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const privateMessageVisibilityWithIdOnly = await prisma.privateMessageVisibility.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PrivateMessageVisibilityFindManyArgs>(args?: SelectSubset<T, PrivateMessageVisibilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PrivateMessageVisibility.
     * @param {PrivateMessageVisibilityCreateArgs} args - Arguments to create a PrivateMessageVisibility.
     * @example
     * // Create one PrivateMessageVisibility
     * const PrivateMessageVisibility = await prisma.privateMessageVisibility.create({
     *   data: {
     *     // ... data to create a PrivateMessageVisibility
     *   }
     * })
     * 
     */
    create<T extends PrivateMessageVisibilityCreateArgs>(args: SelectSubset<T, PrivateMessageVisibilityCreateArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PrivateMessageVisibilities.
     * @param {PrivateMessageVisibilityCreateManyArgs} args - Arguments to create many PrivateMessageVisibilities.
     * @example
     * // Create many PrivateMessageVisibilities
     * const privateMessageVisibility = await prisma.privateMessageVisibility.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PrivateMessageVisibilityCreateManyArgs>(args?: SelectSubset<T, PrivateMessageVisibilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PrivateMessageVisibilities and returns the data saved in the database.
     * @param {PrivateMessageVisibilityCreateManyAndReturnArgs} args - Arguments to create many PrivateMessageVisibilities.
     * @example
     * // Create many PrivateMessageVisibilities
     * const privateMessageVisibility = await prisma.privateMessageVisibility.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PrivateMessageVisibilities and only return the `id`
     * const privateMessageVisibilityWithIdOnly = await prisma.privateMessageVisibility.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PrivateMessageVisibilityCreateManyAndReturnArgs>(args?: SelectSubset<T, PrivateMessageVisibilityCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PrivateMessageVisibility.
     * @param {PrivateMessageVisibilityDeleteArgs} args - Arguments to delete one PrivateMessageVisibility.
     * @example
     * // Delete one PrivateMessageVisibility
     * const PrivateMessageVisibility = await prisma.privateMessageVisibility.delete({
     *   where: {
     *     // ... filter to delete one PrivateMessageVisibility
     *   }
     * })
     * 
     */
    delete<T extends PrivateMessageVisibilityDeleteArgs>(args: SelectSubset<T, PrivateMessageVisibilityDeleteArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PrivateMessageVisibility.
     * @param {PrivateMessageVisibilityUpdateArgs} args - Arguments to update one PrivateMessageVisibility.
     * @example
     * // Update one PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PrivateMessageVisibilityUpdateArgs>(args: SelectSubset<T, PrivateMessageVisibilityUpdateArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PrivateMessageVisibilities.
     * @param {PrivateMessageVisibilityDeleteManyArgs} args - Arguments to filter PrivateMessageVisibilities to delete.
     * @example
     * // Delete a few PrivateMessageVisibilities
     * const { count } = await prisma.privateMessageVisibility.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PrivateMessageVisibilityDeleteManyArgs>(args?: SelectSubset<T, PrivateMessageVisibilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessageVisibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PrivateMessageVisibilities
     * const privateMessageVisibility = await prisma.privateMessageVisibility.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PrivateMessageVisibilityUpdateManyArgs>(args: SelectSubset<T, PrivateMessageVisibilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PrivateMessageVisibilities and returns the data updated in the database.
     * @param {PrivateMessageVisibilityUpdateManyAndReturnArgs} args - Arguments to update many PrivateMessageVisibilities.
     * @example
     * // Update many PrivateMessageVisibilities
     * const privateMessageVisibility = await prisma.privateMessageVisibility.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PrivateMessageVisibilities and only return the `id`
     * const privateMessageVisibilityWithIdOnly = await prisma.privateMessageVisibility.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PrivateMessageVisibilityUpdateManyAndReturnArgs>(args: SelectSubset<T, PrivateMessageVisibilityUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PrivateMessageVisibility.
     * @param {PrivateMessageVisibilityUpsertArgs} args - Arguments to update or create a PrivateMessageVisibility.
     * @example
     * // Update or create a PrivateMessageVisibility
     * const privateMessageVisibility = await prisma.privateMessageVisibility.upsert({
     *   create: {
     *     // ... data to create a PrivateMessageVisibility
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PrivateMessageVisibility we want to update
     *   }
     * })
     */
    upsert<T extends PrivateMessageVisibilityUpsertArgs>(args: SelectSubset<T, PrivateMessageVisibilityUpsertArgs<ExtArgs>>): Prisma__PrivateMessageVisibilityClient<$Result.GetResult<Prisma.$PrivateMessageVisibilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PrivateMessageVisibilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityCountArgs} args - Arguments to filter PrivateMessageVisibilities to count.
     * @example
     * // Count the number of PrivateMessageVisibilities
     * const count = await prisma.privateMessageVisibility.count({
     *   where: {
     *     // ... the filter for the PrivateMessageVisibilities we want to count
     *   }
     * })
    **/
    count<T extends PrivateMessageVisibilityCountArgs>(
      args?: Subset<T, PrivateMessageVisibilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PrivateMessageVisibilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PrivateMessageVisibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PrivateMessageVisibilityAggregateArgs>(args: Subset<T, PrivateMessageVisibilityAggregateArgs>): Prisma.PrismaPromise<GetPrivateMessageVisibilityAggregateType<T>>

    /**
     * Group by PrivateMessageVisibility.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PrivateMessageVisibilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PrivateMessageVisibilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PrivateMessageVisibilityGroupByArgs['orderBy'] }
        : { orderBy?: PrivateMessageVisibilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PrivateMessageVisibilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPrivateMessageVisibilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PrivateMessageVisibility model
   */
  readonly fields: PrivateMessageVisibilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PrivateMessageVisibility.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PrivateMessageVisibilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends PrivateMessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PrivateMessageDefaultArgs<ExtArgs>>): Prisma__PrivateMessageClient<$Result.GetResult<Prisma.$PrivateMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PrivateMessageVisibility model
   */
  interface PrivateMessageVisibilityFieldRefs {
    readonly id: FieldRef<"PrivateMessageVisibility", 'String'>
    readonly messageId: FieldRef<"PrivateMessageVisibility", 'String'>
    readonly accountId: FieldRef<"PrivateMessageVisibility", 'String'>
    readonly readAt: FieldRef<"PrivateMessageVisibility", 'DateTime'>
    readonly deletedAt: FieldRef<"PrivateMessageVisibility", 'DateTime'>
    readonly createdAt: FieldRef<"PrivateMessageVisibility", 'DateTime'>
    readonly updatedAt: FieldRef<"PrivateMessageVisibility", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PrivateMessageVisibility findUnique
   */
  export type PrivateMessageVisibilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageVisibility to fetch.
     */
    where: PrivateMessageVisibilityWhereUniqueInput
  }

  /**
   * PrivateMessageVisibility findUniqueOrThrow
   */
  export type PrivateMessageVisibilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageVisibility to fetch.
     */
    where: PrivateMessageVisibilityWhereUniqueInput
  }

  /**
   * PrivateMessageVisibility findFirst
   */
  export type PrivateMessageVisibilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageVisibility to fetch.
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageVisibilities to fetch.
     */
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessageVisibilities.
     */
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageVisibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageVisibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessageVisibilities.
     */
    distinct?: PrivateMessageVisibilityScalarFieldEnum | PrivateMessageVisibilityScalarFieldEnum[]
  }

  /**
   * PrivateMessageVisibility findFirstOrThrow
   */
  export type PrivateMessageVisibilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageVisibility to fetch.
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageVisibilities to fetch.
     */
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PrivateMessageVisibilities.
     */
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageVisibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageVisibilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PrivateMessageVisibilities.
     */
    distinct?: PrivateMessageVisibilityScalarFieldEnum | PrivateMessageVisibilityScalarFieldEnum[]
  }

  /**
   * PrivateMessageVisibility findMany
   */
  export type PrivateMessageVisibilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter, which PrivateMessageVisibilities to fetch.
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PrivateMessageVisibilities to fetch.
     */
    orderBy?: PrivateMessageVisibilityOrderByWithRelationInput | PrivateMessageVisibilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PrivateMessageVisibilities.
     */
    cursor?: PrivateMessageVisibilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PrivateMessageVisibilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PrivateMessageVisibilities.
     */
    skip?: number
    distinct?: PrivateMessageVisibilityScalarFieldEnum | PrivateMessageVisibilityScalarFieldEnum[]
  }

  /**
   * PrivateMessageVisibility create
   */
  export type PrivateMessageVisibilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * The data needed to create a PrivateMessageVisibility.
     */
    data: XOR<PrivateMessageVisibilityCreateInput, PrivateMessageVisibilityUncheckedCreateInput>
  }

  /**
   * PrivateMessageVisibility createMany
   */
  export type PrivateMessageVisibilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PrivateMessageVisibilities.
     */
    data: PrivateMessageVisibilityCreateManyInput | PrivateMessageVisibilityCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PrivateMessageVisibility createManyAndReturn
   */
  export type PrivateMessageVisibilityCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * The data used to create many PrivateMessageVisibilities.
     */
    data: PrivateMessageVisibilityCreateManyInput | PrivateMessageVisibilityCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessageVisibility update
   */
  export type PrivateMessageVisibilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * The data needed to update a PrivateMessageVisibility.
     */
    data: XOR<PrivateMessageVisibilityUpdateInput, PrivateMessageVisibilityUncheckedUpdateInput>
    /**
     * Choose, which PrivateMessageVisibility to update.
     */
    where: PrivateMessageVisibilityWhereUniqueInput
  }

  /**
   * PrivateMessageVisibility updateMany
   */
  export type PrivateMessageVisibilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PrivateMessageVisibilities.
     */
    data: XOR<PrivateMessageVisibilityUpdateManyMutationInput, PrivateMessageVisibilityUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessageVisibilities to update
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * Limit how many PrivateMessageVisibilities to update.
     */
    limit?: number
  }

  /**
   * PrivateMessageVisibility updateManyAndReturn
   */
  export type PrivateMessageVisibilityUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * The data used to update PrivateMessageVisibilities.
     */
    data: XOR<PrivateMessageVisibilityUpdateManyMutationInput, PrivateMessageVisibilityUncheckedUpdateManyInput>
    /**
     * Filter which PrivateMessageVisibilities to update
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * Limit how many PrivateMessageVisibilities to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PrivateMessageVisibility upsert
   */
  export type PrivateMessageVisibilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * The filter to search for the PrivateMessageVisibility to update in case it exists.
     */
    where: PrivateMessageVisibilityWhereUniqueInput
    /**
     * In case the PrivateMessageVisibility found by the `where` argument doesn't exist, create a new PrivateMessageVisibility with this data.
     */
    create: XOR<PrivateMessageVisibilityCreateInput, PrivateMessageVisibilityUncheckedCreateInput>
    /**
     * In case the PrivateMessageVisibility was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PrivateMessageVisibilityUpdateInput, PrivateMessageVisibilityUncheckedUpdateInput>
  }

  /**
   * PrivateMessageVisibility delete
   */
  export type PrivateMessageVisibilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
    /**
     * Filter which PrivateMessageVisibility to delete.
     */
    where: PrivateMessageVisibilityWhereUniqueInput
  }

  /**
   * PrivateMessageVisibility deleteMany
   */
  export type PrivateMessageVisibilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PrivateMessageVisibilities to delete
     */
    where?: PrivateMessageVisibilityWhereInput
    /**
     * Limit how many PrivateMessageVisibilities to delete.
     */
    limit?: number
  }

  /**
   * PrivateMessageVisibility without action
   */
  export type PrivateMessageVisibilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PrivateMessageVisibility
     */
    select?: PrivateMessageVisibilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the PrivateMessageVisibility
     */
    omit?: PrivateMessageVisibilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PrivateMessageVisibilityInclude<ExtArgs> | null
  }


  /**
   * Model Product
   */

  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    avgRating: Decimal | null
    ratingsCount: number | null
  }

  export type ProductSumAggregateOutputType = {
    avgRating: Decimal | null
    ratingsCount: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: string | null
    brandId: string | null
    category: $Enums.Category | null
    title: string | null
    slug: string | null
    description: string | null
    status: $Enums.ProductStatus | null
    material: string | null
    avgRating: Decimal | null
    ratingsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductMaxAggregateOutputType = {
    id: string | null
    brandId: string | null
    category: $Enums.Category | null
    title: string | null
    slug: string | null
    description: string | null
    status: $Enums.ProductStatus | null
    material: string | null
    avgRating: Decimal | null
    ratingsCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    brandId: number
    category: number
    title: number
    slug: number
    description: number
    attributes: number
    status: number
    material: number
    avgRating: number
    ratingsCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    avgRating?: true
    ratingsCount?: true
  }

  export type ProductSumAggregateInputType = {
    avgRating?: true
    ratingsCount?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    brandId?: true
    category?: true
    title?: true
    slug?: true
    description?: true
    status?: true
    material?: true
    avgRating?: true
    ratingsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    brandId?: true
    category?: true
    title?: true
    slug?: true
    description?: true
    status?: true
    material?: true
    avgRating?: true
    ratingsCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    brandId?: true
    category?: true
    title?: true
    slug?: true
    description?: true
    attributes?: true
    status?: true
    material?: true
    avgRating?: true
    ratingsCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Product to aggregate.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductWhereInput
    orderBy?: ProductOrderByWithAggregationInput | ProductOrderByWithAggregationInput[]
    by: ProductScalarFieldEnum[] | ProductScalarFieldEnum
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }

  export type ProductGroupByOutputType = {
    id: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description: string | null
    attributes: JsonValue | null
    status: $Enums.ProductStatus
    material: string | null
    avgRating: Decimal
    ratingsCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    category?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    attributes?: boolean
    status?: boolean
    material?: boolean
    avgRating?: boolean
    ratingsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    options?: boolean | Product$optionsArgs<ExtArgs>
    tags?: boolean | Product$tagsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    imageVectors?: boolean | Product$imageVectorsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    category?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    attributes?: boolean
    status?: boolean
    material?: boolean
    avgRating?: boolean
    ratingsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    brandId?: boolean
    category?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    attributes?: boolean
    status?: boolean
    material?: boolean
    avgRating?: boolean
    ratingsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["product"]>

  export type ProductSelectScalar = {
    id?: boolean
    brandId?: boolean
    category?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    attributes?: boolean
    status?: boolean
    material?: boolean
    avgRating?: boolean
    ratingsCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProductOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "brandId" | "category" | "title" | "slug" | "description" | "attributes" | "status" | "material" | "avgRating" | "ratingsCount" | "createdAt" | "updatedAt", ExtArgs["result"]["product"]>
  export type ProductInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
    images?: boolean | Product$imagesArgs<ExtArgs>
    variants?: boolean | Product$variantsArgs<ExtArgs>
    options?: boolean | Product$optionsArgs<ExtArgs>
    tags?: boolean | Product$tagsArgs<ExtArgs>
    reviews?: boolean | Product$reviewsArgs<ExtArgs>
    imageVectors?: boolean | Product$imageVectorsArgs<ExtArgs>
    _count?: boolean | ProductCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }
  export type ProductIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | BrandDefaultArgs<ExtArgs>
  }

  export type $ProductPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Product"
    objects: {
      brand: Prisma.$BrandPayload<ExtArgs>
      images: Prisma.$ProductImagePayload<ExtArgs>[]
      variants: Prisma.$VariantPayload<ExtArgs>[]
      options: Prisma.$ProductOptionPayload<ExtArgs>[]
      tags: Prisma.$ProductTagPayload<ExtArgs>[]
      reviews: Prisma.$ReviewPayload<ExtArgs>[]
      imageVectors: Prisma.$ProductImageEmbeddingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      brandId: string
      category: $Enums.Category
      title: string
      slug: string
      description: string | null
      attributes: Prisma.JsonValue | null
      status: $Enums.ProductStatus
      material: string | null
      avgRating: Prisma.Decimal
      ratingsCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["product"]>
    composites: {}
  }

  type ProductGetPayload<S extends boolean | null | undefined | ProductDefaultArgs> = $Result.GetResult<Prisma.$ProductPayload, S>

  type ProductCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductCountAggregateInputType | true
    }

  export interface ProductDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Product'], meta: { name: 'Product' } }
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductFindUniqueArgs>(args: SelectSubset<T, ProductFindUniqueArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Product that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductFindUniqueOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductFindFirstArgs>(args?: SelectSubset<T, ProductFindFirstArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Product that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstOrThrowArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductFindManyArgs>(args?: SelectSubset<T, ProductFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
     */
    create<T extends ProductCreateArgs>(args: SelectSubset<T, ProductCreateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Products.
     * @param {ProductCreateManyArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductCreateManyArgs>(args?: SelectSubset<T, ProductCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Products and returns the data saved in the database.
     * @param {ProductCreateManyAndReturnArgs} args - Arguments to create many Products.
     * @example
     * // Create many Products
     * const product = await prisma.product.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Products and only return the `id`
     * const productWithIdOnly = await prisma.product.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
     */
    delete<T extends ProductDeleteArgs>(args: SelectSubset<T, ProductDeleteArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductUpdateArgs>(args: SelectSubset<T, ProductUpdateArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductDeleteManyArgs>(args?: SelectSubset<T, ProductDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductUpdateManyArgs>(args: SelectSubset<T, ProductUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products and returns the data updated in the database.
     * @param {ProductUpdateManyAndReturnArgs} args - Arguments to update many Products.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Products and only return the `id`
     * const productWithIdOnly = await prisma.product.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
     */
    upsert<T extends ProductUpsertArgs>(args: SelectSubset<T, ProductUpsertArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): Prisma.PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Product model
   */
  readonly fields: ProductFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends BrandDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BrandDefaultArgs<ExtArgs>>): Prisma__BrandClient<$Result.GetResult<Prisma.$BrandPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends Product$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Product$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variants<T extends Product$variantsArgs<ExtArgs> = {}>(args?: Subset<T, Product$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends Product$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Product$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    tags<T extends Product$tagsArgs<ExtArgs> = {}>(args?: Subset<T, Product$tagsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reviews<T extends Product$reviewsArgs<ExtArgs> = {}>(args?: Subset<T, Product$reviewsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    imageVectors<T extends Product$imageVectorsArgs<ExtArgs> = {}>(args?: Subset<T, Product$imageVectorsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Product model
   */
  interface ProductFieldRefs {
    readonly id: FieldRef<"Product", 'String'>
    readonly brandId: FieldRef<"Product", 'String'>
    readonly category: FieldRef<"Product", 'Category'>
    readonly title: FieldRef<"Product", 'String'>
    readonly slug: FieldRef<"Product", 'String'>
    readonly description: FieldRef<"Product", 'String'>
    readonly attributes: FieldRef<"Product", 'Json'>
    readonly status: FieldRef<"Product", 'ProductStatus'>
    readonly material: FieldRef<"Product", 'String'>
    readonly avgRating: FieldRef<"Product", 'Decimal'>
    readonly ratingsCount: FieldRef<"Product", 'Int'>
    readonly createdAt: FieldRef<"Product", 'DateTime'>
    readonly updatedAt: FieldRef<"Product", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findUniqueOrThrow
   */
  export type ProductFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findFirstOrThrow
   */
  export type ProductFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Product to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     */
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product findMany
   */
  export type ProductFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter, which Products to fetch.
     */
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     */
    orderBy?: ProductOrderByWithRelationInput | ProductOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     */
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     */
    skip?: number
    distinct?: ProductScalarFieldEnum | ProductScalarFieldEnum[]
  }

  /**
   * Product create
   */
  export type ProductCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to create a Product.
     */
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }

  /**
   * Product createMany
   */
  export type ProductCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Product createManyAndReturn
   */
  export type ProductCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to create many Products.
     */
    data: ProductCreateManyInput | ProductCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product update
   */
  export type ProductUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The data needed to update a Product.
     */
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
  }

  /**
   * Product updateManyAndReturn
   */
  export type ProductUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * The data used to update Products.
     */
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Product upsert
   */
  export type ProductUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * The filter to search for the Product to update in case it exists.
     */
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     */
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }

  /**
   * Product delete
   */
  export type ProductDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
    /**
     * Filter which Product to delete.
     */
    where: ProductWhereUniqueInput
  }

  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Products to delete
     */
    where?: ProductWhereInput
    /**
     * Limit how many Products to delete.
     */
    limit?: number
  }

  /**
   * Product.images
   */
  export type Product$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    cursor?: ProductImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * Product.variants
   */
  export type Product$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    cursor?: VariantWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Product.options
   */
  export type Product$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    where?: ProductOptionWhereInput
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    cursor?: ProductOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * Product.tags
   */
  export type Product$tagsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    cursor?: ProductTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }

  /**
   * Product.reviews
   */
  export type Product$reviewsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    cursor?: ReviewWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Product.imageVectors
   */
  export type Product$imageVectorsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    where?: ProductImageEmbeddingWhereInput
    orderBy?: ProductImageEmbeddingOrderByWithRelationInput | ProductImageEmbeddingOrderByWithRelationInput[]
    cursor?: ProductImageEmbeddingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductImageEmbeddingScalarFieldEnum | ProductImageEmbeddingScalarFieldEnum[]
  }

  /**
   * Product without action
   */
  export type ProductDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Product
     */
    select?: ProductSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Product
     */
    omit?: ProductOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductInclude<ExtArgs> | null
  }


  /**
   * Model ProductImage
   */

  export type AggregateProductImage = {
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  export type ProductImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductImageMinAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ProductImageMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ProductImageCountAggregateOutputType = {
    id: number
    productId: number
    url: number
    altText: number
    meta: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type ProductImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ProductImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type ProductImageMinAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ProductImageMaxAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ProductImageCountAggregateInputType = {
    id?: true
    productId?: true
    url?: true
    altText?: true
    meta?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type ProductImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImage to aggregate.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImages
    **/
    _count?: true | ProductImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageMaxAggregateInputType
  }

  export type GetProductImageAggregateType<T extends ProductImageAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImage[P]>
      : GetScalarType<T[P], AggregateProductImage[P]>
  }




  export type ProductImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageWhereInput
    orderBy?: ProductImageOrderByWithAggregationInput | ProductImageOrderByWithAggregationInput[]
    by: ProductImageScalarFieldEnum[] | ProductImageScalarFieldEnum
    having?: ProductImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageCountAggregateInputType | true
    _avg?: ProductImageAvgAggregateInputType
    _sum?: ProductImageSumAggregateInputType
    _min?: ProductImageMinAggregateInputType
    _max?: ProductImageMaxAggregateInputType
  }

  export type ProductImageGroupByOutputType = {
    id: string
    productId: string
    url: string
    altText: string | null
    meta: JsonValue | null
    sortOrder: number
    createdAt: Date
    _count: ProductImageCountAggregateOutputType | null
    _avg: ProductImageAvgAggregateOutputType | null
    _sum: ProductImageSumAggregateOutputType | null
    _min: ProductImageMinAggregateOutputType | null
    _max: ProductImageMaxAggregateOutputType | null
  }

  type GetProductImageGroupByPayload<T extends ProductImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    altText?: boolean
    meta?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    embedding?: boolean | ProductImage$embeddingArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    altText?: boolean
    meta?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    url?: boolean
    altText?: boolean
    meta?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImage"]>

  export type ProductImageSelectScalar = {
    id?: boolean
    productId?: boolean
    url?: boolean
    altText?: boolean
    meta?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type ProductImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "url" | "altText" | "meta" | "sortOrder" | "createdAt", ExtArgs["result"]["productImage"]>
  export type ProductImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    embedding?: boolean | ProductImage$embeddingArgs<ExtArgs>
  }
  export type ProductImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImage"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      embedding: Prisma.$ProductImageEmbeddingPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      url: string
      altText: string | null
      meta: Prisma.JsonValue | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["productImage"]>
    composites: {}
  }

  type ProductImageGetPayload<S extends boolean | null | undefined | ProductImageDefaultArgs> = $Result.GetResult<Prisma.$ProductImagePayload, S>

  type ProductImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageCountAggregateInputType | true
    }

  export interface ProductImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImage'], meta: { name: 'ProductImage' } }
    /**
     * Find zero or one ProductImage that matches the filter.
     * @param {ProductImageFindUniqueArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageFindUniqueArgs>(args: SelectSubset<T, ProductImageFindUniqueArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageFindUniqueOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageFindFirstArgs>(args?: SelectSubset<T, ProductImageFindFirstArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindFirstOrThrowArgs} args - Arguments to find a ProductImage
     * @example
     * // Get one ProductImage
     * const productImage = await prisma.productImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImages
     * const productImages = await prisma.productImage.findMany()
     * 
     * // Get first 10 ProductImages
     * const productImages = await prisma.productImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageWithIdOnly = await prisma.productImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageFindManyArgs>(args?: SelectSubset<T, ProductImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductImage.
     * @param {ProductImageCreateArgs} args - Arguments to create a ProductImage.
     * @example
     * // Create one ProductImage
     * const ProductImage = await prisma.productImage.create({
     *   data: {
     *     // ... data to create a ProductImage
     *   }
     * })
     * 
     */
    create<T extends ProductImageCreateArgs>(args: SelectSubset<T, ProductImageCreateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductImages.
     * @param {ProductImageCreateManyArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductImageCreateManyArgs>(args?: SelectSubset<T, ProductImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductImages and returns the data saved in the database.
     * @param {ProductImageCreateManyAndReturnArgs} args - Arguments to create many ProductImages.
     * @example
     * // Create many ProductImages
     * const productImage = await prisma.productImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductImage.
     * @param {ProductImageDeleteArgs} args - Arguments to delete one ProductImage.
     * @example
     * // Delete one ProductImage
     * const ProductImage = await prisma.productImage.delete({
     *   where: {
     *     // ... filter to delete one ProductImage
     *   }
     * })
     * 
     */
    delete<T extends ProductImageDeleteArgs>(args: SelectSubset<T, ProductImageDeleteArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImage.
     * @param {ProductImageUpdateArgs} args - Arguments to update one ProductImage.
     * @example
     * // Update one ProductImage
     * const productImage = await prisma.productImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageUpdateArgs>(args: SelectSubset<T, ProductImageUpdateArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImages.
     * @param {ProductImageDeleteManyArgs} args - Arguments to filter ProductImages to delete.
     * @example
     * // Delete a few ProductImages
     * const { count } = await prisma.productImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageDeleteManyArgs>(args?: SelectSubset<T, ProductImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageUpdateManyArgs>(args: SelectSubset<T, ProductImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImages and returns the data updated in the database.
     * @param {ProductImageUpdateManyAndReturnArgs} args - Arguments to update many ProductImages.
     * @example
     * // Update many ProductImages
     * const productImage = await prisma.productImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImages and only return the `id`
     * const productImageWithIdOnly = await prisma.productImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductImage.
     * @param {ProductImageUpsertArgs} args - Arguments to update or create a ProductImage.
     * @example
     * // Update or create a ProductImage
     * const productImage = await prisma.productImage.upsert({
     *   create: {
     *     // ... data to create a ProductImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductImage we want to update
     *   }
     * })
     */
    upsert<T extends ProductImageUpsertArgs>(args: SelectSubset<T, ProductImageUpsertArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageCountArgs} args - Arguments to filter ProductImages to count.
     * @example
     * // Count the number of ProductImages
     * const count = await prisma.productImage.count({
     *   where: {
     *     // ... the filter for the ProductImages we want to count
     *   }
     * })
    **/
    count<T extends ProductImageCountArgs>(
      args?: Subset<T, ProductImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageAggregateArgs>(args: Subset<T, ProductImageAggregateArgs>): Prisma.PrismaPromise<GetProductImageAggregateType<T>>

    /**
     * Group by ProductImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImage model
   */
  readonly fields: ProductImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    embedding<T extends ProductImage$embeddingArgs<ExtArgs> = {}>(args?: Subset<T, ProductImage$embeddingArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImage model
   */
  interface ProductImageFieldRefs {
    readonly id: FieldRef<"ProductImage", 'String'>
    readonly productId: FieldRef<"ProductImage", 'String'>
    readonly url: FieldRef<"ProductImage", 'String'>
    readonly altText: FieldRef<"ProductImage", 'String'>
    readonly meta: FieldRef<"ProductImage", 'Json'>
    readonly sortOrder: FieldRef<"ProductImage", 'Int'>
    readonly createdAt: FieldRef<"ProductImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductImage findUnique
   */
  export type ProductImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findUniqueOrThrow
   */
  export type ProductImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage findFirst
   */
  export type ProductImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findFirstOrThrow
   */
  export type ProductImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImage to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImages.
     */
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage findMany
   */
  export type ProductImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter, which ProductImages to fetch.
     */
    where?: ProductImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImages to fetch.
     */
    orderBy?: ProductImageOrderByWithRelationInput | ProductImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImages.
     */
    cursor?: ProductImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImages.
     */
    skip?: number
    distinct?: ProductImageScalarFieldEnum | ProductImageScalarFieldEnum[]
  }

  /**
   * ProductImage create
   */
  export type ProductImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductImage.
     */
    data: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
  }

  /**
   * ProductImage createMany
   */
  export type ProductImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductImage createManyAndReturn
   */
  export type ProductImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to create many ProductImages.
     */
    data: ProductImageCreateManyInput | ProductImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage update
   */
  export type ProductImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImage.
     */
    data: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
    /**
     * Choose, which ProductImage to update.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage updateMany
   */
  export type ProductImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
  }

  /**
   * ProductImage updateManyAndReturn
   */
  export type ProductImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * The data used to update ProductImages.
     */
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyInput>
    /**
     * Filter which ProductImages to update
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImage upsert
   */
  export type ProductImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductImage to update in case it exists.
     */
    where: ProductImageWhereUniqueInput
    /**
     * In case the ProductImage found by the `where` argument doesn't exist, create a new ProductImage with this data.
     */
    create: XOR<ProductImageCreateInput, ProductImageUncheckedCreateInput>
    /**
     * In case the ProductImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductImageUpdateInput, ProductImageUncheckedUpdateInput>
  }

  /**
   * ProductImage delete
   */
  export type ProductImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
    /**
     * Filter which ProductImage to delete.
     */
    where: ProductImageWhereUniqueInput
  }

  /**
   * ProductImage deleteMany
   */
  export type ProductImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImages to delete
     */
    where?: ProductImageWhereInput
    /**
     * Limit how many ProductImages to delete.
     */
    limit?: number
  }

  /**
   * ProductImage.embedding
   */
  export type ProductImage$embeddingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    where?: ProductImageEmbeddingWhereInput
  }

  /**
   * ProductImage without action
   */
  export type ProductImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImage
     */
    select?: ProductImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImage
     */
    omit?: ProductImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageInclude<ExtArgs> | null
  }


  /**
   * Model ProductOption
   */

  export type AggregateProductOption = {
    _count: ProductOptionCountAggregateOutputType | null
    _avg: ProductOptionAvgAggregateOutputType | null
    _sum: ProductOptionSumAggregateOutputType | null
    _min: ProductOptionMinAggregateOutputType | null
    _max: ProductOptionMaxAggregateOutputType | null
  }

  export type ProductOptionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductOptionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductOptionMinAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    label: string | null
    sortOrder: number | null
  }

  export type ProductOptionMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    name: string | null
    label: string | null
    sortOrder: number | null
  }

  export type ProductOptionCountAggregateOutputType = {
    id: number
    productId: number
    name: number
    label: number
    sortOrder: number
    _all: number
  }


  export type ProductOptionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ProductOptionSumAggregateInputType = {
    sortOrder?: true
  }

  export type ProductOptionMinAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    label?: true
    sortOrder?: true
  }

  export type ProductOptionMaxAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    label?: true
    sortOrder?: true
  }

  export type ProductOptionCountAggregateInputType = {
    id?: true
    productId?: true
    name?: true
    label?: true
    sortOrder?: true
    _all?: true
  }

  export type ProductOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOption to aggregate.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductOptions
    **/
    _count?: true | ProductOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductOptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductOptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductOptionMaxAggregateInputType
  }

  export type GetProductOptionAggregateType<T extends ProductOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateProductOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductOption[P]>
      : GetScalarType<T[P], AggregateProductOption[P]>
  }




  export type ProductOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionWhereInput
    orderBy?: ProductOptionOrderByWithAggregationInput | ProductOptionOrderByWithAggregationInput[]
    by: ProductOptionScalarFieldEnum[] | ProductOptionScalarFieldEnum
    having?: ProductOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductOptionCountAggregateInputType | true
    _avg?: ProductOptionAvgAggregateInputType
    _sum?: ProductOptionSumAggregateInputType
    _min?: ProductOptionMinAggregateInputType
    _max?: ProductOptionMaxAggregateInputType
  }

  export type ProductOptionGroupByOutputType = {
    id: string
    productId: string
    name: string
    label: string | null
    sortOrder: number
    _count: ProductOptionCountAggregateOutputType | null
    _avg: ProductOptionAvgAggregateOutputType | null
    _sum: ProductOptionSumAggregateOutputType | null
    _min: ProductOptionMinAggregateOutputType | null
    _max: ProductOptionMaxAggregateOutputType | null
  }

  type GetProductOptionGroupByPayload<T extends ProductOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductOptionGroupByOutputType[P]>
            : GetScalarType<T[P], ProductOptionGroupByOutputType[P]>
        }
      >
    >


  export type ProductOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    label?: boolean
    sortOrder?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    values?: boolean | ProductOption$valuesArgs<ExtArgs>
    VariantOption?: boolean | ProductOption$VariantOptionArgs<ExtArgs>
    _count?: boolean | ProductOptionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    label?: boolean
    sortOrder?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    name?: boolean
    label?: boolean
    sortOrder?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOption"]>

  export type ProductOptionSelectScalar = {
    id?: boolean
    productId?: boolean
    name?: boolean
    label?: boolean
    sortOrder?: boolean
  }

  export type ProductOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "name" | "label" | "sortOrder", ExtArgs["result"]["productOption"]>
  export type ProductOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    values?: boolean | ProductOption$valuesArgs<ExtArgs>
    VariantOption?: boolean | ProductOption$VariantOptionArgs<ExtArgs>
    _count?: boolean | ProductOptionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductOption"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      values: Prisma.$ProductOptionValuePayload<ExtArgs>[]
      VariantOption: Prisma.$VariantOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      name: string
      label: string | null
      sortOrder: number
    }, ExtArgs["result"]["productOption"]>
    composites: {}
  }

  type ProductOptionGetPayload<S extends boolean | null | undefined | ProductOptionDefaultArgs> = $Result.GetResult<Prisma.$ProductOptionPayload, S>

  type ProductOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductOptionCountAggregateInputType | true
    }

  export interface ProductOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductOption'], meta: { name: 'ProductOption' } }
    /**
     * Find zero or one ProductOption that matches the filter.
     * @param {ProductOptionFindUniqueArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductOptionFindUniqueArgs>(args: SelectSubset<T, ProductOptionFindUniqueArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductOptionFindUniqueOrThrowArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindFirstArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductOptionFindFirstArgs>(args?: SelectSubset<T, ProductOptionFindFirstArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindFirstOrThrowArgs} args - Arguments to find a ProductOption
     * @example
     * // Get one ProductOption
     * const productOption = await prisma.productOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductOptions
     * const productOptions = await prisma.productOption.findMany()
     * 
     * // Get first 10 ProductOptions
     * const productOptions = await prisma.productOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productOptionWithIdOnly = await prisma.productOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductOptionFindManyArgs>(args?: SelectSubset<T, ProductOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductOption.
     * @param {ProductOptionCreateArgs} args - Arguments to create a ProductOption.
     * @example
     * // Create one ProductOption
     * const ProductOption = await prisma.productOption.create({
     *   data: {
     *     // ... data to create a ProductOption
     *   }
     * })
     * 
     */
    create<T extends ProductOptionCreateArgs>(args: SelectSubset<T, ProductOptionCreateArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductOptions.
     * @param {ProductOptionCreateManyArgs} args - Arguments to create many ProductOptions.
     * @example
     * // Create many ProductOptions
     * const productOption = await prisma.productOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductOptionCreateManyArgs>(args?: SelectSubset<T, ProductOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductOptions and returns the data saved in the database.
     * @param {ProductOptionCreateManyAndReturnArgs} args - Arguments to create many ProductOptions.
     * @example
     * // Create many ProductOptions
     * const productOption = await prisma.productOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductOptions and only return the `id`
     * const productOptionWithIdOnly = await prisma.productOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductOption.
     * @param {ProductOptionDeleteArgs} args - Arguments to delete one ProductOption.
     * @example
     * // Delete one ProductOption
     * const ProductOption = await prisma.productOption.delete({
     *   where: {
     *     // ... filter to delete one ProductOption
     *   }
     * })
     * 
     */
    delete<T extends ProductOptionDeleteArgs>(args: SelectSubset<T, ProductOptionDeleteArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductOption.
     * @param {ProductOptionUpdateArgs} args - Arguments to update one ProductOption.
     * @example
     * // Update one ProductOption
     * const productOption = await prisma.productOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductOptionUpdateArgs>(args: SelectSubset<T, ProductOptionUpdateArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductOptions.
     * @param {ProductOptionDeleteManyArgs} args - Arguments to filter ProductOptions to delete.
     * @example
     * // Delete a few ProductOptions
     * const { count } = await prisma.productOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductOptionDeleteManyArgs>(args?: SelectSubset<T, ProductOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductOptions
     * const productOption = await prisma.productOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductOptionUpdateManyArgs>(args: SelectSubset<T, ProductOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptions and returns the data updated in the database.
     * @param {ProductOptionUpdateManyAndReturnArgs} args - Arguments to update many ProductOptions.
     * @example
     * // Update many ProductOptions
     * const productOption = await prisma.productOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductOptions and only return the `id`
     * const productOptionWithIdOnly = await prisma.productOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductOption.
     * @param {ProductOptionUpsertArgs} args - Arguments to update or create a ProductOption.
     * @example
     * // Update or create a ProductOption
     * const productOption = await prisma.productOption.upsert({
     *   create: {
     *     // ... data to create a ProductOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductOption we want to update
     *   }
     * })
     */
    upsert<T extends ProductOptionUpsertArgs>(args: SelectSubset<T, ProductOptionUpsertArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionCountArgs} args - Arguments to filter ProductOptions to count.
     * @example
     * // Count the number of ProductOptions
     * const count = await prisma.productOption.count({
     *   where: {
     *     // ... the filter for the ProductOptions we want to count
     *   }
     * })
    **/
    count<T extends ProductOptionCountArgs>(
      args?: Subset<T, ProductOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductOptionAggregateArgs>(args: Subset<T, ProductOptionAggregateArgs>): Prisma.PrismaPromise<GetProductOptionAggregateType<T>>

    /**
     * Group by ProductOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductOptionGroupByArgs['orderBy'] }
        : { orderBy?: ProductOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductOption model
   */
  readonly fields: ProductOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    values<T extends ProductOption$valuesArgs<ExtArgs> = {}>(args?: Subset<T, ProductOption$valuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    VariantOption<T extends ProductOption$VariantOptionArgs<ExtArgs> = {}>(args?: Subset<T, ProductOption$VariantOptionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductOption model
   */
  interface ProductOptionFieldRefs {
    readonly id: FieldRef<"ProductOption", 'String'>
    readonly productId: FieldRef<"ProductOption", 'String'>
    readonly name: FieldRef<"ProductOption", 'String'>
    readonly label: FieldRef<"ProductOption", 'String'>
    readonly sortOrder: FieldRef<"ProductOption", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductOption findUnique
   */
  export type ProductOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption findUniqueOrThrow
   */
  export type ProductOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption findFirst
   */
  export type ProductOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptions.
     */
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption findFirstOrThrow
   */
  export type ProductOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOption to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptions.
     */
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption findMany
   */
  export type ProductOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptions to fetch.
     */
    where?: ProductOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptions to fetch.
     */
    orderBy?: ProductOptionOrderByWithRelationInput | ProductOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductOptions.
     */
    cursor?: ProductOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptions.
     */
    skip?: number
    distinct?: ProductOptionScalarFieldEnum | ProductOptionScalarFieldEnum[]
  }

  /**
   * ProductOption create
   */
  export type ProductOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductOption.
     */
    data: XOR<ProductOptionCreateInput, ProductOptionUncheckedCreateInput>
  }

  /**
   * ProductOption createMany
   */
  export type ProductOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductOptions.
     */
    data: ProductOptionCreateManyInput | ProductOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductOption createManyAndReturn
   */
  export type ProductOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * The data used to create many ProductOptions.
     */
    data: ProductOptionCreateManyInput | ProductOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOption update
   */
  export type ProductOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductOption.
     */
    data: XOR<ProductOptionUpdateInput, ProductOptionUncheckedUpdateInput>
    /**
     * Choose, which ProductOption to update.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption updateMany
   */
  export type ProductOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductOptions.
     */
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptions to update
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to update.
     */
    limit?: number
  }

  /**
   * ProductOption updateManyAndReturn
   */
  export type ProductOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * The data used to update ProductOptions.
     */
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptions to update
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOption upsert
   */
  export type ProductOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductOption to update in case it exists.
     */
    where: ProductOptionWhereUniqueInput
    /**
     * In case the ProductOption found by the `where` argument doesn't exist, create a new ProductOption with this data.
     */
    create: XOR<ProductOptionCreateInput, ProductOptionUncheckedCreateInput>
    /**
     * In case the ProductOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductOptionUpdateInput, ProductOptionUncheckedUpdateInput>
  }

  /**
   * ProductOption delete
   */
  export type ProductOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
    /**
     * Filter which ProductOption to delete.
     */
    where: ProductOptionWhereUniqueInput
  }

  /**
   * ProductOption deleteMany
   */
  export type ProductOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOptions to delete
     */
    where?: ProductOptionWhereInput
    /**
     * Limit how many ProductOptions to delete.
     */
    limit?: number
  }

  /**
   * ProductOption.values
   */
  export type ProductOption$valuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    where?: ProductOptionValueWhereInput
    orderBy?: ProductOptionValueOrderByWithRelationInput | ProductOptionValueOrderByWithRelationInput[]
    cursor?: ProductOptionValueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductOptionValueScalarFieldEnum | ProductOptionValueScalarFieldEnum[]
  }

  /**
   * ProductOption.VariantOption
   */
  export type ProductOption$VariantOptionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    where?: VariantOptionWhereInput
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    cursor?: VariantOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * ProductOption without action
   */
  export type ProductOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOption
     */
    select?: ProductOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOption
     */
    omit?: ProductOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionInclude<ExtArgs> | null
  }


  /**
   * Model ProductOptionValue
   */

  export type AggregateProductOptionValue = {
    _count: ProductOptionValueCountAggregateOutputType | null
    _avg: ProductOptionValueAvgAggregateOutputType | null
    _sum: ProductOptionValueSumAggregateOutputType | null
    _min: ProductOptionValueMinAggregateOutputType | null
    _max: ProductOptionValueMaxAggregateOutputType | null
  }

  export type ProductOptionValueAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductOptionValueSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ProductOptionValueMinAggregateOutputType = {
    id: string | null
    productOptionId: string | null
    value: string | null
    label: string | null
    colorHex: string | null
    sortOrder: number | null
  }

  export type ProductOptionValueMaxAggregateOutputType = {
    id: string | null
    productOptionId: string | null
    value: string | null
    label: string | null
    colorHex: string | null
    sortOrder: number | null
  }

  export type ProductOptionValueCountAggregateOutputType = {
    id: number
    productOptionId: number
    value: number
    label: number
    colorHex: number
    sortOrder: number
    _all: number
  }


  export type ProductOptionValueAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ProductOptionValueSumAggregateInputType = {
    sortOrder?: true
  }

  export type ProductOptionValueMinAggregateInputType = {
    id?: true
    productOptionId?: true
    value?: true
    label?: true
    colorHex?: true
    sortOrder?: true
  }

  export type ProductOptionValueMaxAggregateInputType = {
    id?: true
    productOptionId?: true
    value?: true
    label?: true
    colorHex?: true
    sortOrder?: true
  }

  export type ProductOptionValueCountAggregateInputType = {
    id?: true
    productOptionId?: true
    value?: true
    label?: true
    colorHex?: true
    sortOrder?: true
    _all?: true
  }

  export type ProductOptionValueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOptionValue to aggregate.
     */
    where?: ProductOptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptionValues to fetch.
     */
    orderBy?: ProductOptionValueOrderByWithRelationInput | ProductOptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductOptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductOptionValues
    **/
    _count?: true | ProductOptionValueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductOptionValueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductOptionValueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductOptionValueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductOptionValueMaxAggregateInputType
  }

  export type GetProductOptionValueAggregateType<T extends ProductOptionValueAggregateArgs> = {
        [P in keyof T & keyof AggregateProductOptionValue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductOptionValue[P]>
      : GetScalarType<T[P], AggregateProductOptionValue[P]>
  }




  export type ProductOptionValueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductOptionValueWhereInput
    orderBy?: ProductOptionValueOrderByWithAggregationInput | ProductOptionValueOrderByWithAggregationInput[]
    by: ProductOptionValueScalarFieldEnum[] | ProductOptionValueScalarFieldEnum
    having?: ProductOptionValueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductOptionValueCountAggregateInputType | true
    _avg?: ProductOptionValueAvgAggregateInputType
    _sum?: ProductOptionValueSumAggregateInputType
    _min?: ProductOptionValueMinAggregateInputType
    _max?: ProductOptionValueMaxAggregateInputType
  }

  export type ProductOptionValueGroupByOutputType = {
    id: string
    productOptionId: string
    value: string
    label: string | null
    colorHex: string | null
    sortOrder: number
    _count: ProductOptionValueCountAggregateOutputType | null
    _avg: ProductOptionValueAvgAggregateOutputType | null
    _sum: ProductOptionValueSumAggregateOutputType | null
    _min: ProductOptionValueMinAggregateOutputType | null
    _max: ProductOptionValueMaxAggregateOutputType | null
  }

  type GetProductOptionValueGroupByPayload<T extends ProductOptionValueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductOptionValueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductOptionValueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductOptionValueGroupByOutputType[P]>
            : GetScalarType<T[P], ProductOptionValueGroupByOutputType[P]>
        }
      >
    >


  export type ProductOptionValueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productOptionId?: boolean
    value?: boolean
    label?: boolean
    colorHex?: boolean
    sortOrder?: boolean
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    variantLinks?: boolean | ProductOptionValue$variantLinksArgs<ExtArgs>
    _count?: boolean | ProductOptionValueCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOptionValue"]>

  export type ProductOptionValueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productOptionId?: boolean
    value?: boolean
    label?: boolean
    colorHex?: boolean
    sortOrder?: boolean
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOptionValue"]>

  export type ProductOptionValueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productOptionId?: boolean
    value?: boolean
    label?: boolean
    colorHex?: boolean
    sortOrder?: boolean
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productOptionValue"]>

  export type ProductOptionValueSelectScalar = {
    id?: boolean
    productOptionId?: boolean
    value?: boolean
    label?: boolean
    colorHex?: boolean
    sortOrder?: boolean
  }

  export type ProductOptionValueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productOptionId" | "value" | "label" | "colorHex" | "sortOrder", ExtArgs["result"]["productOptionValue"]>
  export type ProductOptionValueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    variantLinks?: boolean | ProductOptionValue$variantLinksArgs<ExtArgs>
    _count?: boolean | ProductOptionValueCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProductOptionValueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }
  export type ProductOptionValueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
  }

  export type $ProductOptionValuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductOptionValue"
    objects: {
      option: Prisma.$ProductOptionPayload<ExtArgs>
      variantLinks: Prisma.$VariantOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productOptionId: string
      value: string
      label: string | null
      colorHex: string | null
      sortOrder: number
    }, ExtArgs["result"]["productOptionValue"]>
    composites: {}
  }

  type ProductOptionValueGetPayload<S extends boolean | null | undefined | ProductOptionValueDefaultArgs> = $Result.GetResult<Prisma.$ProductOptionValuePayload, S>

  type ProductOptionValueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductOptionValueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductOptionValueCountAggregateInputType | true
    }

  export interface ProductOptionValueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductOptionValue'], meta: { name: 'ProductOptionValue' } }
    /**
     * Find zero or one ProductOptionValue that matches the filter.
     * @param {ProductOptionValueFindUniqueArgs} args - Arguments to find a ProductOptionValue
     * @example
     * // Get one ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductOptionValueFindUniqueArgs>(args: SelectSubset<T, ProductOptionValueFindUniqueArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductOptionValue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductOptionValueFindUniqueOrThrowArgs} args - Arguments to find a ProductOptionValue
     * @example
     * // Get one ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductOptionValueFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductOptionValueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOptionValue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueFindFirstArgs} args - Arguments to find a ProductOptionValue
     * @example
     * // Get one ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductOptionValueFindFirstArgs>(args?: SelectSubset<T, ProductOptionValueFindFirstArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductOptionValue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueFindFirstOrThrowArgs} args - Arguments to find a ProductOptionValue
     * @example
     * // Get one ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductOptionValueFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductOptionValueFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductOptionValues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductOptionValues
     * const productOptionValues = await prisma.productOptionValue.findMany()
     * 
     * // Get first 10 ProductOptionValues
     * const productOptionValues = await prisma.productOptionValue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productOptionValueWithIdOnly = await prisma.productOptionValue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductOptionValueFindManyArgs>(args?: SelectSubset<T, ProductOptionValueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductOptionValue.
     * @param {ProductOptionValueCreateArgs} args - Arguments to create a ProductOptionValue.
     * @example
     * // Create one ProductOptionValue
     * const ProductOptionValue = await prisma.productOptionValue.create({
     *   data: {
     *     // ... data to create a ProductOptionValue
     *   }
     * })
     * 
     */
    create<T extends ProductOptionValueCreateArgs>(args: SelectSubset<T, ProductOptionValueCreateArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductOptionValues.
     * @param {ProductOptionValueCreateManyArgs} args - Arguments to create many ProductOptionValues.
     * @example
     * // Create many ProductOptionValues
     * const productOptionValue = await prisma.productOptionValue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductOptionValueCreateManyArgs>(args?: SelectSubset<T, ProductOptionValueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductOptionValues and returns the data saved in the database.
     * @param {ProductOptionValueCreateManyAndReturnArgs} args - Arguments to create many ProductOptionValues.
     * @example
     * // Create many ProductOptionValues
     * const productOptionValue = await prisma.productOptionValue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductOptionValues and only return the `id`
     * const productOptionValueWithIdOnly = await prisma.productOptionValue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductOptionValueCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductOptionValueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductOptionValue.
     * @param {ProductOptionValueDeleteArgs} args - Arguments to delete one ProductOptionValue.
     * @example
     * // Delete one ProductOptionValue
     * const ProductOptionValue = await prisma.productOptionValue.delete({
     *   where: {
     *     // ... filter to delete one ProductOptionValue
     *   }
     * })
     * 
     */
    delete<T extends ProductOptionValueDeleteArgs>(args: SelectSubset<T, ProductOptionValueDeleteArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductOptionValue.
     * @param {ProductOptionValueUpdateArgs} args - Arguments to update one ProductOptionValue.
     * @example
     * // Update one ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductOptionValueUpdateArgs>(args: SelectSubset<T, ProductOptionValueUpdateArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductOptionValues.
     * @param {ProductOptionValueDeleteManyArgs} args - Arguments to filter ProductOptionValues to delete.
     * @example
     * // Delete a few ProductOptionValues
     * const { count } = await prisma.productOptionValue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductOptionValueDeleteManyArgs>(args?: SelectSubset<T, ProductOptionValueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductOptionValues
     * const productOptionValue = await prisma.productOptionValue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductOptionValueUpdateManyArgs>(args: SelectSubset<T, ProductOptionValueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductOptionValues and returns the data updated in the database.
     * @param {ProductOptionValueUpdateManyAndReturnArgs} args - Arguments to update many ProductOptionValues.
     * @example
     * // Update many ProductOptionValues
     * const productOptionValue = await prisma.productOptionValue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductOptionValues and only return the `id`
     * const productOptionValueWithIdOnly = await prisma.productOptionValue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductOptionValueUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductOptionValueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductOptionValue.
     * @param {ProductOptionValueUpsertArgs} args - Arguments to update or create a ProductOptionValue.
     * @example
     * // Update or create a ProductOptionValue
     * const productOptionValue = await prisma.productOptionValue.upsert({
     *   create: {
     *     // ... data to create a ProductOptionValue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductOptionValue we want to update
     *   }
     * })
     */
    upsert<T extends ProductOptionValueUpsertArgs>(args: SelectSubset<T, ProductOptionValueUpsertArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductOptionValues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueCountArgs} args - Arguments to filter ProductOptionValues to count.
     * @example
     * // Count the number of ProductOptionValues
     * const count = await prisma.productOptionValue.count({
     *   where: {
     *     // ... the filter for the ProductOptionValues we want to count
     *   }
     * })
    **/
    count<T extends ProductOptionValueCountArgs>(
      args?: Subset<T, ProductOptionValueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductOptionValueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductOptionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductOptionValueAggregateArgs>(args: Subset<T, ProductOptionValueAggregateArgs>): Prisma.PrismaPromise<GetProductOptionValueAggregateType<T>>

    /**
     * Group by ProductOptionValue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductOptionValueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductOptionValueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductOptionValueGroupByArgs['orderBy'] }
        : { orderBy?: ProductOptionValueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductOptionValueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductOptionValueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductOptionValue model
   */
  readonly fields: ProductOptionValueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductOptionValue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductOptionValueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    option<T extends ProductOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionDefaultArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variantLinks<T extends ProductOptionValue$variantLinksArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionValue$variantLinksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductOptionValue model
   */
  interface ProductOptionValueFieldRefs {
    readonly id: FieldRef<"ProductOptionValue", 'String'>
    readonly productOptionId: FieldRef<"ProductOptionValue", 'String'>
    readonly value: FieldRef<"ProductOptionValue", 'String'>
    readonly label: FieldRef<"ProductOptionValue", 'String'>
    readonly colorHex: FieldRef<"ProductOptionValue", 'String'>
    readonly sortOrder: FieldRef<"ProductOptionValue", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProductOptionValue findUnique
   */
  export type ProductOptionValueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptionValue to fetch.
     */
    where: ProductOptionValueWhereUniqueInput
  }

  /**
   * ProductOptionValue findUniqueOrThrow
   */
  export type ProductOptionValueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptionValue to fetch.
     */
    where: ProductOptionValueWhereUniqueInput
  }

  /**
   * ProductOptionValue findFirst
   */
  export type ProductOptionValueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptionValue to fetch.
     */
    where?: ProductOptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptionValues to fetch.
     */
    orderBy?: ProductOptionValueOrderByWithRelationInput | ProductOptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptionValues.
     */
    cursor?: ProductOptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptionValues.
     */
    distinct?: ProductOptionValueScalarFieldEnum | ProductOptionValueScalarFieldEnum[]
  }

  /**
   * ProductOptionValue findFirstOrThrow
   */
  export type ProductOptionValueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptionValue to fetch.
     */
    where?: ProductOptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptionValues to fetch.
     */
    orderBy?: ProductOptionValueOrderByWithRelationInput | ProductOptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductOptionValues.
     */
    cursor?: ProductOptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptionValues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductOptionValues.
     */
    distinct?: ProductOptionValueScalarFieldEnum | ProductOptionValueScalarFieldEnum[]
  }

  /**
   * ProductOptionValue findMany
   */
  export type ProductOptionValueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter, which ProductOptionValues to fetch.
     */
    where?: ProductOptionValueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductOptionValues to fetch.
     */
    orderBy?: ProductOptionValueOrderByWithRelationInput | ProductOptionValueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductOptionValues.
     */
    cursor?: ProductOptionValueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductOptionValues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductOptionValues.
     */
    skip?: number
    distinct?: ProductOptionValueScalarFieldEnum | ProductOptionValueScalarFieldEnum[]
  }

  /**
   * ProductOptionValue create
   */
  export type ProductOptionValueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductOptionValue.
     */
    data: XOR<ProductOptionValueCreateInput, ProductOptionValueUncheckedCreateInput>
  }

  /**
   * ProductOptionValue createMany
   */
  export type ProductOptionValueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductOptionValues.
     */
    data: ProductOptionValueCreateManyInput | ProductOptionValueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductOptionValue createManyAndReturn
   */
  export type ProductOptionValueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * The data used to create many ProductOptionValues.
     */
    data: ProductOptionValueCreateManyInput | ProductOptionValueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOptionValue update
   */
  export type ProductOptionValueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductOptionValue.
     */
    data: XOR<ProductOptionValueUpdateInput, ProductOptionValueUncheckedUpdateInput>
    /**
     * Choose, which ProductOptionValue to update.
     */
    where: ProductOptionValueWhereUniqueInput
  }

  /**
   * ProductOptionValue updateMany
   */
  export type ProductOptionValueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductOptionValues.
     */
    data: XOR<ProductOptionValueUpdateManyMutationInput, ProductOptionValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptionValues to update
     */
    where?: ProductOptionValueWhereInput
    /**
     * Limit how many ProductOptionValues to update.
     */
    limit?: number
  }

  /**
   * ProductOptionValue updateManyAndReturn
   */
  export type ProductOptionValueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * The data used to update ProductOptionValues.
     */
    data: XOR<ProductOptionValueUpdateManyMutationInput, ProductOptionValueUncheckedUpdateManyInput>
    /**
     * Filter which ProductOptionValues to update
     */
    where?: ProductOptionValueWhereInput
    /**
     * Limit how many ProductOptionValues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductOptionValue upsert
   */
  export type ProductOptionValueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductOptionValue to update in case it exists.
     */
    where: ProductOptionValueWhereUniqueInput
    /**
     * In case the ProductOptionValue found by the `where` argument doesn't exist, create a new ProductOptionValue with this data.
     */
    create: XOR<ProductOptionValueCreateInput, ProductOptionValueUncheckedCreateInput>
    /**
     * In case the ProductOptionValue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductOptionValueUpdateInput, ProductOptionValueUncheckedUpdateInput>
  }

  /**
   * ProductOptionValue delete
   */
  export type ProductOptionValueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
    /**
     * Filter which ProductOptionValue to delete.
     */
    where: ProductOptionValueWhereUniqueInput
  }

  /**
   * ProductOptionValue deleteMany
   */
  export type ProductOptionValueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductOptionValues to delete
     */
    where?: ProductOptionValueWhereInput
    /**
     * Limit how many ProductOptionValues to delete.
     */
    limit?: number
  }

  /**
   * ProductOptionValue.variantLinks
   */
  export type ProductOptionValue$variantLinksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    where?: VariantOptionWhereInput
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    cursor?: VariantOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * ProductOptionValue without action
   */
  export type ProductOptionValueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductOptionValue
     */
    select?: ProductOptionValueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductOptionValue
     */
    omit?: ProductOptionValueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductOptionValueInclude<ExtArgs> | null
  }


  /**
   * Model VariantOption
   */

  export type AggregateVariantOption = {
    _count: VariantOptionCountAggregateOutputType | null
    _min: VariantOptionMinAggregateOutputType | null
    _max: VariantOptionMaxAggregateOutputType | null
  }

  export type VariantOptionMinAggregateOutputType = {
    id: string | null
    variantId: string | null
    productOptionId: string | null
    productOptionValueId: string | null
  }

  export type VariantOptionMaxAggregateOutputType = {
    id: string | null
    variantId: string | null
    productOptionId: string | null
    productOptionValueId: string | null
  }

  export type VariantOptionCountAggregateOutputType = {
    id: number
    variantId: number
    productOptionId: number
    productOptionValueId: number
    _all: number
  }


  export type VariantOptionMinAggregateInputType = {
    id?: true
    variantId?: true
    productOptionId?: true
    productOptionValueId?: true
  }

  export type VariantOptionMaxAggregateInputType = {
    id?: true
    variantId?: true
    productOptionId?: true
    productOptionValueId?: true
  }

  export type VariantOptionCountAggregateInputType = {
    id?: true
    variantId?: true
    productOptionId?: true
    productOptionValueId?: true
    _all?: true
  }

  export type VariantOptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantOption to aggregate.
     */
    where?: VariantOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantOptions to fetch.
     */
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariantOptions
    **/
    _count?: true | VariantOptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantOptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantOptionMaxAggregateInputType
  }

  export type GetVariantOptionAggregateType<T extends VariantOptionAggregateArgs> = {
        [P in keyof T & keyof AggregateVariantOption]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariantOption[P]>
      : GetScalarType<T[P], AggregateVariantOption[P]>
  }




  export type VariantOptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantOptionWhereInput
    orderBy?: VariantOptionOrderByWithAggregationInput | VariantOptionOrderByWithAggregationInput[]
    by: VariantOptionScalarFieldEnum[] | VariantOptionScalarFieldEnum
    having?: VariantOptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantOptionCountAggregateInputType | true
    _min?: VariantOptionMinAggregateInputType
    _max?: VariantOptionMaxAggregateInputType
  }

  export type VariantOptionGroupByOutputType = {
    id: string
    variantId: string
    productOptionId: string
    productOptionValueId: string
    _count: VariantOptionCountAggregateOutputType | null
    _min: VariantOptionMinAggregateOutputType | null
    _max: VariantOptionMaxAggregateOutputType | null
  }

  type GetVariantOptionGroupByPayload<T extends VariantOptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantOptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantOptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantOptionGroupByOutputType[P]>
            : GetScalarType<T[P], VariantOptionGroupByOutputType[P]>
        }
      >
    >


  export type VariantOptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    productOptionId?: boolean
    productOptionValueId?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantOption"]>

  export type VariantOptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    productOptionId?: boolean
    productOptionValueId?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantOption"]>

  export type VariantOptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    productOptionId?: boolean
    productOptionValueId?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantOption"]>

  export type VariantOptionSelectScalar = {
    id?: boolean
    variantId?: boolean
    productOptionId?: boolean
    productOptionValueId?: boolean
  }

  export type VariantOptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variantId" | "productOptionId" | "productOptionValueId", ExtArgs["result"]["variantOption"]>
  export type VariantOptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }
  export type VariantOptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }
  export type VariantOptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
    option?: boolean | ProductOptionDefaultArgs<ExtArgs>
    value?: boolean | ProductOptionValueDefaultArgs<ExtArgs>
  }

  export type $VariantOptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariantOption"
    objects: {
      variant: Prisma.$VariantPayload<ExtArgs>
      option: Prisma.$ProductOptionPayload<ExtArgs>
      value: Prisma.$ProductOptionValuePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variantId: string
      productOptionId: string
      productOptionValueId: string
    }, ExtArgs["result"]["variantOption"]>
    composites: {}
  }

  type VariantOptionGetPayload<S extends boolean | null | undefined | VariantOptionDefaultArgs> = $Result.GetResult<Prisma.$VariantOptionPayload, S>

  type VariantOptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariantOptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantOptionCountAggregateInputType | true
    }

  export interface VariantOptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariantOption'], meta: { name: 'VariantOption' } }
    /**
     * Find zero or one VariantOption that matches the filter.
     * @param {VariantOptionFindUniqueArgs} args - Arguments to find a VariantOption
     * @example
     * // Get one VariantOption
     * const variantOption = await prisma.variantOption.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantOptionFindUniqueArgs>(args: SelectSubset<T, VariantOptionFindUniqueArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariantOption that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariantOptionFindUniqueOrThrowArgs} args - Arguments to find a VariantOption
     * @example
     * // Get one VariantOption
     * const variantOption = await prisma.variantOption.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantOptionFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantOptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariantOption that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionFindFirstArgs} args - Arguments to find a VariantOption
     * @example
     * // Get one VariantOption
     * const variantOption = await prisma.variantOption.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantOptionFindFirstArgs>(args?: SelectSubset<T, VariantOptionFindFirstArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariantOption that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionFindFirstOrThrowArgs} args - Arguments to find a VariantOption
     * @example
     * // Get one VariantOption
     * const variantOption = await prisma.variantOption.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantOptionFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantOptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariantOptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariantOptions
     * const variantOptions = await prisma.variantOption.findMany()
     * 
     * // Get first 10 VariantOptions
     * const variantOptions = await prisma.variantOption.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantOptionWithIdOnly = await prisma.variantOption.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantOptionFindManyArgs>(args?: SelectSubset<T, VariantOptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariantOption.
     * @param {VariantOptionCreateArgs} args - Arguments to create a VariantOption.
     * @example
     * // Create one VariantOption
     * const VariantOption = await prisma.variantOption.create({
     *   data: {
     *     // ... data to create a VariantOption
     *   }
     * })
     * 
     */
    create<T extends VariantOptionCreateArgs>(args: SelectSubset<T, VariantOptionCreateArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariantOptions.
     * @param {VariantOptionCreateManyArgs} args - Arguments to create many VariantOptions.
     * @example
     * // Create many VariantOptions
     * const variantOption = await prisma.variantOption.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantOptionCreateManyArgs>(args?: SelectSubset<T, VariantOptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariantOptions and returns the data saved in the database.
     * @param {VariantOptionCreateManyAndReturnArgs} args - Arguments to create many VariantOptions.
     * @example
     * // Create many VariantOptions
     * const variantOption = await prisma.variantOption.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariantOptions and only return the `id`
     * const variantOptionWithIdOnly = await prisma.variantOption.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantOptionCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantOptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariantOption.
     * @param {VariantOptionDeleteArgs} args - Arguments to delete one VariantOption.
     * @example
     * // Delete one VariantOption
     * const VariantOption = await prisma.variantOption.delete({
     *   where: {
     *     // ... filter to delete one VariantOption
     *   }
     * })
     * 
     */
    delete<T extends VariantOptionDeleteArgs>(args: SelectSubset<T, VariantOptionDeleteArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariantOption.
     * @param {VariantOptionUpdateArgs} args - Arguments to update one VariantOption.
     * @example
     * // Update one VariantOption
     * const variantOption = await prisma.variantOption.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantOptionUpdateArgs>(args: SelectSubset<T, VariantOptionUpdateArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariantOptions.
     * @param {VariantOptionDeleteManyArgs} args - Arguments to filter VariantOptions to delete.
     * @example
     * // Delete a few VariantOptions
     * const { count } = await prisma.variantOption.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantOptionDeleteManyArgs>(args?: SelectSubset<T, VariantOptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariantOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariantOptions
     * const variantOption = await prisma.variantOption.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantOptionUpdateManyArgs>(args: SelectSubset<T, VariantOptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariantOptions and returns the data updated in the database.
     * @param {VariantOptionUpdateManyAndReturnArgs} args - Arguments to update many VariantOptions.
     * @example
     * // Update many VariantOptions
     * const variantOption = await prisma.variantOption.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariantOptions and only return the `id`
     * const variantOptionWithIdOnly = await prisma.variantOption.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariantOptionUpdateManyAndReturnArgs>(args: SelectSubset<T, VariantOptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariantOption.
     * @param {VariantOptionUpsertArgs} args - Arguments to update or create a VariantOption.
     * @example
     * // Update or create a VariantOption
     * const variantOption = await prisma.variantOption.upsert({
     *   create: {
     *     // ... data to create a VariantOption
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariantOption we want to update
     *   }
     * })
     */
    upsert<T extends VariantOptionUpsertArgs>(args: SelectSubset<T, VariantOptionUpsertArgs<ExtArgs>>): Prisma__VariantOptionClient<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariantOptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionCountArgs} args - Arguments to filter VariantOptions to count.
     * @example
     * // Count the number of VariantOptions
     * const count = await prisma.variantOption.count({
     *   where: {
     *     // ... the filter for the VariantOptions we want to count
     *   }
     * })
    **/
    count<T extends VariantOptionCountArgs>(
      args?: Subset<T, VariantOptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantOptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariantOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantOptionAggregateArgs>(args: Subset<T, VariantOptionAggregateArgs>): Prisma.PrismaPromise<GetVariantOptionAggregateType<T>>

    /**
     * Group by VariantOption.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantOptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantOptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantOptionGroupByArgs['orderBy'] }
        : { orderBy?: VariantOptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantOptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantOptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariantOption model
   */
  readonly fields: VariantOptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariantOption.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantOptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends VariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariantDefaultArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    option<T extends ProductOptionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionDefaultArgs<ExtArgs>>): Prisma__ProductOptionClient<$Result.GetResult<Prisma.$ProductOptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    value<T extends ProductOptionValueDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductOptionValueDefaultArgs<ExtArgs>>): Prisma__ProductOptionValueClient<$Result.GetResult<Prisma.$ProductOptionValuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariantOption model
   */
  interface VariantOptionFieldRefs {
    readonly id: FieldRef<"VariantOption", 'String'>
    readonly variantId: FieldRef<"VariantOption", 'String'>
    readonly productOptionId: FieldRef<"VariantOption", 'String'>
    readonly productOptionValueId: FieldRef<"VariantOption", 'String'>
  }
    

  // Custom InputTypes
  /**
   * VariantOption findUnique
   */
  export type VariantOptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter, which VariantOption to fetch.
     */
    where: VariantOptionWhereUniqueInput
  }

  /**
   * VariantOption findUniqueOrThrow
   */
  export type VariantOptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter, which VariantOption to fetch.
     */
    where: VariantOptionWhereUniqueInput
  }

  /**
   * VariantOption findFirst
   */
  export type VariantOptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter, which VariantOption to fetch.
     */
    where?: VariantOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantOptions to fetch.
     */
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantOptions.
     */
    cursor?: VariantOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantOptions.
     */
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * VariantOption findFirstOrThrow
   */
  export type VariantOptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter, which VariantOption to fetch.
     */
    where?: VariantOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantOptions to fetch.
     */
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantOptions.
     */
    cursor?: VariantOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantOptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantOptions.
     */
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * VariantOption findMany
   */
  export type VariantOptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter, which VariantOptions to fetch.
     */
    where?: VariantOptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantOptions to fetch.
     */
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariantOptions.
     */
    cursor?: VariantOptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantOptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantOptions.
     */
    skip?: number
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * VariantOption create
   */
  export type VariantOptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * The data needed to create a VariantOption.
     */
    data: XOR<VariantOptionCreateInput, VariantOptionUncheckedCreateInput>
  }

  /**
   * VariantOption createMany
   */
  export type VariantOptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariantOptions.
     */
    data: VariantOptionCreateManyInput | VariantOptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariantOption createManyAndReturn
   */
  export type VariantOptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * The data used to create many VariantOptions.
     */
    data: VariantOptionCreateManyInput | VariantOptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariantOption update
   */
  export type VariantOptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * The data needed to update a VariantOption.
     */
    data: XOR<VariantOptionUpdateInput, VariantOptionUncheckedUpdateInput>
    /**
     * Choose, which VariantOption to update.
     */
    where: VariantOptionWhereUniqueInput
  }

  /**
   * VariantOption updateMany
   */
  export type VariantOptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariantOptions.
     */
    data: XOR<VariantOptionUpdateManyMutationInput, VariantOptionUncheckedUpdateManyInput>
    /**
     * Filter which VariantOptions to update
     */
    where?: VariantOptionWhereInput
    /**
     * Limit how many VariantOptions to update.
     */
    limit?: number
  }

  /**
   * VariantOption updateManyAndReturn
   */
  export type VariantOptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * The data used to update VariantOptions.
     */
    data: XOR<VariantOptionUpdateManyMutationInput, VariantOptionUncheckedUpdateManyInput>
    /**
     * Filter which VariantOptions to update
     */
    where?: VariantOptionWhereInput
    /**
     * Limit how many VariantOptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariantOption upsert
   */
  export type VariantOptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * The filter to search for the VariantOption to update in case it exists.
     */
    where: VariantOptionWhereUniqueInput
    /**
     * In case the VariantOption found by the `where` argument doesn't exist, create a new VariantOption with this data.
     */
    create: XOR<VariantOptionCreateInput, VariantOptionUncheckedCreateInput>
    /**
     * In case the VariantOption was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantOptionUpdateInput, VariantOptionUncheckedUpdateInput>
  }

  /**
   * VariantOption delete
   */
  export type VariantOptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    /**
     * Filter which VariantOption to delete.
     */
    where: VariantOptionWhereUniqueInput
  }

  /**
   * VariantOption deleteMany
   */
  export type VariantOptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantOptions to delete
     */
    where?: VariantOptionWhereInput
    /**
     * Limit how many VariantOptions to delete.
     */
    limit?: number
  }

  /**
   * VariantOption without action
   */
  export type VariantOptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
  }


  /**
   * Model Variant
   */

  export type AggregateVariant = {
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  export type VariantAvgAggregateOutputType = {
    price: Decimal | null
    stock: number | null
    weight: Decimal | null
  }

  export type VariantSumAggregateOutputType = {
    price: Decimal | null
    stock: number | null
    weight: Decimal | null
  }

  export type VariantMinAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    price: Decimal | null
    currency: string | null
    stock: number | null
    weight: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    sku: string | null
    price: Decimal | null
    currency: string | null
    stock: number | null
    weight: Decimal | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantCountAggregateOutputType = {
    id: number
    productId: number
    sku: number
    price: number
    currency: number
    stock: number
    weight: number
    dimensions: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariantAvgAggregateInputType = {
    price?: true
    stock?: true
    weight?: true
  }

  export type VariantSumAggregateInputType = {
    price?: true
    stock?: true
    weight?: true
  }

  export type VariantMinAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    currency?: true
    stock?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantMaxAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    currency?: true
    stock?: true
    weight?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantCountAggregateInputType = {
    id?: true
    productId?: true
    sku?: true
    price?: true
    currency?: true
    stock?: true
    weight?: true
    dimensions?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variant to aggregate.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Variants
    **/
    _count?: true | VariantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariantAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariantSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantMaxAggregateInputType
  }

  export type GetVariantAggregateType<T extends VariantAggregateArgs> = {
        [P in keyof T & keyof AggregateVariant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariant[P]>
      : GetScalarType<T[P], AggregateVariant[P]>
  }




  export type VariantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantWhereInput
    orderBy?: VariantOrderByWithAggregationInput | VariantOrderByWithAggregationInput[]
    by: VariantScalarFieldEnum[] | VariantScalarFieldEnum
    having?: VariantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantCountAggregateInputType | true
    _avg?: VariantAvgAggregateInputType
    _sum?: VariantSumAggregateInputType
    _min?: VariantMinAggregateInputType
    _max?: VariantMaxAggregateInputType
  }

  export type VariantGroupByOutputType = {
    id: string
    productId: string
    sku: string
    price: Decimal
    currency: string
    stock: number
    weight: Decimal | null
    dimensions: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: VariantCountAggregateOutputType | null
    _avg: VariantAvgAggregateOutputType | null
    _sum: VariantSumAggregateOutputType | null
    _min: VariantMinAggregateOutputType | null
    _max: VariantMaxAggregateOutputType | null
  }

  type GetVariantGroupByPayload<T extends VariantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantGroupByOutputType[P]>
            : GetScalarType<T[P], VariantGroupByOutputType[P]>
        }
      >
    >


  export type VariantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    weight?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | Variant$imagesArgs<ExtArgs>
    options?: boolean | Variant$optionsArgs<ExtArgs>
    _count?: boolean | VariantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    weight?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    weight?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variant"]>

  export type VariantSelectScalar = {
    id?: boolean
    productId?: boolean
    sku?: boolean
    price?: boolean
    currency?: boolean
    stock?: boolean
    weight?: boolean
    dimensions?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type VariantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "sku" | "price" | "currency" | "stock" | "weight" | "dimensions" | "createdAt" | "updatedAt", ExtArgs["result"]["variant"]>
  export type VariantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    images?: boolean | Variant$imagesArgs<ExtArgs>
    options?: boolean | Variant$optionsArgs<ExtArgs>
    _count?: boolean | VariantCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VariantIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type VariantIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $VariantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Variant"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      images: Prisma.$VariantImagePayload<ExtArgs>[]
      options: Prisma.$VariantOptionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      sku: string
      price: Prisma.Decimal
      currency: string
      stock: number
      weight: Prisma.Decimal | null
      dimensions: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variant"]>
    composites: {}
  }

  type VariantGetPayload<S extends boolean | null | undefined | VariantDefaultArgs> = $Result.GetResult<Prisma.$VariantPayload, S>

  type VariantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantCountAggregateInputType | true
    }

  export interface VariantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Variant'], meta: { name: 'Variant' } }
    /**
     * Find zero or one Variant that matches the filter.
     * @param {VariantFindUniqueArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantFindUniqueArgs>(args: SelectSubset<T, VariantFindUniqueArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariantFindUniqueOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantFindFirstArgs>(args?: SelectSubset<T, VariantFindFirstArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindFirstOrThrowArgs} args - Arguments to find a Variant
     * @example
     * // Get one Variant
     * const variant = await prisma.variant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variant.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantWithIdOnly = await prisma.variant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantFindManyArgs>(args?: SelectSubset<T, VariantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variant.
     * @param {VariantCreateArgs} args - Arguments to create a Variant.
     * @example
     * // Create one Variant
     * const Variant = await prisma.variant.create({
     *   data: {
     *     // ... data to create a Variant
     *   }
     * })
     * 
     */
    create<T extends VariantCreateArgs>(args: SelectSubset<T, VariantCreateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variants.
     * @param {VariantCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantCreateManyArgs>(args?: SelectSubset<T, VariantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Variants and returns the data saved in the database.
     * @param {VariantCreateManyAndReturnArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variant = await prisma.variant.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Variants and only return the `id`
     * const variantWithIdOnly = await prisma.variant.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Variant.
     * @param {VariantDeleteArgs} args - Arguments to delete one Variant.
     * @example
     * // Delete one Variant
     * const Variant = await prisma.variant.delete({
     *   where: {
     *     // ... filter to delete one Variant
     *   }
     * })
     * 
     */
    delete<T extends VariantDeleteArgs>(args: SelectSubset<T, VariantDeleteArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variant.
     * @param {VariantUpdateArgs} args - Arguments to update one Variant.
     * @example
     * // Update one Variant
     * const variant = await prisma.variant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantUpdateArgs>(args: SelectSubset<T, VariantUpdateArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variants.
     * @param {VariantDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantDeleteManyArgs>(args?: SelectSubset<T, VariantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variant = await prisma.variant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantUpdateManyArgs>(args: SelectSubset<T, VariantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants and returns the data updated in the database.
     * @param {VariantUpdateManyAndReturnArgs} args - Arguments to update many Variants.
     * @example
     * // Update many Variants
     * const variant = await prisma.variant.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Variants and only return the `id`
     * const variantWithIdOnly = await prisma.variant.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariantUpdateManyAndReturnArgs>(args: SelectSubset<T, VariantUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Variant.
     * @param {VariantUpsertArgs} args - Arguments to update or create a Variant.
     * @example
     * // Update or create a Variant
     * const variant = await prisma.variant.upsert({
     *   create: {
     *     // ... data to create a Variant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variant we want to update
     *   }
     * })
     */
    upsert<T extends VariantUpsertArgs>(args: SelectSubset<T, VariantUpsertArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variant.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends VariantCountArgs>(
      args?: Subset<T, VariantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantAggregateArgs>(args: Subset<T, VariantAggregateArgs>): Prisma.PrismaPromise<GetVariantAggregateType<T>>

    /**
     * Group by Variant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantGroupByArgs['orderBy'] }
        : { orderBy?: VariantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Variant model
   */
  readonly fields: VariantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Variant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    images<T extends Variant$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Variant$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    options<T extends Variant$optionsArgs<ExtArgs> = {}>(args?: Subset<T, Variant$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantOptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Variant model
   */
  interface VariantFieldRefs {
    readonly id: FieldRef<"Variant", 'String'>
    readonly productId: FieldRef<"Variant", 'String'>
    readonly sku: FieldRef<"Variant", 'String'>
    readonly price: FieldRef<"Variant", 'Decimal'>
    readonly currency: FieldRef<"Variant", 'String'>
    readonly stock: FieldRef<"Variant", 'Int'>
    readonly weight: FieldRef<"Variant", 'Decimal'>
    readonly dimensions: FieldRef<"Variant", 'Json'>
    readonly createdAt: FieldRef<"Variant", 'DateTime'>
    readonly updatedAt: FieldRef<"Variant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Variant findUnique
   */
  export type VariantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findUniqueOrThrow
   */
  export type VariantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant findFirst
   */
  export type VariantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findFirstOrThrow
   */
  export type VariantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variant to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Variants.
     */
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant findMany
   */
  export type VariantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter, which Variants to fetch.
     */
    where?: VariantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Variants to fetch.
     */
    orderBy?: VariantOrderByWithRelationInput | VariantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Variants.
     */
    cursor?: VariantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Variants.
     */
    skip?: number
    distinct?: VariantScalarFieldEnum | VariantScalarFieldEnum[]
  }

  /**
   * Variant create
   */
  export type VariantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to create a Variant.
     */
    data: XOR<VariantCreateInput, VariantUncheckedCreateInput>
  }

  /**
   * Variant createMany
   */
  export type VariantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Variant createManyAndReturn
   */
  export type VariantCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * The data used to create many Variants.
     */
    data: VariantCreateManyInput | VariantCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant update
   */
  export type VariantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The data needed to update a Variant.
     */
    data: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
    /**
     * Choose, which Variant to update.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant updateMany
   */
  export type VariantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to update.
     */
    limit?: number
  }

  /**
   * Variant updateManyAndReturn
   */
  export type VariantUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * The data used to update Variants.
     */
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyInput>
    /**
     * Filter which Variants to update
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Variant upsert
   */
  export type VariantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * The filter to search for the Variant to update in case it exists.
     */
    where: VariantWhereUniqueInput
    /**
     * In case the Variant found by the `where` argument doesn't exist, create a new Variant with this data.
     */
    create: XOR<VariantCreateInput, VariantUncheckedCreateInput>
    /**
     * In case the Variant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantUpdateInput, VariantUncheckedUpdateInput>
  }

  /**
   * Variant delete
   */
  export type VariantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
    /**
     * Filter which Variant to delete.
     */
    where: VariantWhereUniqueInput
  }

  /**
   * Variant deleteMany
   */
  export type VariantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Variants to delete
     */
    where?: VariantWhereInput
    /**
     * Limit how many Variants to delete.
     */
    limit?: number
  }

  /**
   * Variant.images
   */
  export type Variant$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    where?: VariantImageWhereInput
    orderBy?: VariantImageOrderByWithRelationInput | VariantImageOrderByWithRelationInput[]
    cursor?: VariantImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantImageScalarFieldEnum | VariantImageScalarFieldEnum[]
  }

  /**
   * Variant.options
   */
  export type Variant$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantOption
     */
    select?: VariantOptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantOption
     */
    omit?: VariantOptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantOptionInclude<ExtArgs> | null
    where?: VariantOptionWhereInput
    orderBy?: VariantOptionOrderByWithRelationInput | VariantOptionOrderByWithRelationInput[]
    cursor?: VariantOptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantOptionScalarFieldEnum | VariantOptionScalarFieldEnum[]
  }

  /**
   * Variant without action
   */
  export type VariantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Variant
     */
    select?: VariantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Variant
     */
    omit?: VariantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantInclude<ExtArgs> | null
  }


  /**
   * Model VariantImage
   */

  export type AggregateVariantImage = {
    _count: VariantImageCountAggregateOutputType | null
    _avg: VariantImageAvgAggregateOutputType | null
    _sum: VariantImageSumAggregateOutputType | null
    _min: VariantImageMinAggregateOutputType | null
    _max: VariantImageMaxAggregateOutputType | null
  }

  export type VariantImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type VariantImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type VariantImageMinAggregateOutputType = {
    id: string | null
    variantId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type VariantImageMaxAggregateOutputType = {
    id: string | null
    variantId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type VariantImageCountAggregateOutputType = {
    id: number
    variantId: number
    url: number
    altText: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type VariantImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type VariantImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type VariantImageMinAggregateInputType = {
    id?: true
    variantId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type VariantImageMaxAggregateInputType = {
    id?: true
    variantId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type VariantImageCountAggregateInputType = {
    id?: true
    variantId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type VariantImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantImage to aggregate.
     */
    where?: VariantImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantImages to fetch.
     */
    orderBy?: VariantImageOrderByWithRelationInput | VariantImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VariantImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VariantImages
    **/
    _count?: true | VariantImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VariantImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VariantImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantImageMaxAggregateInputType
  }

  export type GetVariantImageAggregateType<T extends VariantImageAggregateArgs> = {
        [P in keyof T & keyof AggregateVariantImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariantImage[P]>
      : GetScalarType<T[P], AggregateVariantImage[P]>
  }




  export type VariantImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VariantImageWhereInput
    orderBy?: VariantImageOrderByWithAggregationInput | VariantImageOrderByWithAggregationInput[]
    by: VariantImageScalarFieldEnum[] | VariantImageScalarFieldEnum
    having?: VariantImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantImageCountAggregateInputType | true
    _avg?: VariantImageAvgAggregateInputType
    _sum?: VariantImageSumAggregateInputType
    _min?: VariantImageMinAggregateInputType
    _max?: VariantImageMaxAggregateInputType
  }

  export type VariantImageGroupByOutputType = {
    id: string
    variantId: string
    url: string
    altText: string | null
    sortOrder: number
    createdAt: Date
    _count: VariantImageCountAggregateOutputType | null
    _avg: VariantImageAvgAggregateOutputType | null
    _sum: VariantImageSumAggregateOutputType | null
    _min: VariantImageMinAggregateOutputType | null
    _max: VariantImageMaxAggregateOutputType | null
  }

  type GetVariantImageGroupByPayload<T extends VariantImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantImageGroupByOutputType[P]>
            : GetScalarType<T[P], VariantImageGroupByOutputType[P]>
        }
      >
    >


  export type VariantImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantImage"]>

  export type VariantImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantImage"]>

  export type VariantImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    variantId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variantImage"]>

  export type VariantImageSelectScalar = {
    id?: boolean
    variantId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type VariantImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "variantId" | "url" | "altText" | "sortOrder" | "createdAt", ExtArgs["result"]["variantImage"]>
  export type VariantImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }
  export type VariantImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }
  export type VariantImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variant?: boolean | VariantDefaultArgs<ExtArgs>
  }

  export type $VariantImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VariantImage"
    objects: {
      variant: Prisma.$VariantPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      variantId: string
      url: string
      altText: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["variantImage"]>
    composites: {}
  }

  type VariantImageGetPayload<S extends boolean | null | undefined | VariantImageDefaultArgs> = $Result.GetResult<Prisma.$VariantImagePayload, S>

  type VariantImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VariantImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantImageCountAggregateInputType | true
    }

  export interface VariantImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VariantImage'], meta: { name: 'VariantImage' } }
    /**
     * Find zero or one VariantImage that matches the filter.
     * @param {VariantImageFindUniqueArgs} args - Arguments to find a VariantImage
     * @example
     * // Get one VariantImage
     * const variantImage = await prisma.variantImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VariantImageFindUniqueArgs>(args: SelectSubset<T, VariantImageFindUniqueArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VariantImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VariantImageFindUniqueOrThrowArgs} args - Arguments to find a VariantImage
     * @example
     * // Get one VariantImage
     * const variantImage = await prisma.variantImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VariantImageFindUniqueOrThrowArgs>(args: SelectSubset<T, VariantImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariantImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageFindFirstArgs} args - Arguments to find a VariantImage
     * @example
     * // Get one VariantImage
     * const variantImage = await prisma.variantImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VariantImageFindFirstArgs>(args?: SelectSubset<T, VariantImageFindFirstArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VariantImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageFindFirstOrThrowArgs} args - Arguments to find a VariantImage
     * @example
     * // Get one VariantImage
     * const variantImage = await prisma.variantImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VariantImageFindFirstOrThrowArgs>(args?: SelectSubset<T, VariantImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VariantImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VariantImages
     * const variantImages = await prisma.variantImage.findMany()
     * 
     * // Get first 10 VariantImages
     * const variantImages = await prisma.variantImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantImageWithIdOnly = await prisma.variantImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VariantImageFindManyArgs>(args?: SelectSubset<T, VariantImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VariantImage.
     * @param {VariantImageCreateArgs} args - Arguments to create a VariantImage.
     * @example
     * // Create one VariantImage
     * const VariantImage = await prisma.variantImage.create({
     *   data: {
     *     // ... data to create a VariantImage
     *   }
     * })
     * 
     */
    create<T extends VariantImageCreateArgs>(args: SelectSubset<T, VariantImageCreateArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VariantImages.
     * @param {VariantImageCreateManyArgs} args - Arguments to create many VariantImages.
     * @example
     * // Create many VariantImages
     * const variantImage = await prisma.variantImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VariantImageCreateManyArgs>(args?: SelectSubset<T, VariantImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VariantImages and returns the data saved in the database.
     * @param {VariantImageCreateManyAndReturnArgs} args - Arguments to create many VariantImages.
     * @example
     * // Create many VariantImages
     * const variantImage = await prisma.variantImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VariantImages and only return the `id`
     * const variantImageWithIdOnly = await prisma.variantImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VariantImageCreateManyAndReturnArgs>(args?: SelectSubset<T, VariantImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VariantImage.
     * @param {VariantImageDeleteArgs} args - Arguments to delete one VariantImage.
     * @example
     * // Delete one VariantImage
     * const VariantImage = await prisma.variantImage.delete({
     *   where: {
     *     // ... filter to delete one VariantImage
     *   }
     * })
     * 
     */
    delete<T extends VariantImageDeleteArgs>(args: SelectSubset<T, VariantImageDeleteArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VariantImage.
     * @param {VariantImageUpdateArgs} args - Arguments to update one VariantImage.
     * @example
     * // Update one VariantImage
     * const variantImage = await prisma.variantImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VariantImageUpdateArgs>(args: SelectSubset<T, VariantImageUpdateArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VariantImages.
     * @param {VariantImageDeleteManyArgs} args - Arguments to filter VariantImages to delete.
     * @example
     * // Delete a few VariantImages
     * const { count } = await prisma.variantImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VariantImageDeleteManyArgs>(args?: SelectSubset<T, VariantImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariantImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VariantImages
     * const variantImage = await prisma.variantImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VariantImageUpdateManyArgs>(args: SelectSubset<T, VariantImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VariantImages and returns the data updated in the database.
     * @param {VariantImageUpdateManyAndReturnArgs} args - Arguments to update many VariantImages.
     * @example
     * // Update many VariantImages
     * const variantImage = await prisma.variantImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VariantImages and only return the `id`
     * const variantImageWithIdOnly = await prisma.variantImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VariantImageUpdateManyAndReturnArgs>(args: SelectSubset<T, VariantImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VariantImage.
     * @param {VariantImageUpsertArgs} args - Arguments to update or create a VariantImage.
     * @example
     * // Update or create a VariantImage
     * const variantImage = await prisma.variantImage.upsert({
     *   create: {
     *     // ... data to create a VariantImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VariantImage we want to update
     *   }
     * })
     */
    upsert<T extends VariantImageUpsertArgs>(args: SelectSubset<T, VariantImageUpsertArgs<ExtArgs>>): Prisma__VariantImageClient<$Result.GetResult<Prisma.$VariantImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VariantImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageCountArgs} args - Arguments to filter VariantImages to count.
     * @example
     * // Count the number of VariantImages
     * const count = await prisma.variantImage.count({
     *   where: {
     *     // ... the filter for the VariantImages we want to count
     *   }
     * })
    **/
    count<T extends VariantImageCountArgs>(
      args?: Subset<T, VariantImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VariantImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantImageAggregateArgs>(args: Subset<T, VariantImageAggregateArgs>): Prisma.PrismaPromise<GetVariantImageAggregateType<T>>

    /**
     * Group by VariantImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VariantImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VariantImageGroupByArgs['orderBy'] }
        : { orderBy?: VariantImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VariantImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VariantImage model
   */
  readonly fields: VariantImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VariantImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VariantImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    variant<T extends VariantDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VariantDefaultArgs<ExtArgs>>): Prisma__VariantClient<$Result.GetResult<Prisma.$VariantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VariantImage model
   */
  interface VariantImageFieldRefs {
    readonly id: FieldRef<"VariantImage", 'String'>
    readonly variantId: FieldRef<"VariantImage", 'String'>
    readonly url: FieldRef<"VariantImage", 'String'>
    readonly altText: FieldRef<"VariantImage", 'String'>
    readonly sortOrder: FieldRef<"VariantImage", 'Int'>
    readonly createdAt: FieldRef<"VariantImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VariantImage findUnique
   */
  export type VariantImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter, which VariantImage to fetch.
     */
    where: VariantImageWhereUniqueInput
  }

  /**
   * VariantImage findUniqueOrThrow
   */
  export type VariantImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter, which VariantImage to fetch.
     */
    where: VariantImageWhereUniqueInput
  }

  /**
   * VariantImage findFirst
   */
  export type VariantImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter, which VariantImage to fetch.
     */
    where?: VariantImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantImages to fetch.
     */
    orderBy?: VariantImageOrderByWithRelationInput | VariantImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantImages.
     */
    cursor?: VariantImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantImages.
     */
    distinct?: VariantImageScalarFieldEnum | VariantImageScalarFieldEnum[]
  }

  /**
   * VariantImage findFirstOrThrow
   */
  export type VariantImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter, which VariantImage to fetch.
     */
    where?: VariantImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantImages to fetch.
     */
    orderBy?: VariantImageOrderByWithRelationInput | VariantImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VariantImages.
     */
    cursor?: VariantImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VariantImages.
     */
    distinct?: VariantImageScalarFieldEnum | VariantImageScalarFieldEnum[]
  }

  /**
   * VariantImage findMany
   */
  export type VariantImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter, which VariantImages to fetch.
     */
    where?: VariantImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VariantImages to fetch.
     */
    orderBy?: VariantImageOrderByWithRelationInput | VariantImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VariantImages.
     */
    cursor?: VariantImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VariantImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VariantImages.
     */
    skip?: number
    distinct?: VariantImageScalarFieldEnum | VariantImageScalarFieldEnum[]
  }

  /**
   * VariantImage create
   */
  export type VariantImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * The data needed to create a VariantImage.
     */
    data: XOR<VariantImageCreateInput, VariantImageUncheckedCreateInput>
  }

  /**
   * VariantImage createMany
   */
  export type VariantImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VariantImages.
     */
    data: VariantImageCreateManyInput | VariantImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VariantImage createManyAndReturn
   */
  export type VariantImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * The data used to create many VariantImages.
     */
    data: VariantImageCreateManyInput | VariantImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariantImage update
   */
  export type VariantImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * The data needed to update a VariantImage.
     */
    data: XOR<VariantImageUpdateInput, VariantImageUncheckedUpdateInput>
    /**
     * Choose, which VariantImage to update.
     */
    where: VariantImageWhereUniqueInput
  }

  /**
   * VariantImage updateMany
   */
  export type VariantImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VariantImages.
     */
    data: XOR<VariantImageUpdateManyMutationInput, VariantImageUncheckedUpdateManyInput>
    /**
     * Filter which VariantImages to update
     */
    where?: VariantImageWhereInput
    /**
     * Limit how many VariantImages to update.
     */
    limit?: number
  }

  /**
   * VariantImage updateManyAndReturn
   */
  export type VariantImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * The data used to update VariantImages.
     */
    data: XOR<VariantImageUpdateManyMutationInput, VariantImageUncheckedUpdateManyInput>
    /**
     * Filter which VariantImages to update
     */
    where?: VariantImageWhereInput
    /**
     * Limit how many VariantImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VariantImage upsert
   */
  export type VariantImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * The filter to search for the VariantImage to update in case it exists.
     */
    where: VariantImageWhereUniqueInput
    /**
     * In case the VariantImage found by the `where` argument doesn't exist, create a new VariantImage with this data.
     */
    create: XOR<VariantImageCreateInput, VariantImageUncheckedCreateInput>
    /**
     * In case the VariantImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VariantImageUpdateInput, VariantImageUncheckedUpdateInput>
  }

  /**
   * VariantImage delete
   */
  export type VariantImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
    /**
     * Filter which VariantImage to delete.
     */
    where: VariantImageWhereUniqueInput
  }

  /**
   * VariantImage deleteMany
   */
  export type VariantImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VariantImages to delete
     */
    where?: VariantImageWhereInput
    /**
     * Limit how many VariantImages to delete.
     */
    limit?: number
  }

  /**
   * VariantImage without action
   */
  export type VariantImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantImage
     */
    select?: VariantImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VariantImage
     */
    omit?: VariantImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VariantImageInclude<ExtArgs> | null
  }


  /**
   * Model Tag
   */

  export type AggregateTag = {
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  export type TagMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TagCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TagMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TagCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tag to aggregate.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tags
    **/
    _count?: true | TagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TagMaxAggregateInputType
  }

  export type GetTagAggregateType<T extends TagAggregateArgs> = {
        [P in keyof T & keyof AggregateTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTag[P]>
      : GetScalarType<T[P], AggregateTag[P]>
  }




  export type TagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TagWhereInput
    orderBy?: TagOrderByWithAggregationInput | TagOrderByWithAggregationInput[]
    by: TagScalarFieldEnum[] | TagScalarFieldEnum
    having?: TagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TagCountAggregateInputType | true
    _min?: TagMinAggregateInputType
    _max?: TagMaxAggregateInputType
  }

  export type TagGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: TagCountAggregateOutputType | null
    _min: TagMinAggregateOutputType | null
    _max: TagMaxAggregateOutputType | null
  }

  type GetTagGroupByPayload<T extends TagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TagGroupByOutputType[P]>
            : GetScalarType<T[P], TagGroupByOutputType[P]>
        }
      >
    >


  export type TagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    products?: boolean | Tag$productsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tag"]>

  export type TagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["tag"]>

  export type TagSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["tag"]>
  export type TagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    products?: boolean | Tag$productsArgs<ExtArgs>
    _count?: boolean | TagCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tag"
    objects: {
      products: Prisma.$ProductTagPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tag"]>
    composites: {}
  }

  type TagGetPayload<S extends boolean | null | undefined | TagDefaultArgs> = $Result.GetResult<Prisma.$TagPayload, S>

  type TagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TagCountAggregateInputType | true
    }

  export interface TagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tag'], meta: { name: 'Tag' } }
    /**
     * Find zero or one Tag that matches the filter.
     * @param {TagFindUniqueArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TagFindUniqueArgs>(args: SelectSubset<T, TagFindUniqueArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TagFindUniqueOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TagFindUniqueOrThrowArgs>(args: SelectSubset<T, TagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TagFindFirstArgs>(args?: SelectSubset<T, TagFindFirstArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindFirstOrThrowArgs} args - Arguments to find a Tag
     * @example
     * // Get one Tag
     * const tag = await prisma.tag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TagFindFirstOrThrowArgs>(args?: SelectSubset<T, TagFindFirstOrThrowArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tags
     * const tags = await prisma.tag.findMany()
     * 
     * // Get first 10 Tags
     * const tags = await prisma.tag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tagWithIdOnly = await prisma.tag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TagFindManyArgs>(args?: SelectSubset<T, TagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tag.
     * @param {TagCreateArgs} args - Arguments to create a Tag.
     * @example
     * // Create one Tag
     * const Tag = await prisma.tag.create({
     *   data: {
     *     // ... data to create a Tag
     *   }
     * })
     * 
     */
    create<T extends TagCreateArgs>(args: SelectSubset<T, TagCreateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tags.
     * @param {TagCreateManyArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TagCreateManyArgs>(args?: SelectSubset<T, TagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Tags and returns the data saved in the database.
     * @param {TagCreateManyAndReturnArgs} args - Arguments to create many Tags.
     * @example
     * // Create many Tags
     * const tag = await prisma.tag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TagCreateManyAndReturnArgs>(args?: SelectSubset<T, TagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Tag.
     * @param {TagDeleteArgs} args - Arguments to delete one Tag.
     * @example
     * // Delete one Tag
     * const Tag = await prisma.tag.delete({
     *   where: {
     *     // ... filter to delete one Tag
     *   }
     * })
     * 
     */
    delete<T extends TagDeleteArgs>(args: SelectSubset<T, TagDeleteArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tag.
     * @param {TagUpdateArgs} args - Arguments to update one Tag.
     * @example
     * // Update one Tag
     * const tag = await prisma.tag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TagUpdateArgs>(args: SelectSubset<T, TagUpdateArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tags.
     * @param {TagDeleteManyArgs} args - Arguments to filter Tags to delete.
     * @example
     * // Delete a few Tags
     * const { count } = await prisma.tag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TagDeleteManyArgs>(args?: SelectSubset<T, TagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TagUpdateManyArgs>(args: SelectSubset<T, TagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tags and returns the data updated in the database.
     * @param {TagUpdateManyAndReturnArgs} args - Arguments to update many Tags.
     * @example
     * // Update many Tags
     * const tag = await prisma.tag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Tags and only return the `id`
     * const tagWithIdOnly = await prisma.tag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TagUpdateManyAndReturnArgs>(args: SelectSubset<T, TagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Tag.
     * @param {TagUpsertArgs} args - Arguments to update or create a Tag.
     * @example
     * // Update or create a Tag
     * const tag = await prisma.tag.upsert({
     *   create: {
     *     // ... data to create a Tag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tag we want to update
     *   }
     * })
     */
    upsert<T extends TagUpsertArgs>(args: SelectSubset<T, TagUpsertArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Tags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagCountArgs} args - Arguments to filter Tags to count.
     * @example
     * // Count the number of Tags
     * const count = await prisma.tag.count({
     *   where: {
     *     // ... the filter for the Tags we want to count
     *   }
     * })
    **/
    count<T extends TagCountArgs>(
      args?: Subset<T, TagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TagAggregateArgs>(args: Subset<T, TagAggregateArgs>): Prisma.PrismaPromise<GetTagAggregateType<T>>

    /**
     * Group by Tag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TagGroupByArgs['orderBy'] }
        : { orderBy?: TagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tag model
   */
  readonly fields: TagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    products<T extends Tag$productsArgs<ExtArgs> = {}>(args?: Subset<T, Tag$productsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tag model
   */
  interface TagFieldRefs {
    readonly id: FieldRef<"Tag", 'String'>
    readonly name: FieldRef<"Tag", 'String'>
    readonly slug: FieldRef<"Tag", 'String'>
    readonly createdAt: FieldRef<"Tag", 'DateTime'>
    readonly updatedAt: FieldRef<"Tag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tag findUnique
   */
  export type TagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findUniqueOrThrow
   */
  export type TagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag findFirst
   */
  export type TagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findFirstOrThrow
   */
  export type TagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tag to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tags.
     */
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag findMany
   */
  export type TagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter, which Tags to fetch.
     */
    where?: TagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tags to fetch.
     */
    orderBy?: TagOrderByWithRelationInput | TagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tags.
     */
    cursor?: TagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tags.
     */
    skip?: number
    distinct?: TagScalarFieldEnum | TagScalarFieldEnum[]
  }

  /**
   * Tag create
   */
  export type TagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to create a Tag.
     */
    data: XOR<TagCreateInput, TagUncheckedCreateInput>
  }

  /**
   * Tag createMany
   */
  export type TagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag createManyAndReturn
   */
  export type TagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to create many Tags.
     */
    data: TagCreateManyInput | TagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Tag update
   */
  export type TagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The data needed to update a Tag.
     */
    data: XOR<TagUpdateInput, TagUncheckedUpdateInput>
    /**
     * Choose, which Tag to update.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag updateMany
   */
  export type TagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag updateManyAndReturn
   */
  export type TagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * The data used to update Tags.
     */
    data: XOR<TagUpdateManyMutationInput, TagUncheckedUpdateManyInput>
    /**
     * Filter which Tags to update
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to update.
     */
    limit?: number
  }

  /**
   * Tag upsert
   */
  export type TagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * The filter to search for the Tag to update in case it exists.
     */
    where: TagWhereUniqueInput
    /**
     * In case the Tag found by the `where` argument doesn't exist, create a new Tag with this data.
     */
    create: XOR<TagCreateInput, TagUncheckedCreateInput>
    /**
     * In case the Tag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TagUpdateInput, TagUncheckedUpdateInput>
  }

  /**
   * Tag delete
   */
  export type TagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
    /**
     * Filter which Tag to delete.
     */
    where: TagWhereUniqueInput
  }

  /**
   * Tag deleteMany
   */
  export type TagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tags to delete
     */
    where?: TagWhereInput
    /**
     * Limit how many Tags to delete.
     */
    limit?: number
  }

  /**
   * Tag.products
   */
  export type Tag$productsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    cursor?: ProductTagWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }

  /**
   * Tag without action
   */
  export type TagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tag
     */
    select?: TagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tag
     */
    omit?: TagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TagInclude<ExtArgs> | null
  }


  /**
   * Model ProductTag
   */

  export type AggregateProductTag = {
    _count: ProductTagCountAggregateOutputType | null
    _min: ProductTagMinAggregateOutputType | null
    _max: ProductTagMaxAggregateOutputType | null
  }

  export type ProductTagMinAggregateOutputType = {
    productId: string | null
    tagId: string | null
    pinned: boolean | null
    addedAt: Date | null
  }

  export type ProductTagMaxAggregateOutputType = {
    productId: string | null
    tagId: string | null
    pinned: boolean | null
    addedAt: Date | null
  }

  export type ProductTagCountAggregateOutputType = {
    productId: number
    tagId: number
    pinned: number
    addedAt: number
    _all: number
  }


  export type ProductTagMinAggregateInputType = {
    productId?: true
    tagId?: true
    pinned?: true
    addedAt?: true
  }

  export type ProductTagMaxAggregateInputType = {
    productId?: true
    tagId?: true
    pinned?: true
    addedAt?: true
  }

  export type ProductTagCountAggregateInputType = {
    productId?: true
    tagId?: true
    pinned?: true
    addedAt?: true
    _all?: true
  }

  export type ProductTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTag to aggregate.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductTags
    **/
    _count?: true | ProductTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductTagMaxAggregateInputType
  }

  export type GetProductTagAggregateType<T extends ProductTagAggregateArgs> = {
        [P in keyof T & keyof AggregateProductTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductTag[P]>
      : GetScalarType<T[P], AggregateProductTag[P]>
  }




  export type ProductTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductTagWhereInput
    orderBy?: ProductTagOrderByWithAggregationInput | ProductTagOrderByWithAggregationInput[]
    by: ProductTagScalarFieldEnum[] | ProductTagScalarFieldEnum
    having?: ProductTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductTagCountAggregateInputType | true
    _min?: ProductTagMinAggregateInputType
    _max?: ProductTagMaxAggregateInputType
  }

  export type ProductTagGroupByOutputType = {
    productId: string
    tagId: string
    pinned: boolean
    addedAt: Date
    _count: ProductTagCountAggregateOutputType | null
    _min: ProductTagMinAggregateOutputType | null
    _max: ProductTagMaxAggregateOutputType | null
  }

  type GetProductTagGroupByPayload<T extends ProductTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductTagGroupByOutputType[P]>
            : GetScalarType<T[P], ProductTagGroupByOutputType[P]>
        }
      >
    >


  export type ProductTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    tagId?: boolean
    pinned?: boolean
    addedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTag"]>

  export type ProductTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    tagId?: boolean
    pinned?: boolean
    addedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTag"]>

  export type ProductTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    productId?: boolean
    tagId?: boolean
    pinned?: boolean
    addedAt?: boolean
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productTag"]>

  export type ProductTagSelectScalar = {
    productId?: boolean
    tagId?: boolean
    pinned?: boolean
    addedAt?: boolean
  }

  export type ProductTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"productId" | "tagId" | "pinned" | "addedAt", ExtArgs["result"]["productTag"]>
  export type ProductTagInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ProductTagIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }
  export type ProductTagIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    product?: boolean | ProductDefaultArgs<ExtArgs>
    tag?: boolean | TagDefaultArgs<ExtArgs>
  }

  export type $ProductTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductTag"
    objects: {
      product: Prisma.$ProductPayload<ExtArgs>
      tag: Prisma.$TagPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      productId: string
      tagId: string
      pinned: boolean
      addedAt: Date
    }, ExtArgs["result"]["productTag"]>
    composites: {}
  }

  type ProductTagGetPayload<S extends boolean | null | undefined | ProductTagDefaultArgs> = $Result.GetResult<Prisma.$ProductTagPayload, S>

  type ProductTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductTagCountAggregateInputType | true
    }

  export interface ProductTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductTag'], meta: { name: 'ProductTag' } }
    /**
     * Find zero or one ProductTag that matches the filter.
     * @param {ProductTagFindUniqueArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductTagFindUniqueArgs>(args: SelectSubset<T, ProductTagFindUniqueArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductTagFindUniqueOrThrowArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductTagFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindFirstArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductTagFindFirstArgs>(args?: SelectSubset<T, ProductTagFindFirstArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindFirstOrThrowArgs} args - Arguments to find a ProductTag
     * @example
     * // Get one ProductTag
     * const productTag = await prisma.productTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductTagFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductTags
     * const productTags = await prisma.productTag.findMany()
     * 
     * // Get first 10 ProductTags
     * const productTags = await prisma.productTag.findMany({ take: 10 })
     * 
     * // Only select the `productId`
     * const productTagWithProductIdOnly = await prisma.productTag.findMany({ select: { productId: true } })
     * 
     */
    findMany<T extends ProductTagFindManyArgs>(args?: SelectSubset<T, ProductTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProductTag.
     * @param {ProductTagCreateArgs} args - Arguments to create a ProductTag.
     * @example
     * // Create one ProductTag
     * const ProductTag = await prisma.productTag.create({
     *   data: {
     *     // ... data to create a ProductTag
     *   }
     * })
     * 
     */
    create<T extends ProductTagCreateArgs>(args: SelectSubset<T, ProductTagCreateArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProductTags.
     * @param {ProductTagCreateManyArgs} args - Arguments to create many ProductTags.
     * @example
     * // Create many ProductTags
     * const productTag = await prisma.productTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProductTagCreateManyArgs>(args?: SelectSubset<T, ProductTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProductTags and returns the data saved in the database.
     * @param {ProductTagCreateManyAndReturnArgs} args - Arguments to create many ProductTags.
     * @example
     * // Create many ProductTags
     * const productTag = await prisma.productTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProductTags and only return the `productId`
     * const productTagWithProductIdOnly = await prisma.productTag.createManyAndReturn({
     *   select: { productId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProductTagCreateManyAndReturnArgs>(args?: SelectSubset<T, ProductTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProductTag.
     * @param {ProductTagDeleteArgs} args - Arguments to delete one ProductTag.
     * @example
     * // Delete one ProductTag
     * const ProductTag = await prisma.productTag.delete({
     *   where: {
     *     // ... filter to delete one ProductTag
     *   }
     * })
     * 
     */
    delete<T extends ProductTagDeleteArgs>(args: SelectSubset<T, ProductTagDeleteArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductTag.
     * @param {ProductTagUpdateArgs} args - Arguments to update one ProductTag.
     * @example
     * // Update one ProductTag
     * const productTag = await prisma.productTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductTagUpdateArgs>(args: SelectSubset<T, ProductTagUpdateArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductTags.
     * @param {ProductTagDeleteManyArgs} args - Arguments to filter ProductTags to delete.
     * @example
     * // Delete a few ProductTags
     * const { count } = await prisma.productTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductTagDeleteManyArgs>(args?: SelectSubset<T, ProductTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductTags
     * const productTag = await prisma.productTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductTagUpdateManyArgs>(args: SelectSubset<T, ProductTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductTags and returns the data updated in the database.
     * @param {ProductTagUpdateManyAndReturnArgs} args - Arguments to update many ProductTags.
     * @example
     * // Update many ProductTags
     * const productTag = await prisma.productTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductTags and only return the `productId`
     * const productTagWithProductIdOnly = await prisma.productTag.updateManyAndReturn({
     *   select: { productId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductTagUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProductTag.
     * @param {ProductTagUpsertArgs} args - Arguments to update or create a ProductTag.
     * @example
     * // Update or create a ProductTag
     * const productTag = await prisma.productTag.upsert({
     *   create: {
     *     // ... data to create a ProductTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProductTag we want to update
     *   }
     * })
     */
    upsert<T extends ProductTagUpsertArgs>(args: SelectSubset<T, ProductTagUpsertArgs<ExtArgs>>): Prisma__ProductTagClient<$Result.GetResult<Prisma.$ProductTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProductTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagCountArgs} args - Arguments to filter ProductTags to count.
     * @example
     * // Count the number of ProductTags
     * const count = await prisma.productTag.count({
     *   where: {
     *     // ... the filter for the ProductTags we want to count
     *   }
     * })
    **/
    count<T extends ProductTagCountArgs>(
      args?: Subset<T, ProductTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductTagAggregateArgs>(args: Subset<T, ProductTagAggregateArgs>): Prisma.PrismaPromise<GetProductTagAggregateType<T>>

    /**
     * Group by ProductTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductTagGroupByArgs['orderBy'] }
        : { orderBy?: ProductTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductTag model
   */
  readonly fields: ProductTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    tag<T extends TagDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TagDefaultArgs<ExtArgs>>): Prisma__TagClient<$Result.GetResult<Prisma.$TagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductTag model
   */
  interface ProductTagFieldRefs {
    readonly productId: FieldRef<"ProductTag", 'String'>
    readonly tagId: FieldRef<"ProductTag", 'String'>
    readonly pinned: FieldRef<"ProductTag", 'Boolean'>
    readonly addedAt: FieldRef<"ProductTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductTag findUnique
   */
  export type ProductTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where: ProductTagWhereUniqueInput
  }

  /**
   * ProductTag findUniqueOrThrow
   */
  export type ProductTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where: ProductTagWhereUniqueInput
  }

  /**
   * ProductTag findFirst
   */
  export type ProductTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTags.
     */
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }

  /**
   * ProductTag findFirstOrThrow
   */
  export type ProductTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTag to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductTags.
     */
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }

  /**
   * ProductTag findMany
   */
  export type ProductTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter, which ProductTags to fetch.
     */
    where?: ProductTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductTags to fetch.
     */
    orderBy?: ProductTagOrderByWithRelationInput | ProductTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductTags.
     */
    cursor?: ProductTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductTags.
     */
    skip?: number
    distinct?: ProductTagScalarFieldEnum | ProductTagScalarFieldEnum[]
  }

  /**
   * ProductTag create
   */
  export type ProductTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The data needed to create a ProductTag.
     */
    data: XOR<ProductTagCreateInput, ProductTagUncheckedCreateInput>
  }

  /**
   * ProductTag createMany
   */
  export type ProductTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProductTags.
     */
    data: ProductTagCreateManyInput | ProductTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProductTag createManyAndReturn
   */
  export type ProductTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * The data used to create many ProductTags.
     */
    data: ProductTagCreateManyInput | ProductTagCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTag update
   */
  export type ProductTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductTag.
     */
    data: XOR<ProductTagUpdateInput, ProductTagUncheckedUpdateInput>
    /**
     * Choose, which ProductTag to update.
     */
    where: ProductTagWhereUniqueInput
  }

  /**
   * ProductTag updateMany
   */
  export type ProductTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductTags.
     */
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyInput>
    /**
     * Filter which ProductTags to update
     */
    where?: ProductTagWhereInput
    /**
     * Limit how many ProductTags to update.
     */
    limit?: number
  }

  /**
   * ProductTag updateManyAndReturn
   */
  export type ProductTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * The data used to update ProductTags.
     */
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyInput>
    /**
     * Filter which ProductTags to update
     */
    where?: ProductTagWhereInput
    /**
     * Limit how many ProductTags to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductTag upsert
   */
  export type ProductTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * The filter to search for the ProductTag to update in case it exists.
     */
    where: ProductTagWhereUniqueInput
    /**
     * In case the ProductTag found by the `where` argument doesn't exist, create a new ProductTag with this data.
     */
    create: XOR<ProductTagCreateInput, ProductTagUncheckedCreateInput>
    /**
     * In case the ProductTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProductTagUpdateInput, ProductTagUncheckedUpdateInput>
  }

  /**
   * ProductTag delete
   */
  export type ProductTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
    /**
     * Filter which ProductTag to delete.
     */
    where: ProductTagWhereUniqueInput
  }

  /**
   * ProductTag deleteMany
   */
  export type ProductTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductTags to delete
     */
    where?: ProductTagWhereInput
    /**
     * Limit how many ProductTags to delete.
     */
    limit?: number
  }

  /**
   * ProductTag without action
   */
  export type ProductTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductTag
     */
    select?: ProductTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductTag
     */
    omit?: ProductTagOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductTagInclude<ExtArgs> | null
  }


  /**
   * Model ProductImageEmbedding
   */

  export type AggregateProductImageEmbedding = {
    _count: ProductImageEmbeddingCountAggregateOutputType | null
    _avg: ProductImageEmbeddingAvgAggregateOutputType | null
    _sum: ProductImageEmbeddingSumAggregateOutputType | null
    _min: ProductImageEmbeddingMinAggregateOutputType | null
    _max: ProductImageEmbeddingMaxAggregateOutputType | null
  }

  export type ProductImageEmbeddingAvgAggregateOutputType = {
    dim: number | null
  }

  export type ProductImageEmbeddingSumAggregateOutputType = {
    dim: number | null
  }

  export type ProductImageEmbeddingMinAggregateOutputType = {
    id: string | null
    productImageId: string | null
    productId: string | null
    model: string | null
    dim: number | null
    updatedAt: Date | null
  }

  export type ProductImageEmbeddingMaxAggregateOutputType = {
    id: string | null
    productImageId: string | null
    productId: string | null
    model: string | null
    dim: number | null
    updatedAt: Date | null
  }

  export type ProductImageEmbeddingCountAggregateOutputType = {
    id: number
    productImageId: number
    productId: number
    model: number
    dim: number
    updatedAt: number
    _all: number
  }


  export type ProductImageEmbeddingAvgAggregateInputType = {
    dim?: true
  }

  export type ProductImageEmbeddingSumAggregateInputType = {
    dim?: true
  }

  export type ProductImageEmbeddingMinAggregateInputType = {
    id?: true
    productImageId?: true
    productId?: true
    model?: true
    dim?: true
    updatedAt?: true
  }

  export type ProductImageEmbeddingMaxAggregateInputType = {
    id?: true
    productImageId?: true
    productId?: true
    model?: true
    dim?: true
    updatedAt?: true
  }

  export type ProductImageEmbeddingCountAggregateInputType = {
    id?: true
    productImageId?: true
    productId?: true
    model?: true
    dim?: true
    updatedAt?: true
    _all?: true
  }

  export type ProductImageEmbeddingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImageEmbedding to aggregate.
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImageEmbeddings to fetch.
     */
    orderBy?: ProductImageEmbeddingOrderByWithRelationInput | ProductImageEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProductImageEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImageEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImageEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProductImageEmbeddings
    **/
    _count?: true | ProductImageEmbeddingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductImageEmbeddingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductImageEmbeddingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductImageEmbeddingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductImageEmbeddingMaxAggregateInputType
  }

  export type GetProductImageEmbeddingAggregateType<T extends ProductImageEmbeddingAggregateArgs> = {
        [P in keyof T & keyof AggregateProductImageEmbedding]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProductImageEmbedding[P]>
      : GetScalarType<T[P], AggregateProductImageEmbedding[P]>
  }




  export type ProductImageEmbeddingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProductImageEmbeddingWhereInput
    orderBy?: ProductImageEmbeddingOrderByWithAggregationInput | ProductImageEmbeddingOrderByWithAggregationInput[]
    by: ProductImageEmbeddingScalarFieldEnum[] | ProductImageEmbeddingScalarFieldEnum
    having?: ProductImageEmbeddingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductImageEmbeddingCountAggregateInputType | true
    _avg?: ProductImageEmbeddingAvgAggregateInputType
    _sum?: ProductImageEmbeddingSumAggregateInputType
    _min?: ProductImageEmbeddingMinAggregateInputType
    _max?: ProductImageEmbeddingMaxAggregateInputType
  }

  export type ProductImageEmbeddingGroupByOutputType = {
    id: string
    productImageId: string
    productId: string
    model: string
    dim: number
    updatedAt: Date
    _count: ProductImageEmbeddingCountAggregateOutputType | null
    _avg: ProductImageEmbeddingAvgAggregateOutputType | null
    _sum: ProductImageEmbeddingSumAggregateOutputType | null
    _min: ProductImageEmbeddingMinAggregateOutputType | null
    _max: ProductImageEmbeddingMaxAggregateOutputType | null
  }

  type GetProductImageEmbeddingGroupByPayload<T extends ProductImageEmbeddingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProductImageEmbeddingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductImageEmbeddingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductImageEmbeddingGroupByOutputType[P]>
            : GetScalarType<T[P], ProductImageEmbeddingGroupByOutputType[P]>
        }
      >
    >


  export type ProductImageEmbeddingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productImageId?: boolean
    productId?: boolean
    model?: boolean
    dim?: boolean
    updatedAt?: boolean
    image?: boolean | ProductImageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImageEmbedding"]>


  export type ProductImageEmbeddingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productImageId?: boolean
    productId?: boolean
    model?: boolean
    dim?: boolean
    updatedAt?: boolean
    image?: boolean | ProductImageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["productImageEmbedding"]>

  export type ProductImageEmbeddingSelectScalar = {
    id?: boolean
    productImageId?: boolean
    productId?: boolean
    model?: boolean
    dim?: boolean
    updatedAt?: boolean
  }

  export type ProductImageEmbeddingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productImageId" | "productId" | "model" | "dim" | "updatedAt", ExtArgs["result"]["productImageEmbedding"]>
  export type ProductImageEmbeddingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ProductImageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ProductImageEmbeddingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    image?: boolean | ProductImageDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ProductImageEmbeddingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProductImageEmbedding"
    objects: {
      image: Prisma.$ProductImagePayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productImageId: string
      productId: string
      model: string
      dim: number
      updatedAt: Date
    }, ExtArgs["result"]["productImageEmbedding"]>
    composites: {}
  }

  type ProductImageEmbeddingGetPayload<S extends boolean | null | undefined | ProductImageEmbeddingDefaultArgs> = $Result.GetResult<Prisma.$ProductImageEmbeddingPayload, S>

  type ProductImageEmbeddingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProductImageEmbeddingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProductImageEmbeddingCountAggregateInputType | true
    }

  export interface ProductImageEmbeddingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProductImageEmbedding'], meta: { name: 'ProductImageEmbedding' } }
    /**
     * Find zero or one ProductImageEmbedding that matches the filter.
     * @param {ProductImageEmbeddingFindUniqueArgs} args - Arguments to find a ProductImageEmbedding
     * @example
     * // Get one ProductImageEmbedding
     * const productImageEmbedding = await prisma.productImageEmbedding.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProductImageEmbeddingFindUniqueArgs>(args: SelectSubset<T, ProductImageEmbeddingFindUniqueArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProductImageEmbedding that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProductImageEmbeddingFindUniqueOrThrowArgs} args - Arguments to find a ProductImageEmbedding
     * @example
     * // Get one ProductImageEmbedding
     * const productImageEmbedding = await prisma.productImageEmbedding.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProductImageEmbeddingFindUniqueOrThrowArgs>(args: SelectSubset<T, ProductImageEmbeddingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImageEmbedding that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingFindFirstArgs} args - Arguments to find a ProductImageEmbedding
     * @example
     * // Get one ProductImageEmbedding
     * const productImageEmbedding = await prisma.productImageEmbedding.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProductImageEmbeddingFindFirstArgs>(args?: SelectSubset<T, ProductImageEmbeddingFindFirstArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProductImageEmbedding that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingFindFirstOrThrowArgs} args - Arguments to find a ProductImageEmbedding
     * @example
     * // Get one ProductImageEmbedding
     * const productImageEmbedding = await prisma.productImageEmbedding.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProductImageEmbeddingFindFirstOrThrowArgs>(args?: SelectSubset<T, ProductImageEmbeddingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProductImageEmbeddings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProductImageEmbeddings
     * const productImageEmbeddings = await prisma.productImageEmbedding.findMany()
     * 
     * // Get first 10 ProductImageEmbeddings
     * const productImageEmbeddings = await prisma.productImageEmbedding.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productImageEmbeddingWithIdOnly = await prisma.productImageEmbedding.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProductImageEmbeddingFindManyArgs>(args?: SelectSubset<T, ProductImageEmbeddingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Delete a ProductImageEmbedding.
     * @param {ProductImageEmbeddingDeleteArgs} args - Arguments to delete one ProductImageEmbedding.
     * @example
     * // Delete one ProductImageEmbedding
     * const ProductImageEmbedding = await prisma.productImageEmbedding.delete({
     *   where: {
     *     // ... filter to delete one ProductImageEmbedding
     *   }
     * })
     * 
     */
    delete<T extends ProductImageEmbeddingDeleteArgs>(args: SelectSubset<T, ProductImageEmbeddingDeleteArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProductImageEmbedding.
     * @param {ProductImageEmbeddingUpdateArgs} args - Arguments to update one ProductImageEmbedding.
     * @example
     * // Update one ProductImageEmbedding
     * const productImageEmbedding = await prisma.productImageEmbedding.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProductImageEmbeddingUpdateArgs>(args: SelectSubset<T, ProductImageEmbeddingUpdateArgs<ExtArgs>>): Prisma__ProductImageEmbeddingClient<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProductImageEmbeddings.
     * @param {ProductImageEmbeddingDeleteManyArgs} args - Arguments to filter ProductImageEmbeddings to delete.
     * @example
     * // Delete a few ProductImageEmbeddings
     * const { count } = await prisma.productImageEmbedding.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProductImageEmbeddingDeleteManyArgs>(args?: SelectSubset<T, ProductImageEmbeddingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImageEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProductImageEmbeddings
     * const productImageEmbedding = await prisma.productImageEmbedding.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProductImageEmbeddingUpdateManyArgs>(args: SelectSubset<T, ProductImageEmbeddingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProductImageEmbeddings and returns the data updated in the database.
     * @param {ProductImageEmbeddingUpdateManyAndReturnArgs} args - Arguments to update many ProductImageEmbeddings.
     * @example
     * // Update many ProductImageEmbeddings
     * const productImageEmbedding = await prisma.productImageEmbedding.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProductImageEmbeddings and only return the `id`
     * const productImageEmbeddingWithIdOnly = await prisma.productImageEmbedding.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProductImageEmbeddingUpdateManyAndReturnArgs>(args: SelectSubset<T, ProductImageEmbeddingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProductImageEmbeddingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>


    /**
     * Count the number of ProductImageEmbeddings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingCountArgs} args - Arguments to filter ProductImageEmbeddings to count.
     * @example
     * // Count the number of ProductImageEmbeddings
     * const count = await prisma.productImageEmbedding.count({
     *   where: {
     *     // ... the filter for the ProductImageEmbeddings we want to count
     *   }
     * })
    **/
    count<T extends ProductImageEmbeddingCountArgs>(
      args?: Subset<T, ProductImageEmbeddingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductImageEmbeddingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProductImageEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductImageEmbeddingAggregateArgs>(args: Subset<T, ProductImageEmbeddingAggregateArgs>): Prisma.PrismaPromise<GetProductImageEmbeddingAggregateType<T>>

    /**
     * Group by ProductImageEmbedding.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductImageEmbeddingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductImageEmbeddingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductImageEmbeddingGroupByArgs['orderBy'] }
        : { orderBy?: ProductImageEmbeddingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductImageEmbeddingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductImageEmbeddingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProductImageEmbedding model
   */
  readonly fields: ProductImageEmbeddingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProductImageEmbedding.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProductImageEmbeddingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    image<T extends ProductImageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductImageDefaultArgs<ExtArgs>>): Prisma__ProductImageClient<$Result.GetResult<Prisma.$ProductImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProductImageEmbedding model
   */
  interface ProductImageEmbeddingFieldRefs {
    readonly id: FieldRef<"ProductImageEmbedding", 'String'>
    readonly productImageId: FieldRef<"ProductImageEmbedding", 'String'>
    readonly productId: FieldRef<"ProductImageEmbedding", 'String'>
    readonly model: FieldRef<"ProductImageEmbedding", 'String'>
    readonly dim: FieldRef<"ProductImageEmbedding", 'Int'>
    readonly updatedAt: FieldRef<"ProductImageEmbedding", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProductImageEmbedding findUnique
   */
  export type ProductImageEmbeddingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which ProductImageEmbedding to fetch.
     */
    where: ProductImageEmbeddingWhereUniqueInput
  }

  /**
   * ProductImageEmbedding findUniqueOrThrow
   */
  export type ProductImageEmbeddingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which ProductImageEmbedding to fetch.
     */
    where: ProductImageEmbeddingWhereUniqueInput
  }

  /**
   * ProductImageEmbedding findFirst
   */
  export type ProductImageEmbeddingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which ProductImageEmbedding to fetch.
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImageEmbeddings to fetch.
     */
    orderBy?: ProductImageEmbeddingOrderByWithRelationInput | ProductImageEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImageEmbeddings.
     */
    cursor?: ProductImageEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImageEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImageEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImageEmbeddings.
     */
    distinct?: ProductImageEmbeddingScalarFieldEnum | ProductImageEmbeddingScalarFieldEnum[]
  }

  /**
   * ProductImageEmbedding findFirstOrThrow
   */
  export type ProductImageEmbeddingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which ProductImageEmbedding to fetch.
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImageEmbeddings to fetch.
     */
    orderBy?: ProductImageEmbeddingOrderByWithRelationInput | ProductImageEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProductImageEmbeddings.
     */
    cursor?: ProductImageEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImageEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImageEmbeddings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProductImageEmbeddings.
     */
    distinct?: ProductImageEmbeddingScalarFieldEnum | ProductImageEmbeddingScalarFieldEnum[]
  }

  /**
   * ProductImageEmbedding findMany
   */
  export type ProductImageEmbeddingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter, which ProductImageEmbeddings to fetch.
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProductImageEmbeddings to fetch.
     */
    orderBy?: ProductImageEmbeddingOrderByWithRelationInput | ProductImageEmbeddingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProductImageEmbeddings.
     */
    cursor?: ProductImageEmbeddingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProductImageEmbeddings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProductImageEmbeddings.
     */
    skip?: number
    distinct?: ProductImageEmbeddingScalarFieldEnum | ProductImageEmbeddingScalarFieldEnum[]
  }

  /**
   * ProductImageEmbedding update
   */
  export type ProductImageEmbeddingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * The data needed to update a ProductImageEmbedding.
     */
    data: XOR<ProductImageEmbeddingUpdateInput, ProductImageEmbeddingUncheckedUpdateInput>
    /**
     * Choose, which ProductImageEmbedding to update.
     */
    where: ProductImageEmbeddingWhereUniqueInput
  }

  /**
   * ProductImageEmbedding updateMany
   */
  export type ProductImageEmbeddingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProductImageEmbeddings.
     */
    data: XOR<ProductImageEmbeddingUpdateManyMutationInput, ProductImageEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which ProductImageEmbeddings to update
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * Limit how many ProductImageEmbeddings to update.
     */
    limit?: number
  }

  /**
   * ProductImageEmbedding updateManyAndReturn
   */
  export type ProductImageEmbeddingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * The data used to update ProductImageEmbeddings.
     */
    data: XOR<ProductImageEmbeddingUpdateManyMutationInput, ProductImageEmbeddingUncheckedUpdateManyInput>
    /**
     * Filter which ProductImageEmbeddings to update
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * Limit how many ProductImageEmbeddings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProductImageEmbedding delete
   */
  export type ProductImageEmbeddingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
    /**
     * Filter which ProductImageEmbedding to delete.
     */
    where: ProductImageEmbeddingWhereUniqueInput
  }

  /**
   * ProductImageEmbedding deleteMany
   */
  export type ProductImageEmbeddingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProductImageEmbeddings to delete
     */
    where?: ProductImageEmbeddingWhereInput
    /**
     * Limit how many ProductImageEmbeddings to delete.
     */
    limit?: number
  }

  /**
   * ProductImageEmbedding without action
   */
  export type ProductImageEmbeddingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProductImageEmbedding
     */
    select?: ProductImageEmbeddingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProductImageEmbedding
     */
    omit?: ProductImageEmbeddingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProductImageEmbeddingInclude<ExtArgs> | null
  }


  /**
   * Model Review
   */

  export type AggregateReview = {
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  export type ReviewAvgAggregateOutputType = {
    rating: number | null
    helpfulCount: number | null
  }

  export type ReviewSumAggregateOutputType = {
    rating: number | null
    helpfulCount: number | null
  }

  export type ReviewMinAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    rating: number | null
    title: string | null
    content: string | null
    isVerified: boolean | null
    visibility: $Enums.ReviewVisibility | null
    reported: boolean | null
    helpfulCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewMaxAggregateOutputType = {
    id: string | null
    productId: string | null
    userId: string | null
    rating: number | null
    title: string | null
    content: string | null
    isVerified: boolean | null
    visibility: $Enums.ReviewVisibility | null
    reported: boolean | null
    helpfulCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewCountAggregateOutputType = {
    id: number
    productId: number
    userId: number
    rating: number
    title: number
    content: number
    isVerified: number
    visibility: number
    reported: number
    helpfulCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewAvgAggregateInputType = {
    rating?: true
    helpfulCount?: true
  }

  export type ReviewSumAggregateInputType = {
    rating?: true
    helpfulCount?: true
  }

  export type ReviewMinAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    rating?: true
    title?: true
    content?: true
    isVerified?: true
    visibility?: true
    reported?: true
    helpfulCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewMaxAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    rating?: true
    title?: true
    content?: true
    isVerified?: true
    visibility?: true
    reported?: true
    helpfulCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewCountAggregateInputType = {
    id?: true
    productId?: true
    userId?: true
    rating?: true
    title?: true
    content?: true
    isVerified?: true
    visibility?: true
    reported?: true
    helpfulCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Review to aggregate.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reviews
    **/
    _count?: true | ReviewCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewMaxAggregateInputType
  }

  export type GetReviewAggregateType<T extends ReviewAggregateArgs> = {
        [P in keyof T & keyof AggregateReview]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReview[P]>
      : GetScalarType<T[P], AggregateReview[P]>
  }




  export type ReviewGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewWhereInput
    orderBy?: ReviewOrderByWithAggregationInput | ReviewOrderByWithAggregationInput[]
    by: ReviewScalarFieldEnum[] | ReviewScalarFieldEnum
    having?: ReviewScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewCountAggregateInputType | true
    _avg?: ReviewAvgAggregateInputType
    _sum?: ReviewSumAggregateInputType
    _min?: ReviewMinAggregateInputType
    _max?: ReviewMaxAggregateInputType
  }

  export type ReviewGroupByOutputType = {
    id: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified: boolean
    visibility: $Enums.ReviewVisibility
    reported: boolean
    helpfulCount: number
    createdAt: Date
    updatedAt: Date
    _count: ReviewCountAggregateOutputType | null
    _avg: ReviewAvgAggregateOutputType | null
    _sum: ReviewSumAggregateOutputType | null
    _min: ReviewMinAggregateOutputType | null
    _max: ReviewMaxAggregateOutputType | null
  }

  type GetReviewGroupByPayload<T extends ReviewGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewGroupByOutputType[P]>
        }
      >
    >


  export type ReviewSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    content?: boolean
    isVerified?: boolean
    visibility?: boolean
    reported?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    images?: boolean | Review$imagesArgs<ExtArgs>
    votes?: boolean | Review$votesArgs<ExtArgs>
    reports?: boolean | Review$reportsArgs<ExtArgs>
    replies?: boolean | Review$repliesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    content?: boolean
    isVerified?: boolean
    visibility?: boolean
    reported?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    productId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    content?: boolean
    isVerified?: boolean
    visibility?: boolean
    reported?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["review"]>

  export type ReviewSelectScalar = {
    id?: boolean
    productId?: boolean
    userId?: boolean
    rating?: boolean
    title?: boolean
    content?: boolean
    isVerified?: boolean
    visibility?: boolean
    reported?: boolean
    helpfulCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "productId" | "userId" | "rating" | "title" | "content" | "isVerified" | "visibility" | "reported" | "helpfulCount" | "createdAt" | "updatedAt", ExtArgs["result"]["review"]>
  export type ReviewInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    images?: boolean | Review$imagesArgs<ExtArgs>
    votes?: boolean | Review$votesArgs<ExtArgs>
    reports?: boolean | Review$reportsArgs<ExtArgs>
    replies?: boolean | Review$repliesArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
    _count?: boolean | ReviewCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }
  export type ReviewIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    product?: boolean | ProductDefaultArgs<ExtArgs>
  }

  export type $ReviewPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Review"
    objects: {
      images: Prisma.$ReviewImagePayload<ExtArgs>[]
      votes: Prisma.$ReviewVotePayload<ExtArgs>[]
      reports: Prisma.$ReviewReportPayload<ExtArgs>[]
      replies: Prisma.$ReviewReplyPayload<ExtArgs>[]
      user: Prisma.$UserPayload<ExtArgs>
      product: Prisma.$ProductPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      productId: string
      userId: string
      rating: number
      title: string
      content: string
      isVerified: boolean
      visibility: $Enums.ReviewVisibility
      reported: boolean
      helpfulCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["review"]>
    composites: {}
  }

  type ReviewGetPayload<S extends boolean | null | undefined | ReviewDefaultArgs> = $Result.GetResult<Prisma.$ReviewPayload, S>

  type ReviewCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewCountAggregateInputType | true
    }

  export interface ReviewDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Review'], meta: { name: 'Review' } }
    /**
     * Find zero or one Review that matches the filter.
     * @param {ReviewFindUniqueArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewFindUniqueArgs>(args: SelectSubset<T, ReviewFindUniqueArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Review that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewFindUniqueOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewFindFirstArgs>(args?: SelectSubset<T, ReviewFindFirstArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Review that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindFirstOrThrowArgs} args - Arguments to find a Review
     * @example
     * // Get one Review
     * const review = await prisma.review.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Reviews that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reviews
     * const reviews = await prisma.review.findMany()
     * 
     * // Get first 10 Reviews
     * const reviews = await prisma.review.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewWithIdOnly = await prisma.review.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewFindManyArgs>(args?: SelectSubset<T, ReviewFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Review.
     * @param {ReviewCreateArgs} args - Arguments to create a Review.
     * @example
     * // Create one Review
     * const Review = await prisma.review.create({
     *   data: {
     *     // ... data to create a Review
     *   }
     * })
     * 
     */
    create<T extends ReviewCreateArgs>(args: SelectSubset<T, ReviewCreateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Reviews.
     * @param {ReviewCreateManyArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewCreateManyArgs>(args?: SelectSubset<T, ReviewCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reviews and returns the data saved in the database.
     * @param {ReviewCreateManyAndReturnArgs} args - Arguments to create many Reviews.
     * @example
     * // Create many Reviews
     * const review = await prisma.review.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Review.
     * @param {ReviewDeleteArgs} args - Arguments to delete one Review.
     * @example
     * // Delete one Review
     * const Review = await prisma.review.delete({
     *   where: {
     *     // ... filter to delete one Review
     *   }
     * })
     * 
     */
    delete<T extends ReviewDeleteArgs>(args: SelectSubset<T, ReviewDeleteArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Review.
     * @param {ReviewUpdateArgs} args - Arguments to update one Review.
     * @example
     * // Update one Review
     * const review = await prisma.review.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewUpdateArgs>(args: SelectSubset<T, ReviewUpdateArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Reviews.
     * @param {ReviewDeleteManyArgs} args - Arguments to filter Reviews to delete.
     * @example
     * // Delete a few Reviews
     * const { count } = await prisma.review.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewDeleteManyArgs>(args?: SelectSubset<T, ReviewDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewUpdateManyArgs>(args: SelectSubset<T, ReviewUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reviews and returns the data updated in the database.
     * @param {ReviewUpdateManyAndReturnArgs} args - Arguments to update many Reviews.
     * @example
     * // Update many Reviews
     * const review = await prisma.review.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Reviews and only return the `id`
     * const reviewWithIdOnly = await prisma.review.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Review.
     * @param {ReviewUpsertArgs} args - Arguments to update or create a Review.
     * @example
     * // Update or create a Review
     * const review = await prisma.review.upsert({
     *   create: {
     *     // ... data to create a Review
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Review we want to update
     *   }
     * })
     */
    upsert<T extends ReviewUpsertArgs>(args: SelectSubset<T, ReviewUpsertArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Reviews.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewCountArgs} args - Arguments to filter Reviews to count.
     * @example
     * // Count the number of Reviews
     * const count = await prisma.review.count({
     *   where: {
     *     // ... the filter for the Reviews we want to count
     *   }
     * })
    **/
    count<T extends ReviewCountArgs>(
      args?: Subset<T, ReviewCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewAggregateArgs>(args: Subset<T, ReviewAggregateArgs>): Prisma.PrismaPromise<GetReviewAggregateType<T>>

    /**
     * Group by Review.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewGroupByArgs['orderBy'] }
        : { orderBy?: ReviewGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Review model
   */
  readonly fields: ReviewFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Review.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    images<T extends Review$imagesArgs<ExtArgs> = {}>(args?: Subset<T, Review$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    votes<T extends Review$votesArgs<ExtArgs> = {}>(args?: Subset<T, Review$votesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    reports<T extends Review$reportsArgs<ExtArgs> = {}>(args?: Subset<T, Review$reportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    replies<T extends Review$repliesArgs<ExtArgs> = {}>(args?: Subset<T, Review$repliesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    product<T extends ProductDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProductDefaultArgs<ExtArgs>>): Prisma__ProductClient<$Result.GetResult<Prisma.$ProductPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Review model
   */
  interface ReviewFieldRefs {
    readonly id: FieldRef<"Review", 'String'>
    readonly productId: FieldRef<"Review", 'String'>
    readonly userId: FieldRef<"Review", 'String'>
    readonly rating: FieldRef<"Review", 'Float'>
    readonly title: FieldRef<"Review", 'String'>
    readonly content: FieldRef<"Review", 'String'>
    readonly isVerified: FieldRef<"Review", 'Boolean'>
    readonly visibility: FieldRef<"Review", 'ReviewVisibility'>
    readonly reported: FieldRef<"Review", 'Boolean'>
    readonly helpfulCount: FieldRef<"Review", 'Int'>
    readonly createdAt: FieldRef<"Review", 'DateTime'>
    readonly updatedAt: FieldRef<"Review", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Review findUnique
   */
  export type ReviewFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findUniqueOrThrow
   */
  export type ReviewFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review findFirst
   */
  export type ReviewFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findFirstOrThrow
   */
  export type ReviewFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Review to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reviews.
     */
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review findMany
   */
  export type ReviewFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter, which Reviews to fetch.
     */
    where?: ReviewWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reviews to fetch.
     */
    orderBy?: ReviewOrderByWithRelationInput | ReviewOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reviews.
     */
    cursor?: ReviewWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reviews from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reviews.
     */
    skip?: number
    distinct?: ReviewScalarFieldEnum | ReviewScalarFieldEnum[]
  }

  /**
   * Review create
   */
  export type ReviewCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to create a Review.
     */
    data: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
  }

  /**
   * Review createMany
   */
  export type ReviewCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Review createManyAndReturn
   */
  export type ReviewCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to create many Reviews.
     */
    data: ReviewCreateManyInput | ReviewCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review update
   */
  export type ReviewUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The data needed to update a Review.
     */
    data: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
    /**
     * Choose, which Review to update.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review updateMany
   */
  export type ReviewUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
  }

  /**
   * Review updateManyAndReturn
   */
  export type ReviewUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * The data used to update Reviews.
     */
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyInput>
    /**
     * Filter which Reviews to update
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Review upsert
   */
  export type ReviewUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * The filter to search for the Review to update in case it exists.
     */
    where: ReviewWhereUniqueInput
    /**
     * In case the Review found by the `where` argument doesn't exist, create a new Review with this data.
     */
    create: XOR<ReviewCreateInput, ReviewUncheckedCreateInput>
    /**
     * In case the Review was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewUpdateInput, ReviewUncheckedUpdateInput>
  }

  /**
   * Review delete
   */
  export type ReviewDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
    /**
     * Filter which Review to delete.
     */
    where: ReviewWhereUniqueInput
  }

  /**
   * Review deleteMany
   */
  export type ReviewDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reviews to delete
     */
    where?: ReviewWhereInput
    /**
     * Limit how many Reviews to delete.
     */
    limit?: number
  }

  /**
   * Review.images
   */
  export type Review$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    where?: ReviewImageWhereInput
    orderBy?: ReviewImageOrderByWithRelationInput | ReviewImageOrderByWithRelationInput[]
    cursor?: ReviewImageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewImageScalarFieldEnum | ReviewImageScalarFieldEnum[]
  }

  /**
   * Review.votes
   */
  export type Review$votesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    cursor?: ReviewVoteWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * Review.reports
   */
  export type Review$reportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    cursor?: ReviewReportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * Review.replies
   */
  export type Review$repliesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    cursor?: ReviewReplyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * Review without action
   */
  export type ReviewDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Review
     */
    select?: ReviewSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Review
     */
    omit?: ReviewOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewInclude<ExtArgs> | null
  }


  /**
   * Model ReviewImage
   */

  export type AggregateReviewImage = {
    _count: ReviewImageCountAggregateOutputType | null
    _avg: ReviewImageAvgAggregateOutputType | null
    _sum: ReviewImageSumAggregateOutputType | null
    _min: ReviewImageMinAggregateOutputType | null
    _max: ReviewImageMaxAggregateOutputType | null
  }

  export type ReviewImageAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ReviewImageSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ReviewImageMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ReviewImageMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    url: string | null
    altText: string | null
    sortOrder: number | null
    createdAt: Date | null
  }

  export type ReviewImageCountAggregateOutputType = {
    id: number
    reviewId: number
    url: number
    altText: number
    sortOrder: number
    createdAt: number
    _all: number
  }


  export type ReviewImageAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ReviewImageSumAggregateInputType = {
    sortOrder?: true
  }

  export type ReviewImageMinAggregateInputType = {
    id?: true
    reviewId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ReviewImageMaxAggregateInputType = {
    id?: true
    reviewId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
  }

  export type ReviewImageCountAggregateInputType = {
    id?: true
    reviewId?: true
    url?: true
    altText?: true
    sortOrder?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewImageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewImage to aggregate.
     */
    where?: ReviewImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewImages to fetch.
     */
    orderBy?: ReviewImageOrderByWithRelationInput | ReviewImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewImages
    **/
    _count?: true | ReviewImageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReviewImageAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReviewImageSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewImageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewImageMaxAggregateInputType
  }

  export type GetReviewImageAggregateType<T extends ReviewImageAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewImage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewImage[P]>
      : GetScalarType<T[P], AggregateReviewImage[P]>
  }




  export type ReviewImageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewImageWhereInput
    orderBy?: ReviewImageOrderByWithAggregationInput | ReviewImageOrderByWithAggregationInput[]
    by: ReviewImageScalarFieldEnum[] | ReviewImageScalarFieldEnum
    having?: ReviewImageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewImageCountAggregateInputType | true
    _avg?: ReviewImageAvgAggregateInputType
    _sum?: ReviewImageSumAggregateInputType
    _min?: ReviewImageMinAggregateInputType
    _max?: ReviewImageMaxAggregateInputType
  }

  export type ReviewImageGroupByOutputType = {
    id: string
    reviewId: string
    url: string
    altText: string | null
    sortOrder: number
    createdAt: Date
    _count: ReviewImageCountAggregateOutputType | null
    _avg: ReviewImageAvgAggregateOutputType | null
    _sum: ReviewImageSumAggregateOutputType | null
    _min: ReviewImageMinAggregateOutputType | null
    _max: ReviewImageMaxAggregateOutputType | null
  }

  type GetReviewImageGroupByPayload<T extends ReviewImageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewImageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewImageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewImageGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewImageGroupByOutputType[P]>
        }
      >
    >


  export type ReviewImageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewImage"]>

  export type ReviewImageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewImage"]>

  export type ReviewImageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewImage"]>

  export type ReviewImageSelectScalar = {
    id?: boolean
    reviewId?: boolean
    url?: boolean
    altText?: boolean
    sortOrder?: boolean
    createdAt?: boolean
  }

  export type ReviewImageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "url" | "altText" | "sortOrder" | "createdAt", ExtArgs["result"]["reviewImage"]>
  export type ReviewImageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewImageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }
  export type ReviewImageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
  }

  export type $ReviewImagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewImage"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      url: string
      altText: string | null
      sortOrder: number
      createdAt: Date
    }, ExtArgs["result"]["reviewImage"]>
    composites: {}
  }

  type ReviewImageGetPayload<S extends boolean | null | undefined | ReviewImageDefaultArgs> = $Result.GetResult<Prisma.$ReviewImagePayload, S>

  type ReviewImageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewImageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewImageCountAggregateInputType | true
    }

  export interface ReviewImageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewImage'], meta: { name: 'ReviewImage' } }
    /**
     * Find zero or one ReviewImage that matches the filter.
     * @param {ReviewImageFindUniqueArgs} args - Arguments to find a ReviewImage
     * @example
     * // Get one ReviewImage
     * const reviewImage = await prisma.reviewImage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewImageFindUniqueArgs>(args: SelectSubset<T, ReviewImageFindUniqueArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewImage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewImageFindUniqueOrThrowArgs} args - Arguments to find a ReviewImage
     * @example
     * // Get one ReviewImage
     * const reviewImage = await prisma.reviewImage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewImageFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewImageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewImage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageFindFirstArgs} args - Arguments to find a ReviewImage
     * @example
     * // Get one ReviewImage
     * const reviewImage = await prisma.reviewImage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewImageFindFirstArgs>(args?: SelectSubset<T, ReviewImageFindFirstArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewImage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageFindFirstOrThrowArgs} args - Arguments to find a ReviewImage
     * @example
     * // Get one ReviewImage
     * const reviewImage = await prisma.reviewImage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewImageFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewImageFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewImages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewImages
     * const reviewImages = await prisma.reviewImage.findMany()
     * 
     * // Get first 10 ReviewImages
     * const reviewImages = await prisma.reviewImage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewImageWithIdOnly = await prisma.reviewImage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewImageFindManyArgs>(args?: SelectSubset<T, ReviewImageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewImage.
     * @param {ReviewImageCreateArgs} args - Arguments to create a ReviewImage.
     * @example
     * // Create one ReviewImage
     * const ReviewImage = await prisma.reviewImage.create({
     *   data: {
     *     // ... data to create a ReviewImage
     *   }
     * })
     * 
     */
    create<T extends ReviewImageCreateArgs>(args: SelectSubset<T, ReviewImageCreateArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewImages.
     * @param {ReviewImageCreateManyArgs} args - Arguments to create many ReviewImages.
     * @example
     * // Create many ReviewImages
     * const reviewImage = await prisma.reviewImage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewImageCreateManyArgs>(args?: SelectSubset<T, ReviewImageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewImages and returns the data saved in the database.
     * @param {ReviewImageCreateManyAndReturnArgs} args - Arguments to create many ReviewImages.
     * @example
     * // Create many ReviewImages
     * const reviewImage = await prisma.reviewImage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewImages and only return the `id`
     * const reviewImageWithIdOnly = await prisma.reviewImage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewImageCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewImageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewImage.
     * @param {ReviewImageDeleteArgs} args - Arguments to delete one ReviewImage.
     * @example
     * // Delete one ReviewImage
     * const ReviewImage = await prisma.reviewImage.delete({
     *   where: {
     *     // ... filter to delete one ReviewImage
     *   }
     * })
     * 
     */
    delete<T extends ReviewImageDeleteArgs>(args: SelectSubset<T, ReviewImageDeleteArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewImage.
     * @param {ReviewImageUpdateArgs} args - Arguments to update one ReviewImage.
     * @example
     * // Update one ReviewImage
     * const reviewImage = await prisma.reviewImage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewImageUpdateArgs>(args: SelectSubset<T, ReviewImageUpdateArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewImages.
     * @param {ReviewImageDeleteManyArgs} args - Arguments to filter ReviewImages to delete.
     * @example
     * // Delete a few ReviewImages
     * const { count } = await prisma.reviewImage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewImageDeleteManyArgs>(args?: SelectSubset<T, ReviewImageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewImages
     * const reviewImage = await prisma.reviewImage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewImageUpdateManyArgs>(args: SelectSubset<T, ReviewImageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewImages and returns the data updated in the database.
     * @param {ReviewImageUpdateManyAndReturnArgs} args - Arguments to update many ReviewImages.
     * @example
     * // Update many ReviewImages
     * const reviewImage = await prisma.reviewImage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewImages and only return the `id`
     * const reviewImageWithIdOnly = await prisma.reviewImage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewImageUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewImageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewImage.
     * @param {ReviewImageUpsertArgs} args - Arguments to update or create a ReviewImage.
     * @example
     * // Update or create a ReviewImage
     * const reviewImage = await prisma.reviewImage.upsert({
     *   create: {
     *     // ... data to create a ReviewImage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewImage we want to update
     *   }
     * })
     */
    upsert<T extends ReviewImageUpsertArgs>(args: SelectSubset<T, ReviewImageUpsertArgs<ExtArgs>>): Prisma__ReviewImageClient<$Result.GetResult<Prisma.$ReviewImagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewImages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageCountArgs} args - Arguments to filter ReviewImages to count.
     * @example
     * // Count the number of ReviewImages
     * const count = await prisma.reviewImage.count({
     *   where: {
     *     // ... the filter for the ReviewImages we want to count
     *   }
     * })
    **/
    count<T extends ReviewImageCountArgs>(
      args?: Subset<T, ReviewImageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewImageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewImageAggregateArgs>(args: Subset<T, ReviewImageAggregateArgs>): Prisma.PrismaPromise<GetReviewImageAggregateType<T>>

    /**
     * Group by ReviewImage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewImageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewImageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewImageGroupByArgs['orderBy'] }
        : { orderBy?: ReviewImageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewImageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewImageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewImage model
   */
  readonly fields: ReviewImageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewImage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewImageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewImage model
   */
  interface ReviewImageFieldRefs {
    readonly id: FieldRef<"ReviewImage", 'String'>
    readonly reviewId: FieldRef<"ReviewImage", 'String'>
    readonly url: FieldRef<"ReviewImage", 'String'>
    readonly altText: FieldRef<"ReviewImage", 'String'>
    readonly sortOrder: FieldRef<"ReviewImage", 'Int'>
    readonly createdAt: FieldRef<"ReviewImage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewImage findUnique
   */
  export type ReviewImageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter, which ReviewImage to fetch.
     */
    where: ReviewImageWhereUniqueInput
  }

  /**
   * ReviewImage findUniqueOrThrow
   */
  export type ReviewImageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter, which ReviewImage to fetch.
     */
    where: ReviewImageWhereUniqueInput
  }

  /**
   * ReviewImage findFirst
   */
  export type ReviewImageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter, which ReviewImage to fetch.
     */
    where?: ReviewImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewImages to fetch.
     */
    orderBy?: ReviewImageOrderByWithRelationInput | ReviewImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewImages.
     */
    cursor?: ReviewImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewImages.
     */
    distinct?: ReviewImageScalarFieldEnum | ReviewImageScalarFieldEnum[]
  }

  /**
   * ReviewImage findFirstOrThrow
   */
  export type ReviewImageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter, which ReviewImage to fetch.
     */
    where?: ReviewImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewImages to fetch.
     */
    orderBy?: ReviewImageOrderByWithRelationInput | ReviewImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewImages.
     */
    cursor?: ReviewImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewImages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewImages.
     */
    distinct?: ReviewImageScalarFieldEnum | ReviewImageScalarFieldEnum[]
  }

  /**
   * ReviewImage findMany
   */
  export type ReviewImageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter, which ReviewImages to fetch.
     */
    where?: ReviewImageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewImages to fetch.
     */
    orderBy?: ReviewImageOrderByWithRelationInput | ReviewImageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewImages.
     */
    cursor?: ReviewImageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewImages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewImages.
     */
    skip?: number
    distinct?: ReviewImageScalarFieldEnum | ReviewImageScalarFieldEnum[]
  }

  /**
   * ReviewImage create
   */
  export type ReviewImageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewImage.
     */
    data: XOR<ReviewImageCreateInput, ReviewImageUncheckedCreateInput>
  }

  /**
   * ReviewImage createMany
   */
  export type ReviewImageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewImages.
     */
    data: ReviewImageCreateManyInput | ReviewImageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewImage createManyAndReturn
   */
  export type ReviewImageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewImages.
     */
    data: ReviewImageCreateManyInput | ReviewImageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewImage update
   */
  export type ReviewImageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewImage.
     */
    data: XOR<ReviewImageUpdateInput, ReviewImageUncheckedUpdateInput>
    /**
     * Choose, which ReviewImage to update.
     */
    where: ReviewImageWhereUniqueInput
  }

  /**
   * ReviewImage updateMany
   */
  export type ReviewImageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewImages.
     */
    data: XOR<ReviewImageUpdateManyMutationInput, ReviewImageUncheckedUpdateManyInput>
    /**
     * Filter which ReviewImages to update
     */
    where?: ReviewImageWhereInput
    /**
     * Limit how many ReviewImages to update.
     */
    limit?: number
  }

  /**
   * ReviewImage updateManyAndReturn
   */
  export type ReviewImageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * The data used to update ReviewImages.
     */
    data: XOR<ReviewImageUpdateManyMutationInput, ReviewImageUncheckedUpdateManyInput>
    /**
     * Filter which ReviewImages to update
     */
    where?: ReviewImageWhereInput
    /**
     * Limit how many ReviewImages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewImage upsert
   */
  export type ReviewImageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewImage to update in case it exists.
     */
    where: ReviewImageWhereUniqueInput
    /**
     * In case the ReviewImage found by the `where` argument doesn't exist, create a new ReviewImage with this data.
     */
    create: XOR<ReviewImageCreateInput, ReviewImageUncheckedCreateInput>
    /**
     * In case the ReviewImage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewImageUpdateInput, ReviewImageUncheckedUpdateInput>
  }

  /**
   * ReviewImage delete
   */
  export type ReviewImageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
    /**
     * Filter which ReviewImage to delete.
     */
    where: ReviewImageWhereUniqueInput
  }

  /**
   * ReviewImage deleteMany
   */
  export type ReviewImageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewImages to delete
     */
    where?: ReviewImageWhereInput
    /**
     * Limit how many ReviewImages to delete.
     */
    limit?: number
  }

  /**
   * ReviewImage without action
   */
  export type ReviewImageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewImage
     */
    select?: ReviewImageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewImage
     */
    omit?: ReviewImageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewImageInclude<ExtArgs> | null
  }


  /**
   * Model ReviewVote
   */

  export type AggregateReviewVote = {
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  export type ReviewVoteMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    type: $Enums.VoteType | null
    createdAt: Date | null
  }

  export type ReviewVoteMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    type: $Enums.VoteType | null
    createdAt: Date | null
  }

  export type ReviewVoteCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    type: number
    createdAt: number
    _all: number
  }


  export type ReviewVoteMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReviewVoteMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    type?: true
    createdAt?: true
  }

  export type ReviewVoteCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    type?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewVoteAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVote to aggregate.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewVotes
    **/
    _count?: true | ReviewVoteCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewVoteMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type GetReviewVoteAggregateType<T extends ReviewVoteAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewVote]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewVote[P]>
      : GetScalarType<T[P], AggregateReviewVote[P]>
  }




  export type ReviewVoteGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewVoteWhereInput
    orderBy?: ReviewVoteOrderByWithAggregationInput | ReviewVoteOrderByWithAggregationInput[]
    by: ReviewVoteScalarFieldEnum[] | ReviewVoteScalarFieldEnum
    having?: ReviewVoteScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewVoteCountAggregateInputType | true
    _min?: ReviewVoteMinAggregateInputType
    _max?: ReviewVoteMaxAggregateInputType
  }

  export type ReviewVoteGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    type: $Enums.VoteType
    createdAt: Date
    _count: ReviewVoteCountAggregateOutputType | null
    _min: ReviewVoteMinAggregateOutputType | null
    _max: ReviewVoteMaxAggregateOutputType | null
  }

  type GetReviewVoteGroupByPayload<T extends ReviewVoteGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewVoteGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewVoteGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewVoteGroupByOutputType[P]>
        }
      >
    >


  export type ReviewVoteSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewVote"]>

  export type ReviewVoteSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    type?: boolean
    createdAt?: boolean
  }

  export type ReviewVoteOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "type" | "createdAt", ExtArgs["result"]["reviewVote"]>
  export type ReviewVoteInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewVoteIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewVotePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewVote"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      type: $Enums.VoteType
      createdAt: Date
    }, ExtArgs["result"]["reviewVote"]>
    composites: {}
  }

  type ReviewVoteGetPayload<S extends boolean | null | undefined | ReviewVoteDefaultArgs> = $Result.GetResult<Prisma.$ReviewVotePayload, S>

  type ReviewVoteCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewVoteFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewVoteCountAggregateInputType | true
    }

  export interface ReviewVoteDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewVote'], meta: { name: 'ReviewVote' } }
    /**
     * Find zero or one ReviewVote that matches the filter.
     * @param {ReviewVoteFindUniqueArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewVoteFindUniqueArgs>(args: SelectSubset<T, ReviewVoteFindUniqueArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewVote that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewVoteFindUniqueOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewVoteFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewVoteFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewVoteFindFirstArgs>(args?: SelectSubset<T, ReviewVoteFindFirstArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewVote that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindFirstOrThrowArgs} args - Arguments to find a ReviewVote
     * @example
     * // Get one ReviewVote
     * const reviewVote = await prisma.reviewVote.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewVoteFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewVoteFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewVotes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany()
     * 
     * // Get first 10 ReviewVotes
     * const reviewVotes = await prisma.reviewVote.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewVoteFindManyArgs>(args?: SelectSubset<T, ReviewVoteFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewVote.
     * @param {ReviewVoteCreateArgs} args - Arguments to create a ReviewVote.
     * @example
     * // Create one ReviewVote
     * const ReviewVote = await prisma.reviewVote.create({
     *   data: {
     *     // ... data to create a ReviewVote
     *   }
     * })
     * 
     */
    create<T extends ReviewVoteCreateArgs>(args: SelectSubset<T, ReviewVoteCreateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewVotes.
     * @param {ReviewVoteCreateManyArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewVoteCreateManyArgs>(args?: SelectSubset<T, ReviewVoteCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewVotes and returns the data saved in the database.
     * @param {ReviewVoteCreateManyAndReturnArgs} args - Arguments to create many ReviewVotes.
     * @example
     * // Create many ReviewVotes
     * const reviewVote = await prisma.reviewVote.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewVoteCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewVoteCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewVote.
     * @param {ReviewVoteDeleteArgs} args - Arguments to delete one ReviewVote.
     * @example
     * // Delete one ReviewVote
     * const ReviewVote = await prisma.reviewVote.delete({
     *   where: {
     *     // ... filter to delete one ReviewVote
     *   }
     * })
     * 
     */
    delete<T extends ReviewVoteDeleteArgs>(args: SelectSubset<T, ReviewVoteDeleteArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewVote.
     * @param {ReviewVoteUpdateArgs} args - Arguments to update one ReviewVote.
     * @example
     * // Update one ReviewVote
     * const reviewVote = await prisma.reviewVote.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewVoteUpdateArgs>(args: SelectSubset<T, ReviewVoteUpdateArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewVotes.
     * @param {ReviewVoteDeleteManyArgs} args - Arguments to filter ReviewVotes to delete.
     * @example
     * // Delete a few ReviewVotes
     * const { count } = await prisma.reviewVote.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewVoteDeleteManyArgs>(args?: SelectSubset<T, ReviewVoteDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewVoteUpdateManyArgs>(args: SelectSubset<T, ReviewVoteUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewVotes and returns the data updated in the database.
     * @param {ReviewVoteUpdateManyAndReturnArgs} args - Arguments to update many ReviewVotes.
     * @example
     * // Update many ReviewVotes
     * const reviewVote = await prisma.reviewVote.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewVotes and only return the `id`
     * const reviewVoteWithIdOnly = await prisma.reviewVote.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewVoteUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewVoteUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewVote.
     * @param {ReviewVoteUpsertArgs} args - Arguments to update or create a ReviewVote.
     * @example
     * // Update or create a ReviewVote
     * const reviewVote = await prisma.reviewVote.upsert({
     *   create: {
     *     // ... data to create a ReviewVote
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewVote we want to update
     *   }
     * })
     */
    upsert<T extends ReviewVoteUpsertArgs>(args: SelectSubset<T, ReviewVoteUpsertArgs<ExtArgs>>): Prisma__ReviewVoteClient<$Result.GetResult<Prisma.$ReviewVotePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewVotes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteCountArgs} args - Arguments to filter ReviewVotes to count.
     * @example
     * // Count the number of ReviewVotes
     * const count = await prisma.reviewVote.count({
     *   where: {
     *     // ... the filter for the ReviewVotes we want to count
     *   }
     * })
    **/
    count<T extends ReviewVoteCountArgs>(
      args?: Subset<T, ReviewVoteCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewVoteCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewVoteAggregateArgs>(args: Subset<T, ReviewVoteAggregateArgs>): Prisma.PrismaPromise<GetReviewVoteAggregateType<T>>

    /**
     * Group by ReviewVote.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewVoteGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewVoteGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewVoteGroupByArgs['orderBy'] }
        : { orderBy?: ReviewVoteGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewVoteGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewVoteGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewVote model
   */
  readonly fields: ReviewVoteFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewVote.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewVoteClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewVote model
   */
  interface ReviewVoteFieldRefs {
    readonly id: FieldRef<"ReviewVote", 'String'>
    readonly reviewId: FieldRef<"ReviewVote", 'String'>
    readonly userId: FieldRef<"ReviewVote", 'String'>
    readonly type: FieldRef<"ReviewVote", 'VoteType'>
    readonly createdAt: FieldRef<"ReviewVote", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewVote findUnique
   */
  export type ReviewVoteFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findUniqueOrThrow
   */
  export type ReviewVoteFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote findFirst
   */
  export type ReviewVoteFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findFirstOrThrow
   */
  export type ReviewVoteFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVote to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewVotes.
     */
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote findMany
   */
  export type ReviewVoteFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter, which ReviewVotes to fetch.
     */
    where?: ReviewVoteWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewVotes to fetch.
     */
    orderBy?: ReviewVoteOrderByWithRelationInput | ReviewVoteOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewVotes.
     */
    cursor?: ReviewVoteWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewVotes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewVotes.
     */
    skip?: number
    distinct?: ReviewVoteScalarFieldEnum | ReviewVoteScalarFieldEnum[]
  }

  /**
   * ReviewVote create
   */
  export type ReviewVoteCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewVote.
     */
    data: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
  }

  /**
   * ReviewVote createMany
   */
  export type ReviewVoteCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewVote createManyAndReturn
   */
  export type ReviewVoteCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewVotes.
     */
    data: ReviewVoteCreateManyInput | ReviewVoteCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote update
   */
  export type ReviewVoteUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewVote.
     */
    data: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
    /**
     * Choose, which ReviewVote to update.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote updateMany
   */
  export type ReviewVoteUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
  }

  /**
   * ReviewVote updateManyAndReturn
   */
  export type ReviewVoteUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * The data used to update ReviewVotes.
     */
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyInput>
    /**
     * Filter which ReviewVotes to update
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewVote upsert
   */
  export type ReviewVoteUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewVote to update in case it exists.
     */
    where: ReviewVoteWhereUniqueInput
    /**
     * In case the ReviewVote found by the `where` argument doesn't exist, create a new ReviewVote with this data.
     */
    create: XOR<ReviewVoteCreateInput, ReviewVoteUncheckedCreateInput>
    /**
     * In case the ReviewVote was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewVoteUpdateInput, ReviewVoteUncheckedUpdateInput>
  }

  /**
   * ReviewVote delete
   */
  export type ReviewVoteDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
    /**
     * Filter which ReviewVote to delete.
     */
    where: ReviewVoteWhereUniqueInput
  }

  /**
   * ReviewVote deleteMany
   */
  export type ReviewVoteDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewVotes to delete
     */
    where?: ReviewVoteWhereInput
    /**
     * Limit how many ReviewVotes to delete.
     */
    limit?: number
  }

  /**
   * ReviewVote without action
   */
  export type ReviewVoteDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewVote
     */
    select?: ReviewVoteSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewVote
     */
    omit?: ReviewVoteOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewVoteInclude<ExtArgs> | null
  }


  /**
   * Model ReviewReport
   */

  export type AggregateReviewReport = {
    _count: ReviewReportCountAggregateOutputType | null
    _min: ReviewReportMinAggregateOutputType | null
    _max: ReviewReportMaxAggregateOutputType | null
  }

  export type ReviewReportMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: $Enums.ReportReason | null
    details: string | null
    createdAt: Date | null
  }

  export type ReviewReportMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    userId: string | null
    reason: $Enums.ReportReason | null
    details: string | null
    createdAt: Date | null
  }

  export type ReviewReportCountAggregateOutputType = {
    id: number
    reviewId: number
    userId: number
    reason: number
    details: number
    createdAt: number
    _all: number
  }


  export type ReviewReportMinAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    details?: true
    createdAt?: true
  }

  export type ReviewReportMaxAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    details?: true
    createdAt?: true
  }

  export type ReviewReportCountAggregateInputType = {
    id?: true
    reviewId?: true
    userId?: true
    reason?: true
    details?: true
    createdAt?: true
    _all?: true
  }

  export type ReviewReportAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReport to aggregate.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewReports
    **/
    _count?: true | ReviewReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewReportMaxAggregateInputType
  }

  export type GetReviewReportAggregateType<T extends ReviewReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewReport[P]>
      : GetScalarType<T[P], AggregateReviewReport[P]>
  }




  export type ReviewReportGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReportWhereInput
    orderBy?: ReviewReportOrderByWithAggregationInput | ReviewReportOrderByWithAggregationInput[]
    by: ReviewReportScalarFieldEnum[] | ReviewReportScalarFieldEnum
    having?: ReviewReportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewReportCountAggregateInputType | true
    _min?: ReviewReportMinAggregateInputType
    _max?: ReviewReportMaxAggregateInputType
  }

  export type ReviewReportGroupByOutputType = {
    id: string
    reviewId: string
    userId: string
    reason: $Enums.ReportReason
    details: string | null
    createdAt: Date
    _count: ReviewReportCountAggregateOutputType | null
    _min: ReviewReportMinAggregateOutputType | null
    _max: ReviewReportMaxAggregateOutputType | null
  }

  type GetReviewReportGroupByPayload<T extends ReviewReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewReportGroupByOutputType[P]>
        }
      >
    >


  export type ReviewReportSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    details?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    details?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    details?: boolean
    createdAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReport"]>

  export type ReviewReportSelectScalar = {
    id?: boolean
    reviewId?: boolean
    userId?: boolean
    reason?: boolean
    details?: boolean
    createdAt?: boolean
  }

  export type ReviewReportOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "userId" | "reason" | "details" | "createdAt", ExtArgs["result"]["reviewReport"]>
  export type ReviewReportInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReportIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReportIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewReportPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewReport"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      userId: string
      reason: $Enums.ReportReason
      details: string | null
      createdAt: Date
    }, ExtArgs["result"]["reviewReport"]>
    composites: {}
  }

  type ReviewReportGetPayload<S extends boolean | null | undefined | ReviewReportDefaultArgs> = $Result.GetResult<Prisma.$ReviewReportPayload, S>

  type ReviewReportCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewReportFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewReportCountAggregateInputType | true
    }

  export interface ReviewReportDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewReport'], meta: { name: 'ReviewReport' } }
    /**
     * Find zero or one ReviewReport that matches the filter.
     * @param {ReviewReportFindUniqueArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewReportFindUniqueArgs>(args: SelectSubset<T, ReviewReportFindUniqueArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewReport that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewReportFindUniqueOrThrowArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewReportFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewReportFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReport that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindFirstArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewReportFindFirstArgs>(args?: SelectSubset<T, ReviewReportFindFirstArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReport that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindFirstOrThrowArgs} args - Arguments to find a ReviewReport
     * @example
     * // Get one ReviewReport
     * const reviewReport = await prisma.reviewReport.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewReportFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewReportFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewReports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewReports
     * const reviewReports = await prisma.reviewReport.findMany()
     * 
     * // Get first 10 ReviewReports
     * const reviewReports = await prisma.reviewReport.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewReportFindManyArgs>(args?: SelectSubset<T, ReviewReportFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewReport.
     * @param {ReviewReportCreateArgs} args - Arguments to create a ReviewReport.
     * @example
     * // Create one ReviewReport
     * const ReviewReport = await prisma.reviewReport.create({
     *   data: {
     *     // ... data to create a ReviewReport
     *   }
     * })
     * 
     */
    create<T extends ReviewReportCreateArgs>(args: SelectSubset<T, ReviewReportCreateArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewReports.
     * @param {ReviewReportCreateManyArgs} args - Arguments to create many ReviewReports.
     * @example
     * // Create many ReviewReports
     * const reviewReport = await prisma.reviewReport.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewReportCreateManyArgs>(args?: SelectSubset<T, ReviewReportCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewReports and returns the data saved in the database.
     * @param {ReviewReportCreateManyAndReturnArgs} args - Arguments to create many ReviewReports.
     * @example
     * // Create many ReviewReports
     * const reviewReport = await prisma.reviewReport.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewReports and only return the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewReportCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewReportCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewReport.
     * @param {ReviewReportDeleteArgs} args - Arguments to delete one ReviewReport.
     * @example
     * // Delete one ReviewReport
     * const ReviewReport = await prisma.reviewReport.delete({
     *   where: {
     *     // ... filter to delete one ReviewReport
     *   }
     * })
     * 
     */
    delete<T extends ReviewReportDeleteArgs>(args: SelectSubset<T, ReviewReportDeleteArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewReport.
     * @param {ReviewReportUpdateArgs} args - Arguments to update one ReviewReport.
     * @example
     * // Update one ReviewReport
     * const reviewReport = await prisma.reviewReport.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewReportUpdateArgs>(args: SelectSubset<T, ReviewReportUpdateArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewReports.
     * @param {ReviewReportDeleteManyArgs} args - Arguments to filter ReviewReports to delete.
     * @example
     * // Delete a few ReviewReports
     * const { count } = await prisma.reviewReport.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewReportDeleteManyArgs>(args?: SelectSubset<T, ReviewReportDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewReports
     * const reviewReport = await prisma.reviewReport.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewReportUpdateManyArgs>(args: SelectSubset<T, ReviewReportUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReports and returns the data updated in the database.
     * @param {ReviewReportUpdateManyAndReturnArgs} args - Arguments to update many ReviewReports.
     * @example
     * // Update many ReviewReports
     * const reviewReport = await prisma.reviewReport.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewReports and only return the `id`
     * const reviewReportWithIdOnly = await prisma.reviewReport.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewReportUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewReportUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewReport.
     * @param {ReviewReportUpsertArgs} args - Arguments to update or create a ReviewReport.
     * @example
     * // Update or create a ReviewReport
     * const reviewReport = await prisma.reviewReport.upsert({
     *   create: {
     *     // ... data to create a ReviewReport
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewReport we want to update
     *   }
     * })
     */
    upsert<T extends ReviewReportUpsertArgs>(args: SelectSubset<T, ReviewReportUpsertArgs<ExtArgs>>): Prisma__ReviewReportClient<$Result.GetResult<Prisma.$ReviewReportPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewReports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportCountArgs} args - Arguments to filter ReviewReports to count.
     * @example
     * // Count the number of ReviewReports
     * const count = await prisma.reviewReport.count({
     *   where: {
     *     // ... the filter for the ReviewReports we want to count
     *   }
     * })
    **/
    count<T extends ReviewReportCountArgs>(
      args?: Subset<T, ReviewReportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewReportAggregateArgs>(args: Subset<T, ReviewReportAggregateArgs>): Prisma.PrismaPromise<GetReviewReportAggregateType<T>>

    /**
     * Group by ReviewReport.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewReportGroupByArgs['orderBy'] }
        : { orderBy?: ReviewReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewReport model
   */
  readonly fields: ReviewReportFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewReport.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewReportClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewReport model
   */
  interface ReviewReportFieldRefs {
    readonly id: FieldRef<"ReviewReport", 'String'>
    readonly reviewId: FieldRef<"ReviewReport", 'String'>
    readonly userId: FieldRef<"ReviewReport", 'String'>
    readonly reason: FieldRef<"ReviewReport", 'ReportReason'>
    readonly details: FieldRef<"ReviewReport", 'String'>
    readonly createdAt: FieldRef<"ReviewReport", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewReport findUnique
   */
  export type ReviewReportFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport findUniqueOrThrow
   */
  export type ReviewReportFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport findFirst
   */
  export type ReviewReportFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReports.
     */
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport findFirstOrThrow
   */
  export type ReviewReportFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReport to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReports.
     */
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport findMany
   */
  export type ReviewReportFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReports to fetch.
     */
    where?: ReviewReportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReports to fetch.
     */
    orderBy?: ReviewReportOrderByWithRelationInput | ReviewReportOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewReports.
     */
    cursor?: ReviewReportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReports.
     */
    skip?: number
    distinct?: ReviewReportScalarFieldEnum | ReviewReportScalarFieldEnum[]
  }

  /**
   * ReviewReport create
   */
  export type ReviewReportCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewReport.
     */
    data: XOR<ReviewReportCreateInput, ReviewReportUncheckedCreateInput>
  }

  /**
   * ReviewReport createMany
   */
  export type ReviewReportCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewReports.
     */
    data: ReviewReportCreateManyInput | ReviewReportCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewReport createManyAndReturn
   */
  export type ReviewReportCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewReports.
     */
    data: ReviewReportCreateManyInput | ReviewReportCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReport update
   */
  export type ReviewReportUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewReport.
     */
    data: XOR<ReviewReportUpdateInput, ReviewReportUncheckedUpdateInput>
    /**
     * Choose, which ReviewReport to update.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport updateMany
   */
  export type ReviewReportUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewReports.
     */
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReports to update
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to update.
     */
    limit?: number
  }

  /**
   * ReviewReport updateManyAndReturn
   */
  export type ReviewReportUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * The data used to update ReviewReports.
     */
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReports to update
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReport upsert
   */
  export type ReviewReportUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewReport to update in case it exists.
     */
    where: ReviewReportWhereUniqueInput
    /**
     * In case the ReviewReport found by the `where` argument doesn't exist, create a new ReviewReport with this data.
     */
    create: XOR<ReviewReportCreateInput, ReviewReportUncheckedCreateInput>
    /**
     * In case the ReviewReport was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewReportUpdateInput, ReviewReportUncheckedUpdateInput>
  }

  /**
   * ReviewReport delete
   */
  export type ReviewReportDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
    /**
     * Filter which ReviewReport to delete.
     */
    where: ReviewReportWhereUniqueInput
  }

  /**
   * ReviewReport deleteMany
   */
  export type ReviewReportDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReports to delete
     */
    where?: ReviewReportWhereInput
    /**
     * Limit how many ReviewReports to delete.
     */
    limit?: number
  }

  /**
   * ReviewReport without action
   */
  export type ReviewReportDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReport
     */
    select?: ReviewReportSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReport
     */
    omit?: ReviewReportOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReportInclude<ExtArgs> | null
  }


  /**
   * Model ReviewReply
   */

  export type AggregateReviewReply = {
    _count: ReviewReplyCountAggregateOutputType | null
    _min: ReviewReplyMinAggregateOutputType | null
    _max: ReviewReplyMaxAggregateOutputType | null
  }

  export type ReviewReplyMinAggregateOutputType = {
    id: string | null
    reviewId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewReplyMaxAggregateOutputType = {
    id: string | null
    reviewId: string | null
    authorId: string | null
    content: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ReviewReplyCountAggregateOutputType = {
    id: number
    reviewId: number
    authorId: number
    content: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ReviewReplyMinAggregateInputType = {
    id?: true
    reviewId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewReplyMaxAggregateInputType = {
    id?: true
    reviewId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ReviewReplyCountAggregateInputType = {
    id?: true
    reviewId?: true
    authorId?: true
    content?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ReviewReplyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReply to aggregate.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ReviewReplies
    **/
    _count?: true | ReviewReplyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReviewReplyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReviewReplyMaxAggregateInputType
  }

  export type GetReviewReplyAggregateType<T extends ReviewReplyAggregateArgs> = {
        [P in keyof T & keyof AggregateReviewReply]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReviewReply[P]>
      : GetScalarType<T[P], AggregateReviewReply[P]>
  }




  export type ReviewReplyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReviewReplyWhereInput
    orderBy?: ReviewReplyOrderByWithAggregationInput | ReviewReplyOrderByWithAggregationInput[]
    by: ReviewReplyScalarFieldEnum[] | ReviewReplyScalarFieldEnum
    having?: ReviewReplyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReviewReplyCountAggregateInputType | true
    _min?: ReviewReplyMinAggregateInputType
    _max?: ReviewReplyMaxAggregateInputType
  }

  export type ReviewReplyGroupByOutputType = {
    id: string
    reviewId: string
    authorId: string
    content: string
    createdAt: Date
    updatedAt: Date
    _count: ReviewReplyCountAggregateOutputType | null
    _min: ReviewReplyMinAggregateOutputType | null
    _max: ReviewReplyMaxAggregateOutputType | null
  }

  type GetReviewReplyGroupByPayload<T extends ReviewReplyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReviewReplyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReviewReplyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReviewReplyGroupByOutputType[P]>
            : GetScalarType<T[P], ReviewReplyGroupByOutputType[P]>
        }
      >
    >


  export type ReviewReplySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reviewId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reviewReply"]>

  export type ReviewReplySelectScalar = {
    id?: boolean
    reviewId?: boolean
    authorId?: boolean
    content?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ReviewReplyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "reviewId" | "authorId" | "content" | "createdAt" | "updatedAt", ExtArgs["result"]["reviewReply"]>
  export type ReviewReplyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReplyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ReviewReplyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    review?: boolean | ReviewDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ReviewReplyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ReviewReply"
    objects: {
      review: Prisma.$ReviewPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      reviewId: string
      authorId: string
      content: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["reviewReply"]>
    composites: {}
  }

  type ReviewReplyGetPayload<S extends boolean | null | undefined | ReviewReplyDefaultArgs> = $Result.GetResult<Prisma.$ReviewReplyPayload, S>

  type ReviewReplyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ReviewReplyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ReviewReplyCountAggregateInputType | true
    }

  export interface ReviewReplyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ReviewReply'], meta: { name: 'ReviewReply' } }
    /**
     * Find zero or one ReviewReply that matches the filter.
     * @param {ReviewReplyFindUniqueArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReviewReplyFindUniqueArgs>(args: SelectSubset<T, ReviewReplyFindUniqueArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ReviewReply that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ReviewReplyFindUniqueOrThrowArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReviewReplyFindUniqueOrThrowArgs>(args: SelectSubset<T, ReviewReplyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReply that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindFirstArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReviewReplyFindFirstArgs>(args?: SelectSubset<T, ReviewReplyFindFirstArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ReviewReply that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindFirstOrThrowArgs} args - Arguments to find a ReviewReply
     * @example
     * // Get one ReviewReply
     * const reviewReply = await prisma.reviewReply.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReviewReplyFindFirstOrThrowArgs>(args?: SelectSubset<T, ReviewReplyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ReviewReplies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ReviewReplies
     * const reviewReplies = await prisma.reviewReply.findMany()
     * 
     * // Get first 10 ReviewReplies
     * const reviewReplies = await prisma.reviewReply.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReviewReplyFindManyArgs>(args?: SelectSubset<T, ReviewReplyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ReviewReply.
     * @param {ReviewReplyCreateArgs} args - Arguments to create a ReviewReply.
     * @example
     * // Create one ReviewReply
     * const ReviewReply = await prisma.reviewReply.create({
     *   data: {
     *     // ... data to create a ReviewReply
     *   }
     * })
     * 
     */
    create<T extends ReviewReplyCreateArgs>(args: SelectSubset<T, ReviewReplyCreateArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ReviewReplies.
     * @param {ReviewReplyCreateManyArgs} args - Arguments to create many ReviewReplies.
     * @example
     * // Create many ReviewReplies
     * const reviewReply = await prisma.reviewReply.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReviewReplyCreateManyArgs>(args?: SelectSubset<T, ReviewReplyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ReviewReplies and returns the data saved in the database.
     * @param {ReviewReplyCreateManyAndReturnArgs} args - Arguments to create many ReviewReplies.
     * @example
     * // Create many ReviewReplies
     * const reviewReply = await prisma.reviewReply.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ReviewReplies and only return the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReviewReplyCreateManyAndReturnArgs>(args?: SelectSubset<T, ReviewReplyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ReviewReply.
     * @param {ReviewReplyDeleteArgs} args - Arguments to delete one ReviewReply.
     * @example
     * // Delete one ReviewReply
     * const ReviewReply = await prisma.reviewReply.delete({
     *   where: {
     *     // ... filter to delete one ReviewReply
     *   }
     * })
     * 
     */
    delete<T extends ReviewReplyDeleteArgs>(args: SelectSubset<T, ReviewReplyDeleteArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ReviewReply.
     * @param {ReviewReplyUpdateArgs} args - Arguments to update one ReviewReply.
     * @example
     * // Update one ReviewReply
     * const reviewReply = await prisma.reviewReply.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReviewReplyUpdateArgs>(args: SelectSubset<T, ReviewReplyUpdateArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ReviewReplies.
     * @param {ReviewReplyDeleteManyArgs} args - Arguments to filter ReviewReplies to delete.
     * @example
     * // Delete a few ReviewReplies
     * const { count } = await prisma.reviewReply.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReviewReplyDeleteManyArgs>(args?: SelectSubset<T, ReviewReplyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ReviewReplies
     * const reviewReply = await prisma.reviewReply.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReviewReplyUpdateManyArgs>(args: SelectSubset<T, ReviewReplyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ReviewReplies and returns the data updated in the database.
     * @param {ReviewReplyUpdateManyAndReturnArgs} args - Arguments to update many ReviewReplies.
     * @example
     * // Update many ReviewReplies
     * const reviewReply = await prisma.reviewReply.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ReviewReplies and only return the `id`
     * const reviewReplyWithIdOnly = await prisma.reviewReply.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ReviewReplyUpdateManyAndReturnArgs>(args: SelectSubset<T, ReviewReplyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ReviewReply.
     * @param {ReviewReplyUpsertArgs} args - Arguments to update or create a ReviewReply.
     * @example
     * // Update or create a ReviewReply
     * const reviewReply = await prisma.reviewReply.upsert({
     *   create: {
     *     // ... data to create a ReviewReply
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ReviewReply we want to update
     *   }
     * })
     */
    upsert<T extends ReviewReplyUpsertArgs>(args: SelectSubset<T, ReviewReplyUpsertArgs<ExtArgs>>): Prisma__ReviewReplyClient<$Result.GetResult<Prisma.$ReviewReplyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ReviewReplies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyCountArgs} args - Arguments to filter ReviewReplies to count.
     * @example
     * // Count the number of ReviewReplies
     * const count = await prisma.reviewReply.count({
     *   where: {
     *     // ... the filter for the ReviewReplies we want to count
     *   }
     * })
    **/
    count<T extends ReviewReplyCountArgs>(
      args?: Subset<T, ReviewReplyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReviewReplyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ReviewReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReviewReplyAggregateArgs>(args: Subset<T, ReviewReplyAggregateArgs>): Prisma.PrismaPromise<GetReviewReplyAggregateType<T>>

    /**
     * Group by ReviewReply.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReviewReplyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReviewReplyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReviewReplyGroupByArgs['orderBy'] }
        : { orderBy?: ReviewReplyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReviewReplyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReviewReplyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ReviewReply model
   */
  readonly fields: ReviewReplyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ReviewReply.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReviewReplyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    review<T extends ReviewDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReviewDefaultArgs<ExtArgs>>): Prisma__ReviewClient<$Result.GetResult<Prisma.$ReviewPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ReviewReply model
   */
  interface ReviewReplyFieldRefs {
    readonly id: FieldRef<"ReviewReply", 'String'>
    readonly reviewId: FieldRef<"ReviewReply", 'String'>
    readonly authorId: FieldRef<"ReviewReply", 'String'>
    readonly content: FieldRef<"ReviewReply", 'String'>
    readonly createdAt: FieldRef<"ReviewReply", 'DateTime'>
    readonly updatedAt: FieldRef<"ReviewReply", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ReviewReply findUnique
   */
  export type ReviewReplyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply findUniqueOrThrow
   */
  export type ReviewReplyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply findFirst
   */
  export type ReviewReplyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReplies.
     */
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply findFirstOrThrow
   */
  export type ReviewReplyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReply to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ReviewReplies.
     */
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply findMany
   */
  export type ReviewReplyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter, which ReviewReplies to fetch.
     */
    where?: ReviewReplyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ReviewReplies to fetch.
     */
    orderBy?: ReviewReplyOrderByWithRelationInput | ReviewReplyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ReviewReplies.
     */
    cursor?: ReviewReplyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ReviewReplies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ReviewReplies.
     */
    skip?: number
    distinct?: ReviewReplyScalarFieldEnum | ReviewReplyScalarFieldEnum[]
  }

  /**
   * ReviewReply create
   */
  export type ReviewReplyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The data needed to create a ReviewReply.
     */
    data: XOR<ReviewReplyCreateInput, ReviewReplyUncheckedCreateInput>
  }

  /**
   * ReviewReply createMany
   */
  export type ReviewReplyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ReviewReplies.
     */
    data: ReviewReplyCreateManyInput | ReviewReplyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ReviewReply createManyAndReturn
   */
  export type ReviewReplyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * The data used to create many ReviewReplies.
     */
    data: ReviewReplyCreateManyInput | ReviewReplyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReply update
   */
  export type ReviewReplyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The data needed to update a ReviewReply.
     */
    data: XOR<ReviewReplyUpdateInput, ReviewReplyUncheckedUpdateInput>
    /**
     * Choose, which ReviewReply to update.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply updateMany
   */
  export type ReviewReplyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ReviewReplies.
     */
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReplies to update
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to update.
     */
    limit?: number
  }

  /**
   * ReviewReply updateManyAndReturn
   */
  export type ReviewReplyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * The data used to update ReviewReplies.
     */
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyInput>
    /**
     * Filter which ReviewReplies to update
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ReviewReply upsert
   */
  export type ReviewReplyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * The filter to search for the ReviewReply to update in case it exists.
     */
    where: ReviewReplyWhereUniqueInput
    /**
     * In case the ReviewReply found by the `where` argument doesn't exist, create a new ReviewReply with this data.
     */
    create: XOR<ReviewReplyCreateInput, ReviewReplyUncheckedCreateInput>
    /**
     * In case the ReviewReply was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReviewReplyUpdateInput, ReviewReplyUncheckedUpdateInput>
  }

  /**
   * ReviewReply delete
   */
  export type ReviewReplyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
    /**
     * Filter which ReviewReply to delete.
     */
    where: ReviewReplyWhereUniqueInput
  }

  /**
   * ReviewReply deleteMany
   */
  export type ReviewReplyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ReviewReplies to delete
     */
    where?: ReviewReplyWhereInput
    /**
     * Limit how many ReviewReplies to delete.
     */
    limit?: number
  }

  /**
   * ReviewReply without action
   */
  export type ReviewReplyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReviewReply
     */
    select?: ReviewReplySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ReviewReply
     */
    omit?: ReviewReplyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReviewReplyInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    actorId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    body: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    actorId: string | null
    type: $Enums.NotificationType | null
    title: string | null
    body: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    actorId: number
    type: number
    title: number
    body: number
    data: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    actorId?: true
    type?: true
    title?: true
    body?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    actorId?: true
    type?: true
    title?: true
    body?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    actorId?: true
    type?: true
    title?: true
    body?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    actorId: string | null
    type: $Enums.NotificationType
    title: string
    body: string
    data: JsonValue | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    createdAt?: boolean
    actor?: boolean | Notification$actorArgs<ExtArgs>
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    createdAt?: boolean
    actor?: boolean | Notification$actorArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    actorId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    createdAt?: boolean
    actor?: boolean | Notification$actorArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    actorId?: boolean
    type?: boolean
    title?: boolean
    body?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "actorId" | "type" | "title" | "body" | "data" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | Notification$actorArgs<ExtArgs>
    recipients?: boolean | Notification$recipientsArgs<ExtArgs>
    _count?: boolean | NotificationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | Notification$actorArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    actor?: boolean | Notification$actorArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      actor: Prisma.$AccountPayload<ExtArgs> | null
      recipients: Prisma.$NotificationRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      actorId: string | null
      type: $Enums.NotificationType
      title: string
      body: string
      data: Prisma.JsonValue | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    actor<T extends Notification$actorArgs<ExtArgs> = {}>(args?: Subset<T, Notification$actorArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recipients<T extends Notification$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Notification$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly actorId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly data: FieldRef<"Notification", 'Json'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification.actor
   */
  export type Notification$actorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
  }

  /**
   * Notification.recipients
   */
  export type Notification$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    cursor?: NotificationRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model NotificationRecipient
   */

  export type AggregateNotificationRecipient = {
    _count: NotificationRecipientCountAggregateOutputType | null
    _min: NotificationRecipientMinAggregateOutputType | null
    _max: NotificationRecipientMaxAggregateOutputType | null
  }

  export type NotificationRecipientMinAggregateOutputType = {
    id: string | null
    notificationId: string | null
    accountId: string | null
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationRecipientMaxAggregateOutputType = {
    id: string | null
    notificationId: string | null
    accountId: string | null
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type NotificationRecipientCountAggregateOutputType = {
    id: number
    notificationId: number
    accountId: number
    readAt: number
    deletedAt: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type NotificationRecipientMinAggregateInputType = {
    id?: true
    notificationId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationRecipientMaxAggregateInputType = {
    id?: true
    notificationId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
  }

  export type NotificationRecipientCountAggregateInputType = {
    id?: true
    notificationId?: true
    accountId?: true
    readAt?: true
    deletedAt?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type NotificationRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRecipient to aggregate.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NotificationRecipients
    **/
    _count?: true | NotificationRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationRecipientMaxAggregateInputType
  }

  export type GetNotificationRecipientAggregateType<T extends NotificationRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateNotificationRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotificationRecipient[P]>
      : GetScalarType<T[P], AggregateNotificationRecipient[P]>
  }




  export type NotificationRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationRecipientWhereInput
    orderBy?: NotificationRecipientOrderByWithAggregationInput | NotificationRecipientOrderByWithAggregationInput[]
    by: NotificationRecipientScalarFieldEnum[] | NotificationRecipientScalarFieldEnum
    having?: NotificationRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationRecipientCountAggregateInputType | true
    _min?: NotificationRecipientMinAggregateInputType
    _max?: NotificationRecipientMaxAggregateInputType
  }

  export type NotificationRecipientGroupByOutputType = {
    id: string
    notificationId: string
    accountId: string
    readAt: Date | null
    deletedAt: Date | null
    createdAt: Date
    updatedAt: Date
    _count: NotificationRecipientCountAggregateOutputType | null
    _min: NotificationRecipientMinAggregateOutputType | null
    _max: NotificationRecipientMaxAggregateOutputType | null
  }

  type GetNotificationRecipientGroupByPayload<T extends NotificationRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationRecipientGroupByOutputType[P]>
        }
      >
    >


  export type NotificationRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    notificationId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notificationRecipient"]>

  export type NotificationRecipientSelectScalar = {
    id?: boolean
    notificationId?: boolean
    accountId?: boolean
    readAt?: boolean
    deletedAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type NotificationRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "notificationId" | "accountId" | "readAt" | "deletedAt" | "createdAt" | "updatedAt", ExtArgs["result"]["notificationRecipient"]>
  export type NotificationRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type NotificationRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }
  export type NotificationRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    notification?: boolean | NotificationDefaultArgs<ExtArgs>
    account?: boolean | AccountDefaultArgs<ExtArgs>
  }

  export type $NotificationRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "NotificationRecipient"
    objects: {
      notification: Prisma.$NotificationPayload<ExtArgs>
      account: Prisma.$AccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      notificationId: string
      accountId: string
      readAt: Date | null
      deletedAt: Date | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["notificationRecipient"]>
    composites: {}
  }

  type NotificationRecipientGetPayload<S extends boolean | null | undefined | NotificationRecipientDefaultArgs> = $Result.GetResult<Prisma.$NotificationRecipientPayload, S>

  type NotificationRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationRecipientCountAggregateInputType | true
    }

  export interface NotificationRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['NotificationRecipient'], meta: { name: 'NotificationRecipient' } }
    /**
     * Find zero or one NotificationRecipient that matches the filter.
     * @param {NotificationRecipientFindUniqueArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationRecipientFindUniqueArgs>(args: SelectSubset<T, NotificationRecipientFindUniqueArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one NotificationRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationRecipientFindUniqueOrThrowArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindFirstArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationRecipientFindFirstArgs>(args?: SelectSubset<T, NotificationRecipientFindFirstArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first NotificationRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindFirstOrThrowArgs} args - Arguments to find a NotificationRecipient
     * @example
     * // Get one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more NotificationRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NotificationRecipients
     * const notificationRecipients = await prisma.notificationRecipient.findMany()
     * 
     * // Get first 10 NotificationRecipients
     * const notificationRecipients = await prisma.notificationRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationRecipientFindManyArgs>(args?: SelectSubset<T, NotificationRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a NotificationRecipient.
     * @param {NotificationRecipientCreateArgs} args - Arguments to create a NotificationRecipient.
     * @example
     * // Create one NotificationRecipient
     * const NotificationRecipient = await prisma.notificationRecipient.create({
     *   data: {
     *     // ... data to create a NotificationRecipient
     *   }
     * })
     * 
     */
    create<T extends NotificationRecipientCreateArgs>(args: SelectSubset<T, NotificationRecipientCreateArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many NotificationRecipients.
     * @param {NotificationRecipientCreateManyArgs} args - Arguments to create many NotificationRecipients.
     * @example
     * // Create many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationRecipientCreateManyArgs>(args?: SelectSubset<T, NotificationRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many NotificationRecipients and returns the data saved in the database.
     * @param {NotificationRecipientCreateManyAndReturnArgs} args - Arguments to create many NotificationRecipients.
     * @example
     * // Create many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many NotificationRecipients and only return the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a NotificationRecipient.
     * @param {NotificationRecipientDeleteArgs} args - Arguments to delete one NotificationRecipient.
     * @example
     * // Delete one NotificationRecipient
     * const NotificationRecipient = await prisma.notificationRecipient.delete({
     *   where: {
     *     // ... filter to delete one NotificationRecipient
     *   }
     * })
     * 
     */
    delete<T extends NotificationRecipientDeleteArgs>(args: SelectSubset<T, NotificationRecipientDeleteArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one NotificationRecipient.
     * @param {NotificationRecipientUpdateArgs} args - Arguments to update one NotificationRecipient.
     * @example
     * // Update one NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationRecipientUpdateArgs>(args: SelectSubset<T, NotificationRecipientUpdateArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more NotificationRecipients.
     * @param {NotificationRecipientDeleteManyArgs} args - Arguments to filter NotificationRecipients to delete.
     * @example
     * // Delete a few NotificationRecipients
     * const { count } = await prisma.notificationRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationRecipientDeleteManyArgs>(args?: SelectSubset<T, NotificationRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationRecipientUpdateManyArgs>(args: SelectSubset<T, NotificationRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more NotificationRecipients and returns the data updated in the database.
     * @param {NotificationRecipientUpdateManyAndReturnArgs} args - Arguments to update many NotificationRecipients.
     * @example
     * // Update many NotificationRecipients
     * const notificationRecipient = await prisma.notificationRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more NotificationRecipients and only return the `id`
     * const notificationRecipientWithIdOnly = await prisma.notificationRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one NotificationRecipient.
     * @param {NotificationRecipientUpsertArgs} args - Arguments to update or create a NotificationRecipient.
     * @example
     * // Update or create a NotificationRecipient
     * const notificationRecipient = await prisma.notificationRecipient.upsert({
     *   create: {
     *     // ... data to create a NotificationRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NotificationRecipient we want to update
     *   }
     * })
     */
    upsert<T extends NotificationRecipientUpsertArgs>(args: SelectSubset<T, NotificationRecipientUpsertArgs<ExtArgs>>): Prisma__NotificationRecipientClient<$Result.GetResult<Prisma.$NotificationRecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of NotificationRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientCountArgs} args - Arguments to filter NotificationRecipients to count.
     * @example
     * // Count the number of NotificationRecipients
     * const count = await prisma.notificationRecipient.count({
     *   where: {
     *     // ... the filter for the NotificationRecipients we want to count
     *   }
     * })
    **/
    count<T extends NotificationRecipientCountArgs>(
      args?: Subset<T, NotificationRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NotificationRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationRecipientAggregateArgs>(args: Subset<T, NotificationRecipientAggregateArgs>): Prisma.PrismaPromise<GetNotificationRecipientAggregateType<T>>

    /**
     * Group by NotificationRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationRecipientGroupByArgs['orderBy'] }
        : { orderBy?: NotificationRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the NotificationRecipient model
   */
  readonly fields: NotificationRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for NotificationRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    notification<T extends NotificationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NotificationDefaultArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    account<T extends AccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AccountDefaultArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the NotificationRecipient model
   */
  interface NotificationRecipientFieldRefs {
    readonly id: FieldRef<"NotificationRecipient", 'String'>
    readonly notificationId: FieldRef<"NotificationRecipient", 'String'>
    readonly accountId: FieldRef<"NotificationRecipient", 'String'>
    readonly readAt: FieldRef<"NotificationRecipient", 'DateTime'>
    readonly deletedAt: FieldRef<"NotificationRecipient", 'DateTime'>
    readonly createdAt: FieldRef<"NotificationRecipient", 'DateTime'>
    readonly updatedAt: FieldRef<"NotificationRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * NotificationRecipient findUnique
   */
  export type NotificationRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient findUniqueOrThrow
   */
  export type NotificationRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient findFirst
   */
  export type NotificationRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRecipients.
     */
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient findFirstOrThrow
   */
  export type NotificationRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipient to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NotificationRecipients.
     */
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient findMany
   */
  export type NotificationRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter, which NotificationRecipients to fetch.
     */
    where?: NotificationRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NotificationRecipients to fetch.
     */
    orderBy?: NotificationRecipientOrderByWithRelationInput | NotificationRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NotificationRecipients.
     */
    cursor?: NotificationRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NotificationRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NotificationRecipients.
     */
    skip?: number
    distinct?: NotificationRecipientScalarFieldEnum | NotificationRecipientScalarFieldEnum[]
  }

  /**
   * NotificationRecipient create
   */
  export type NotificationRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a NotificationRecipient.
     */
    data: XOR<NotificationRecipientCreateInput, NotificationRecipientUncheckedCreateInput>
  }

  /**
   * NotificationRecipient createMany
   */
  export type NotificationRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many NotificationRecipients.
     */
    data: NotificationRecipientCreateManyInput | NotificationRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * NotificationRecipient createManyAndReturn
   */
  export type NotificationRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many NotificationRecipients.
     */
    data: NotificationRecipientCreateManyInput | NotificationRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRecipient update
   */
  export type NotificationRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a NotificationRecipient.
     */
    data: XOR<NotificationRecipientUpdateInput, NotificationRecipientUncheckedUpdateInput>
    /**
     * Choose, which NotificationRecipient to update.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient updateMany
   */
  export type NotificationRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update NotificationRecipients.
     */
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRecipients to update
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to update.
     */
    limit?: number
  }

  /**
   * NotificationRecipient updateManyAndReturn
   */
  export type NotificationRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * The data used to update NotificationRecipients.
     */
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyInput>
    /**
     * Filter which NotificationRecipients to update
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * NotificationRecipient upsert
   */
  export type NotificationRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the NotificationRecipient to update in case it exists.
     */
    where: NotificationRecipientWhereUniqueInput
    /**
     * In case the NotificationRecipient found by the `where` argument doesn't exist, create a new NotificationRecipient with this data.
     */
    create: XOR<NotificationRecipientCreateInput, NotificationRecipientUncheckedCreateInput>
    /**
     * In case the NotificationRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationRecipientUpdateInput, NotificationRecipientUncheckedUpdateInput>
  }

  /**
   * NotificationRecipient delete
   */
  export type NotificationRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
    /**
     * Filter which NotificationRecipient to delete.
     */
    where: NotificationRecipientWhereUniqueInput
  }

  /**
   * NotificationRecipient deleteMany
   */
  export type NotificationRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which NotificationRecipients to delete
     */
    where?: NotificationRecipientWhereInput
    /**
     * Limit how many NotificationRecipients to delete.
     */
    limit?: number
  }

  /**
   * NotificationRecipient without action
   */
  export type NotificationRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the NotificationRecipient
     */
    select?: NotificationRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the NotificationRecipient
     */
    omit?: NotificationRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationRecipientInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const AccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email: 'email',
    password: 'password',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    status: 'status',
    verificationCode: 'verificationCode',
    verificationCodeExpiresAt: 'verificationCodeExpiresAt',
    passwordResetCode: 'passwordResetCode',
    passwordResetCodeExpiresAt: 'passwordResetCodeExpiresAt',
    provider: 'provider',
    providerId: 'providerId'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const DeviceTokenScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    token: 'token',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isActive: 'isActive',
    lastSeenAt: 'lastSeenAt'
  };

  export type DeviceTokenScalarFieldEnum = (typeof DeviceTokenScalarFieldEnum)[keyof typeof DeviceTokenScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    userName: 'userName',
    photo: 'photo',
    phone: 'phone',
    photoPublicId: 'photoPublicId',
    gender: 'gender',
    birthDate: 'birthDate',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    paymentMethods: 'paymentMethods'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AddressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    government: 'government',
    city: 'city',
    addressLine: 'addressLine',
    landmark: 'landmark',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AddressScalarFieldEnum = (typeof AddressScalarFieldEnum)[keyof typeof AddressScalarFieldEnum]


  export const BrandScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    description: 'description',
    logo: 'logo',
    categories: 'categories',
    status: 'status',
    instagramUrl: 'instagramUrl',
    tiktokUrl: 'tiktokUrl',
    businessPhone: 'businessPhone',
    ownerName: 'ownerName',
    ownerNationalId: 'ownerNationalId',
    ownerPhone: 'ownerPhone',
    crn: 'crn',
    taxId: 'taxId',
    paymentMethods: 'paymentMethods',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandScalarFieldEnum = (typeof BrandScalarFieldEnum)[keyof typeof BrandScalarFieldEnum]


  export const RefreshTokenScalarFieldEnum: {
    id: 'id',
    accountId: 'accountId',
    token: 'token',
    expiresAt: 'expiresAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    revokedAt: 'revokedAt',
    revokedReason: 'revokedReason',
    jti: 'jti'
  };

  export type RefreshTokenScalarFieldEnum = (typeof RefreshTokenScalarFieldEnum)[keyof typeof RefreshTokenScalarFieldEnum]


  export const PrivateConversationScalarFieldEnum: {
    id: 'id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    archivedAt: 'archivedAt'
  };

  export type PrivateConversationScalarFieldEnum = (typeof PrivateConversationScalarFieldEnum)[keyof typeof PrivateConversationScalarFieldEnum]


  export const PrivateConversationParticipantScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    accountId: 'accountId',
    unreadCount: 'unreadCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivateConversationParticipantScalarFieldEnum = (typeof PrivateConversationParticipantScalarFieldEnum)[keyof typeof PrivateConversationParticipantScalarFieldEnum]


  export const PrivateMessageScalarFieldEnum: {
    id: 'id',
    conversationId: 'conversationId',
    senderId: 'senderId',
    content: 'content',
    contentType: 'contentType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    reactionType: 'reactionType',
    reactedById: 'reactedById'
  };

  export type PrivateMessageScalarFieldEnum = (typeof PrivateMessageScalarFieldEnum)[keyof typeof PrivateMessageScalarFieldEnum]


  export const PrivateMessageAttachmentScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    url: 'url',
    mimeType: 'mimeType',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivateMessageAttachmentScalarFieldEnum = (typeof PrivateMessageAttachmentScalarFieldEnum)[keyof typeof PrivateMessageAttachmentScalarFieldEnum]


  export const PrivateMessageVisibilityScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    accountId: 'accountId',
    readAt: 'readAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PrivateMessageVisibilityScalarFieldEnum = (typeof PrivateMessageVisibilityScalarFieldEnum)[keyof typeof PrivateMessageVisibilityScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    brandId: 'brandId',
    category: 'category',
    title: 'title',
    slug: 'slug',
    description: 'description',
    attributes: 'attributes',
    status: 'status',
    material: 'material',
    avgRating: 'avgRating',
    ratingsCount: 'ratingsCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const ProductImageScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    url: 'url',
    altText: 'altText',
    meta: 'meta',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type ProductImageScalarFieldEnum = (typeof ProductImageScalarFieldEnum)[keyof typeof ProductImageScalarFieldEnum]


  export const ProductOptionScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    name: 'name',
    label: 'label',
    sortOrder: 'sortOrder'
  };

  export type ProductOptionScalarFieldEnum = (typeof ProductOptionScalarFieldEnum)[keyof typeof ProductOptionScalarFieldEnum]


  export const ProductOptionValueScalarFieldEnum: {
    id: 'id',
    productOptionId: 'productOptionId',
    value: 'value',
    label: 'label',
    colorHex: 'colorHex',
    sortOrder: 'sortOrder'
  };

  export type ProductOptionValueScalarFieldEnum = (typeof ProductOptionValueScalarFieldEnum)[keyof typeof ProductOptionValueScalarFieldEnum]


  export const VariantOptionScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    productOptionId: 'productOptionId',
    productOptionValueId: 'productOptionValueId'
  };

  export type VariantOptionScalarFieldEnum = (typeof VariantOptionScalarFieldEnum)[keyof typeof VariantOptionScalarFieldEnum]


  export const VariantScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    sku: 'sku',
    price: 'price',
    currency: 'currency',
    stock: 'stock',
    weight: 'weight',
    dimensions: 'dimensions',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariantScalarFieldEnum = (typeof VariantScalarFieldEnum)[keyof typeof VariantScalarFieldEnum]


  export const VariantImageScalarFieldEnum: {
    id: 'id',
    variantId: 'variantId',
    url: 'url',
    altText: 'altText',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type VariantImageScalarFieldEnum = (typeof VariantImageScalarFieldEnum)[keyof typeof VariantImageScalarFieldEnum]


  export const TagScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TagScalarFieldEnum = (typeof TagScalarFieldEnum)[keyof typeof TagScalarFieldEnum]


  export const ProductTagScalarFieldEnum: {
    productId: 'productId',
    tagId: 'tagId',
    pinned: 'pinned',
    addedAt: 'addedAt'
  };

  export type ProductTagScalarFieldEnum = (typeof ProductTagScalarFieldEnum)[keyof typeof ProductTagScalarFieldEnum]


  export const ProductImageEmbeddingScalarFieldEnum: {
    id: 'id',
    productImageId: 'productImageId',
    productId: 'productId',
    model: 'model',
    dim: 'dim',
    updatedAt: 'updatedAt'
  };

  export type ProductImageEmbeddingScalarFieldEnum = (typeof ProductImageEmbeddingScalarFieldEnum)[keyof typeof ProductImageEmbeddingScalarFieldEnum]


  export const ReviewScalarFieldEnum: {
    id: 'id',
    productId: 'productId',
    userId: 'userId',
    rating: 'rating',
    title: 'title',
    content: 'content',
    isVerified: 'isVerified',
    visibility: 'visibility',
    reported: 'reported',
    helpfulCount: 'helpfulCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewScalarFieldEnum = (typeof ReviewScalarFieldEnum)[keyof typeof ReviewScalarFieldEnum]


  export const ReviewImageScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    url: 'url',
    altText: 'altText',
    sortOrder: 'sortOrder',
    createdAt: 'createdAt'
  };

  export type ReviewImageScalarFieldEnum = (typeof ReviewImageScalarFieldEnum)[keyof typeof ReviewImageScalarFieldEnum]


  export const ReviewVoteScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    type: 'type',
    createdAt: 'createdAt'
  };

  export type ReviewVoteScalarFieldEnum = (typeof ReviewVoteScalarFieldEnum)[keyof typeof ReviewVoteScalarFieldEnum]


  export const ReviewReportScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    userId: 'userId',
    reason: 'reason',
    details: 'details',
    createdAt: 'createdAt'
  };

  export type ReviewReportScalarFieldEnum = (typeof ReviewReportScalarFieldEnum)[keyof typeof ReviewReportScalarFieldEnum]


  export const ReviewReplyScalarFieldEnum: {
    id: 'id',
    reviewId: 'reviewId',
    authorId: 'authorId',
    content: 'content',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ReviewReplyScalarFieldEnum = (typeof ReviewReplyScalarFieldEnum)[keyof typeof ReviewReplyScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    actorId: 'actorId',
    type: 'type',
    title: 'title',
    body: 'body',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const NotificationRecipientScalarFieldEnum: {
    id: 'id',
    notificationId: 'notificationId',
    accountId: 'accountId',
    readAt: 'readAt',
    deletedAt: 'deletedAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type NotificationRecipientScalarFieldEnum = (typeof NotificationRecipientScalarFieldEnum)[keyof typeof NotificationRecipientScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Status'
   */
  export type EnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status'>
    


  /**
   * Reference to a field of type 'Status[]'
   */
  export type ListEnumStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Status[]'>
    


  /**
   * Reference to a field of type 'Provider'
   */
  export type EnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider'>
    


  /**
   * Reference to a field of type 'Provider[]'
   */
  export type ListEnumProviderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Provider[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Gender'
   */
  export type EnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender'>
    


  /**
   * Reference to a field of type 'Gender[]'
   */
  export type ListEnumGenderFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Gender[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod[]'
   */
  export type ListEnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod[]'>
    


  /**
   * Reference to a field of type 'PaymentMethod'
   */
  export type EnumPaymentMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentMethod'>
    


  /**
   * Reference to a field of type 'Category[]'
   */
  export type ListEnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category[]'>
    


  /**
   * Reference to a field of type 'Category'
   */
  export type EnumCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Category'>
    


  /**
   * Reference to a field of type 'BrandStatus'
   */
  export type EnumBrandStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BrandStatus'>
    


  /**
   * Reference to a field of type 'BrandStatus[]'
   */
  export type ListEnumBrandStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BrandStatus[]'>
    


  /**
   * Reference to a field of type 'RevokedReason'
   */
  export type EnumRevokedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevokedReason'>
    


  /**
   * Reference to a field of type 'RevokedReason[]'
   */
  export type ListEnumRevokedReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RevokedReason[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'ContentType'
   */
  export type EnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType'>
    


  /**
   * Reference to a field of type 'ContentType[]'
   */
  export type ListEnumContentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ContentType[]'>
    


  /**
   * Reference to a field of type 'ReactionType'
   */
  export type EnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType'>
    


  /**
   * Reference to a field of type 'ReactionType[]'
   */
  export type ListEnumReactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReactionType[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'ProductStatus'
   */
  export type EnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus'>
    


  /**
   * Reference to a field of type 'ProductStatus[]'
   */
  export type ListEnumProductStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProductStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ReviewVisibility'
   */
  export type EnumReviewVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewVisibility'>
    


  /**
   * Reference to a field of type 'ReviewVisibility[]'
   */
  export type ListEnumReviewVisibilityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReviewVisibility[]'>
    


  /**
   * Reference to a field of type 'VoteType'
   */
  export type EnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType'>
    


  /**
   * Reference to a field of type 'VoteType[]'
   */
  export type ListEnumVoteTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VoteType[]'>
    


  /**
   * Reference to a field of type 'ReportReason'
   */
  export type EnumReportReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportReason'>
    


  /**
   * Reference to a field of type 'ReportReason[]'
   */
  export type ListEnumReportReasonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ReportReason[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    name?: StringFilter<"Account"> | string
    email?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    role?: EnumRoleFilter<"Account"> | $Enums.Role
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    status?: EnumStatusFilter<"Account"> | $Enums.Status
    verificationCode?: StringNullableFilter<"Account"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    passwordResetCode?: StringNullableFilter<"Account"> | string | null
    passwordResetCodeExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    provider?: EnumProviderFilter<"Account"> | $Enums.Provider
    providerId?: StringNullableFilter<"Account"> | string | null
    refreshTokens?: RefreshTokenListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    ConversationParticipant?: PrivateConversationParticipantListRelationFilter
    sentPrivateMessages?: PrivateMessageListRelationFilter
    reactedMessages?: PrivateMessageListRelationFilter
    privateMessageVisibilities?: PrivateMessageVisibilityListRelationFilter
    Notification?: NotificationListRelationFilter
    NotificationRecipient?: NotificationRecipientListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationCodeExpiresAt?: SortOrderInput | SortOrder
    passwordResetCode?: SortOrderInput | SortOrder
    passwordResetCodeExpiresAt?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    refreshTokens?: RefreshTokenOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    brand?: BrandOrderByWithRelationInput
    ConversationParticipant?: PrivateConversationParticipantOrderByRelationAggregateInput
    sentPrivateMessages?: PrivateMessageOrderByRelationAggregateInput
    reactedMessages?: PrivateMessageOrderByRelationAggregateInput
    privateMessageVisibilities?: PrivateMessageVisibilityOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    NotificationRecipient?: NotificationRecipientOrderByRelationAggregateInput
    deviceTokens?: DeviceTokenOrderByRelationAggregateInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    provider_providerId?: AccountProviderProviderIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    name?: StringFilter<"Account"> | string
    password?: StringFilter<"Account"> | string
    role?: EnumRoleFilter<"Account"> | $Enums.Role
    createdAt?: DateTimeFilter<"Account"> | Date | string
    updatedAt?: DateTimeFilter<"Account"> | Date | string
    status?: EnumStatusFilter<"Account"> | $Enums.Status
    verificationCode?: StringNullableFilter<"Account"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    passwordResetCode?: StringNullableFilter<"Account"> | string | null
    passwordResetCodeExpiresAt?: DateTimeNullableFilter<"Account"> | Date | string | null
    provider?: EnumProviderFilter<"Account"> | $Enums.Provider
    providerId?: StringNullableFilter<"Account"> | string | null
    refreshTokens?: RefreshTokenListRelationFilter
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    brand?: XOR<BrandNullableScalarRelationFilter, BrandWhereInput> | null
    ConversationParticipant?: PrivateConversationParticipantListRelationFilter
    sentPrivateMessages?: PrivateMessageListRelationFilter
    reactedMessages?: PrivateMessageListRelationFilter
    privateMessageVisibilities?: PrivateMessageVisibilityListRelationFilter
    Notification?: NotificationListRelationFilter
    NotificationRecipient?: NotificationRecipientListRelationFilter
    deviceTokens?: DeviceTokenListRelationFilter
  }, "id" | "email" | "provider_providerId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    verificationCode?: SortOrderInput | SortOrder
    verificationCodeExpiresAt?: SortOrderInput | SortOrder
    passwordResetCode?: SortOrderInput | SortOrder
    passwordResetCodeExpiresAt?: SortOrderInput | SortOrder
    provider?: SortOrder
    providerId?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    name?: StringWithAggregatesFilter<"Account"> | string
    email?: StringWithAggregatesFilter<"Account"> | string
    password?: StringWithAggregatesFilter<"Account"> | string
    role?: EnumRoleWithAggregatesFilter<"Account"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Account"> | Date | string
    status?: EnumStatusWithAggregatesFilter<"Account"> | $Enums.Status
    verificationCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    verificationCodeExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    passwordResetCode?: StringNullableWithAggregatesFilter<"Account"> | string | null
    passwordResetCodeExpiresAt?: DateTimeNullableWithAggregatesFilter<"Account"> | Date | string | null
    provider?: EnumProviderWithAggregatesFilter<"Account"> | $Enums.Provider
    providerId?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type DeviceTokenWhereInput = {
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    accountId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    lastSeenAt?: DateTimeFilter<"DeviceToken"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type DeviceTokenOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    lastSeenAt?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type DeviceTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    OR?: DeviceTokenWhereInput[]
    NOT?: DeviceTokenWhereInput | DeviceTokenWhereInput[]
    accountId?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    lastSeenAt?: DateTimeFilter<"DeviceToken"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "token">

  export type DeviceTokenOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    lastSeenAt?: SortOrder
    _count?: DeviceTokenCountOrderByAggregateInput
    _max?: DeviceTokenMaxOrderByAggregateInput
    _min?: DeviceTokenMinOrderByAggregateInput
  }

  export type DeviceTokenScalarWhereWithAggregatesInput = {
    AND?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    OR?: DeviceTokenScalarWhereWithAggregatesInput[]
    NOT?: DeviceTokenScalarWhereWithAggregatesInput | DeviceTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DeviceToken"> | string
    accountId?: StringWithAggregatesFilter<"DeviceToken"> | string
    token?: StringWithAggregatesFilter<"DeviceToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
    isActive?: BoolWithAggregatesFilter<"DeviceToken"> | boolean
    lastSeenAt?: DateTimeWithAggregatesFilter<"DeviceToken"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    accountId?: StringFilter<"User"> | string
    userName?: StringFilter<"User"> | string
    photo?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    photoPublicId?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    paymentMethods?: EnumPaymentMethodNullableListFilter<"User">
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    addresses?: AddressListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    reviewReports?: ReviewReportListRelationFilter
    reviewReplays?: ReviewReplyListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userName?: SortOrder
    photo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethods?: SortOrder
    account?: AccountOrderByWithRelationInput
    addresses?: AddressOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    reviewVotes?: ReviewVoteOrderByRelationAggregateInput
    reviewReports?: ReviewReportOrderByRelationAggregateInput
    reviewReplays?: ReviewReplyOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    userName?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    photo?: StringNullableFilter<"User"> | string | null
    phone?: StringNullableFilter<"User"> | string | null
    photoPublicId?: StringNullableFilter<"User"> | string | null
    gender?: EnumGenderNullableFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableFilter<"User"> | Date | string | null
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    paymentMethods?: EnumPaymentMethodNullableListFilter<"User">
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    addresses?: AddressListRelationFilter
    reviews?: ReviewListRelationFilter
    reviewVotes?: ReviewVoteListRelationFilter
    reviewReports?: ReviewReportListRelationFilter
    reviewReplays?: ReviewReplyListRelationFilter
  }, "id" | "accountId" | "userName">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    userName?: SortOrder
    photo?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photoPublicId?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    birthDate?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethods?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    accountId?: StringWithAggregatesFilter<"User"> | string
    userName?: StringWithAggregatesFilter<"User"> | string
    photo?: StringNullableWithAggregatesFilter<"User"> | string | null
    phone?: StringNullableWithAggregatesFilter<"User"> | string | null
    photoPublicId?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: EnumGenderNullableWithAggregatesFilter<"User"> | $Enums.Gender | null
    birthDate?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    paymentMethods?: EnumPaymentMethodNullableListFilter<"User">
  }

  export type AddressWhereInput = {
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    id?: StringFilter<"Address"> | string
    userId?: StringFilter<"Address"> | string
    government?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    addressLine?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AddressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    government?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    addressLine?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AddressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AddressWhereInput | AddressWhereInput[]
    OR?: AddressWhereInput[]
    NOT?: AddressWhereInput | AddressWhereInput[]
    userId?: StringFilter<"Address"> | string
    government?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    addressLine?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type AddressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    government?: SortOrderInput | SortOrder
    city?: SortOrderInput | SortOrder
    addressLine?: SortOrderInput | SortOrder
    landmark?: SortOrderInput | SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AddressCountOrderByAggregateInput
    _max?: AddressMaxOrderByAggregateInput
    _min?: AddressMinOrderByAggregateInput
  }

  export type AddressScalarWhereWithAggregatesInput = {
    AND?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    OR?: AddressScalarWhereWithAggregatesInput[]
    NOT?: AddressScalarWhereWithAggregatesInput | AddressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Address"> | string
    userId?: StringWithAggregatesFilter<"Address"> | string
    government?: StringNullableWithAggregatesFilter<"Address"> | string | null
    city?: StringNullableWithAggregatesFilter<"Address"> | string | null
    addressLine?: StringNullableWithAggregatesFilter<"Address"> | string | null
    landmark?: StringNullableWithAggregatesFilter<"Address"> | string | null
    isPrimary?: BoolWithAggregatesFilter<"Address"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Address"> | Date | string
  }

  export type BrandWhereInput = {
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    id?: StringFilter<"Brand"> | string
    accountId?: StringFilter<"Brand"> | string
    description?: StringNullableFilter<"Brand"> | string | null
    logo?: StringNullableFilter<"Brand"> | string | null
    categories?: EnumCategoryNullableListFilter<"Brand">
    status?: EnumBrandStatusFilter<"Brand"> | $Enums.BrandStatus
    instagramUrl?: StringNullableFilter<"Brand"> | string | null
    tiktokUrl?: StringNullableFilter<"Brand"> | string | null
    businessPhone?: StringNullableFilter<"Brand"> | string | null
    ownerName?: StringNullableFilter<"Brand"> | string | null
    ownerNationalId?: StringNullableFilter<"Brand"> | string | null
    ownerPhone?: StringNullableFilter<"Brand"> | string | null
    crn?: StringNullableFilter<"Brand"> | string | null
    taxId?: StringNullableFilter<"Brand"> | string | null
    paymentMethods?: EnumPaymentMethodNullableListFilter<"Brand">
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    Products?: ProductListRelationFilter
  }

  export type BrandOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    categories?: SortOrder
    status?: SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    tiktokUrl?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerNationalId?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    crn?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    account?: AccountOrderByWithRelationInput
    Products?: ProductOrderByRelationAggregateInput
  }

  export type BrandWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    accountId?: string
    AND?: BrandWhereInput | BrandWhereInput[]
    OR?: BrandWhereInput[]
    NOT?: BrandWhereInput | BrandWhereInput[]
    description?: StringNullableFilter<"Brand"> | string | null
    logo?: StringNullableFilter<"Brand"> | string | null
    categories?: EnumCategoryNullableListFilter<"Brand">
    status?: EnumBrandStatusFilter<"Brand"> | $Enums.BrandStatus
    instagramUrl?: StringNullableFilter<"Brand"> | string | null
    tiktokUrl?: StringNullableFilter<"Brand"> | string | null
    businessPhone?: StringNullableFilter<"Brand"> | string | null
    ownerName?: StringNullableFilter<"Brand"> | string | null
    ownerNationalId?: StringNullableFilter<"Brand"> | string | null
    ownerPhone?: StringNullableFilter<"Brand"> | string | null
    crn?: StringNullableFilter<"Brand"> | string | null
    taxId?: StringNullableFilter<"Brand"> | string | null
    paymentMethods?: EnumPaymentMethodNullableListFilter<"Brand">
    createdAt?: DateTimeFilter<"Brand"> | Date | string
    updatedAt?: DateTimeFilter<"Brand"> | Date | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    Products?: ProductListRelationFilter
  }, "id" | "accountId">

  export type BrandOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    description?: SortOrderInput | SortOrder
    logo?: SortOrderInput | SortOrder
    categories?: SortOrder
    status?: SortOrder
    instagramUrl?: SortOrderInput | SortOrder
    tiktokUrl?: SortOrderInput | SortOrder
    businessPhone?: SortOrderInput | SortOrder
    ownerName?: SortOrderInput | SortOrder
    ownerNationalId?: SortOrderInput | SortOrder
    ownerPhone?: SortOrderInput | SortOrder
    crn?: SortOrderInput | SortOrder
    taxId?: SortOrderInput | SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BrandCountOrderByAggregateInput
    _max?: BrandMaxOrderByAggregateInput
    _min?: BrandMinOrderByAggregateInput
  }

  export type BrandScalarWhereWithAggregatesInput = {
    AND?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    OR?: BrandScalarWhereWithAggregatesInput[]
    NOT?: BrandScalarWhereWithAggregatesInput | BrandScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Brand"> | string
    accountId?: StringWithAggregatesFilter<"Brand"> | string
    description?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    logo?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    categories?: EnumCategoryNullableListFilter<"Brand">
    status?: EnumBrandStatusWithAggregatesFilter<"Brand"> | $Enums.BrandStatus
    instagramUrl?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    tiktokUrl?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    businessPhone?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    ownerName?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    ownerNationalId?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    ownerPhone?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    crn?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    taxId?: StringNullableWithAggregatesFilter<"Brand"> | string | null
    paymentMethods?: EnumPaymentMethodNullableListFilter<"Brand">
    createdAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Brand"> | Date | string
  }

  export type RefreshTokenWhereInput = {
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    accountId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revokedReason?: EnumRevokedReasonNullableFilter<"RefreshToken"> | $Enums.RevokedReason | null
    jti?: StringFilter<"RefreshToken"> | string
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type RefreshTokenOrderByWithRelationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    jti?: SortOrder
    account?: AccountOrderByWithRelationInput
  }

  export type RefreshTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    jti?: string
    AND?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    OR?: RefreshTokenWhereInput[]
    NOT?: RefreshTokenWhereInput | RefreshTokenWhereInput[]
    accountId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revokedReason?: EnumRevokedReasonNullableFilter<"RefreshToken"> | $Enums.RevokedReason | null
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "jti">

  export type RefreshTokenOrderByWithAggregationInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrderInput | SortOrder
    revokedReason?: SortOrderInput | SortOrder
    jti?: SortOrder
    _count?: RefreshTokenCountOrderByAggregateInput
    _max?: RefreshTokenMaxOrderByAggregateInput
    _min?: RefreshTokenMinOrderByAggregateInput
  }

  export type RefreshTokenScalarWhereWithAggregatesInput = {
    AND?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    OR?: RefreshTokenScalarWhereWithAggregatesInput[]
    NOT?: RefreshTokenScalarWhereWithAggregatesInput | RefreshTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RefreshToken"> | string
    accountId?: StringWithAggregatesFilter<"RefreshToken"> | string
    token?: StringWithAggregatesFilter<"RefreshToken"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableWithAggregatesFilter<"RefreshToken"> | Date | string | null
    revokedReason?: EnumRevokedReasonNullableWithAggregatesFilter<"RefreshToken"> | $Enums.RevokedReason | null
    jti?: StringWithAggregatesFilter<"RefreshToken"> | string
  }

  export type PrivateConversationWhereInput = {
    AND?: PrivateConversationWhereInput | PrivateConversationWhereInput[]
    OR?: PrivateConversationWhereInput[]
    NOT?: PrivateConversationWhereInput | PrivateConversationWhereInput[]
    id?: StringFilter<"PrivateConversation"> | string
    createdAt?: DateTimeFilter<"PrivateConversation"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateConversation"> | Date | string
    archivedAt?: DateTimeNullableFilter<"PrivateConversation"> | Date | string | null
    participants?: PrivateConversationParticipantListRelationFilter
    messages?: PrivateMessageListRelationFilter
  }

  export type PrivateConversationOrderByWithRelationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    participants?: PrivateConversationParticipantOrderByRelationAggregateInput
    messages?: PrivateMessageOrderByRelationAggregateInput
  }

  export type PrivateConversationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivateConversationWhereInput | PrivateConversationWhereInput[]
    OR?: PrivateConversationWhereInput[]
    NOT?: PrivateConversationWhereInput | PrivateConversationWhereInput[]
    createdAt?: DateTimeFilter<"PrivateConversation"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateConversation"> | Date | string
    archivedAt?: DateTimeNullableFilter<"PrivateConversation"> | Date | string | null
    participants?: PrivateConversationParticipantListRelationFilter
    messages?: PrivateMessageListRelationFilter
  }, "id">

  export type PrivateConversationOrderByWithAggregationInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrderInput | SortOrder
    _count?: PrivateConversationCountOrderByAggregateInput
    _max?: PrivateConversationMaxOrderByAggregateInput
    _min?: PrivateConversationMinOrderByAggregateInput
  }

  export type PrivateConversationScalarWhereWithAggregatesInput = {
    AND?: PrivateConversationScalarWhereWithAggregatesInput | PrivateConversationScalarWhereWithAggregatesInput[]
    OR?: PrivateConversationScalarWhereWithAggregatesInput[]
    NOT?: PrivateConversationScalarWhereWithAggregatesInput | PrivateConversationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateConversation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"PrivateConversation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateConversation"> | Date | string
    archivedAt?: DateTimeNullableWithAggregatesFilter<"PrivateConversation"> | Date | string | null
  }

  export type PrivateConversationParticipantWhereInput = {
    AND?: PrivateConversationParticipantWhereInput | PrivateConversationParticipantWhereInput[]
    OR?: PrivateConversationParticipantWhereInput[]
    NOT?: PrivateConversationParticipantWhereInput | PrivateConversationParticipantWhereInput[]
    id?: StringFilter<"PrivateConversationParticipant"> | string
    conversationId?: StringFilter<"PrivateConversationParticipant"> | string
    accountId?: StringFilter<"PrivateConversationParticipant"> | string
    unreadCount?: IntFilter<"PrivateConversationParticipant"> | number
    createdAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
    conversation?: XOR<PrivateConversationScalarRelationFilter, PrivateConversationWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type PrivateConversationParticipantOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    accountId?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    conversation?: PrivateConversationOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type PrivateConversationParticipantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    conversationId_accountId?: PrivateConversationParticipantConversationIdAccountIdCompoundUniqueInput
    AND?: PrivateConversationParticipantWhereInput | PrivateConversationParticipantWhereInput[]
    OR?: PrivateConversationParticipantWhereInput[]
    NOT?: PrivateConversationParticipantWhereInput | PrivateConversationParticipantWhereInput[]
    conversationId?: StringFilter<"PrivateConversationParticipant"> | string
    accountId?: StringFilter<"PrivateConversationParticipant"> | string
    unreadCount?: IntFilter<"PrivateConversationParticipant"> | number
    createdAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
    conversation?: XOR<PrivateConversationScalarRelationFilter, PrivateConversationWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "conversationId_accountId">

  export type PrivateConversationParticipantOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    accountId?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivateConversationParticipantCountOrderByAggregateInput
    _avg?: PrivateConversationParticipantAvgOrderByAggregateInput
    _max?: PrivateConversationParticipantMaxOrderByAggregateInput
    _min?: PrivateConversationParticipantMinOrderByAggregateInput
    _sum?: PrivateConversationParticipantSumOrderByAggregateInput
  }

  export type PrivateConversationParticipantScalarWhereWithAggregatesInput = {
    AND?: PrivateConversationParticipantScalarWhereWithAggregatesInput | PrivateConversationParticipantScalarWhereWithAggregatesInput[]
    OR?: PrivateConversationParticipantScalarWhereWithAggregatesInput[]
    NOT?: PrivateConversationParticipantScalarWhereWithAggregatesInput | PrivateConversationParticipantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateConversationParticipant"> | string
    conversationId?: StringWithAggregatesFilter<"PrivateConversationParticipant"> | string
    accountId?: StringWithAggregatesFilter<"PrivateConversationParticipant"> | string
    unreadCount?: IntWithAggregatesFilter<"PrivateConversationParticipant"> | number
    createdAt?: DateTimeWithAggregatesFilter<"PrivateConversationParticipant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateConversationParticipant"> | Date | string
  }

  export type PrivateMessageWhereInput = {
    AND?: PrivateMessageWhereInput | PrivateMessageWhereInput[]
    OR?: PrivateMessageWhereInput[]
    NOT?: PrivateMessageWhereInput | PrivateMessageWhereInput[]
    id?: StringFilter<"PrivateMessage"> | string
    conversationId?: StringFilter<"PrivateMessage"> | string
    senderId?: StringFilter<"PrivateMessage"> | string
    content?: StringFilter<"PrivateMessage"> | string
    contentType?: EnumContentTypeFilter<"PrivateMessage"> | $Enums.ContentType
    createdAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PrivateMessage"> | Date | string | null
    reactionType?: EnumReactionTypeNullableFilter<"PrivateMessage"> | $Enums.ReactionType | null
    reactedById?: StringNullableFilter<"PrivateMessage"> | string | null
    conversation?: XOR<PrivateConversationScalarRelationFilter, PrivateConversationWhereInput>
    sender?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    attachments?: PrivateMessageAttachmentListRelationFilter
    reactedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    visibilities?: PrivateMessageVisibilityListRelationFilter
  }

  export type PrivateMessageOrderByWithRelationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    reactionType?: SortOrderInput | SortOrder
    reactedById?: SortOrderInput | SortOrder
    conversation?: PrivateConversationOrderByWithRelationInput
    sender?: AccountOrderByWithRelationInput
    attachments?: PrivateMessageAttachmentOrderByRelationAggregateInput
    reactedBy?: AccountOrderByWithRelationInput
    visibilities?: PrivateMessageVisibilityOrderByRelationAggregateInput
  }

  export type PrivateMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivateMessageWhereInput | PrivateMessageWhereInput[]
    OR?: PrivateMessageWhereInput[]
    NOT?: PrivateMessageWhereInput | PrivateMessageWhereInput[]
    conversationId?: StringFilter<"PrivateMessage"> | string
    senderId?: StringFilter<"PrivateMessage"> | string
    content?: StringFilter<"PrivateMessage"> | string
    contentType?: EnumContentTypeFilter<"PrivateMessage"> | $Enums.ContentType
    createdAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PrivateMessage"> | Date | string | null
    reactionType?: EnumReactionTypeNullableFilter<"PrivateMessage"> | $Enums.ReactionType | null
    reactedById?: StringNullableFilter<"PrivateMessage"> | string | null
    conversation?: XOR<PrivateConversationScalarRelationFilter, PrivateConversationWhereInput>
    sender?: XOR<AccountScalarRelationFilter, AccountWhereInput>
    attachments?: PrivateMessageAttachmentListRelationFilter
    reactedBy?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    visibilities?: PrivateMessageVisibilityListRelationFilter
  }, "id">

  export type PrivateMessageOrderByWithAggregationInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    reactionType?: SortOrderInput | SortOrder
    reactedById?: SortOrderInput | SortOrder
    _count?: PrivateMessageCountOrderByAggregateInput
    _max?: PrivateMessageMaxOrderByAggregateInput
    _min?: PrivateMessageMinOrderByAggregateInput
  }

  export type PrivateMessageScalarWhereWithAggregatesInput = {
    AND?: PrivateMessageScalarWhereWithAggregatesInput | PrivateMessageScalarWhereWithAggregatesInput[]
    OR?: PrivateMessageScalarWhereWithAggregatesInput[]
    NOT?: PrivateMessageScalarWhereWithAggregatesInput | PrivateMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateMessage"> | string
    conversationId?: StringWithAggregatesFilter<"PrivateMessage"> | string
    senderId?: StringWithAggregatesFilter<"PrivateMessage"> | string
    content?: StringWithAggregatesFilter<"PrivateMessage"> | string
    contentType?: EnumContentTypeWithAggregatesFilter<"PrivateMessage"> | $Enums.ContentType
    createdAt?: DateTimeWithAggregatesFilter<"PrivateMessage"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateMessage"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PrivateMessage"> | Date | string | null
    reactionType?: EnumReactionTypeNullableWithAggregatesFilter<"PrivateMessage"> | $Enums.ReactionType | null
    reactedById?: StringNullableWithAggregatesFilter<"PrivateMessage"> | string | null
  }

  export type PrivateMessageAttachmentWhereInput = {
    AND?: PrivateMessageAttachmentWhereInput | PrivateMessageAttachmentWhereInput[]
    OR?: PrivateMessageAttachmentWhereInput[]
    NOT?: PrivateMessageAttachmentWhereInput | PrivateMessageAttachmentWhereInput[]
    id?: StringFilter<"PrivateMessageAttachment"> | string
    messageId?: StringFilter<"PrivateMessageAttachment"> | string
    url?: StringFilter<"PrivateMessageAttachment"> | string
    mimeType?: StringNullableFilter<"PrivateMessageAttachment"> | string | null
    createdAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
    message?: XOR<PrivateMessageScalarRelationFilter, PrivateMessageWhereInput>
  }

  export type PrivateMessageAttachmentOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: PrivateMessageOrderByWithRelationInput
  }

  export type PrivateMessageAttachmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PrivateMessageAttachmentWhereInput | PrivateMessageAttachmentWhereInput[]
    OR?: PrivateMessageAttachmentWhereInput[]
    NOT?: PrivateMessageAttachmentWhereInput | PrivateMessageAttachmentWhereInput[]
    messageId?: StringFilter<"PrivateMessageAttachment"> | string
    url?: StringFilter<"PrivateMessageAttachment"> | string
    mimeType?: StringNullableFilter<"PrivateMessageAttachment"> | string | null
    createdAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
    message?: XOR<PrivateMessageScalarRelationFilter, PrivateMessageWhereInput>
  }, "id">

  export type PrivateMessageAttachmentOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivateMessageAttachmentCountOrderByAggregateInput
    _max?: PrivateMessageAttachmentMaxOrderByAggregateInput
    _min?: PrivateMessageAttachmentMinOrderByAggregateInput
  }

  export type PrivateMessageAttachmentScalarWhereWithAggregatesInput = {
    AND?: PrivateMessageAttachmentScalarWhereWithAggregatesInput | PrivateMessageAttachmentScalarWhereWithAggregatesInput[]
    OR?: PrivateMessageAttachmentScalarWhereWithAggregatesInput[]
    NOT?: PrivateMessageAttachmentScalarWhereWithAggregatesInput | PrivateMessageAttachmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateMessageAttachment"> | string
    messageId?: StringWithAggregatesFilter<"PrivateMessageAttachment"> | string
    url?: StringWithAggregatesFilter<"PrivateMessageAttachment"> | string
    mimeType?: StringNullableWithAggregatesFilter<"PrivateMessageAttachment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrivateMessageAttachment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateMessageAttachment"> | Date | string
  }

  export type PrivateMessageVisibilityWhereInput = {
    AND?: PrivateMessageVisibilityWhereInput | PrivateMessageVisibilityWhereInput[]
    OR?: PrivateMessageVisibilityWhereInput[]
    NOT?: PrivateMessageVisibilityWhereInput | PrivateMessageVisibilityWhereInput[]
    id?: StringFilter<"PrivateMessageVisibility"> | string
    messageId?: StringFilter<"PrivateMessageVisibility"> | string
    accountId?: StringFilter<"PrivateMessageVisibility"> | string
    readAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    createdAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
    message?: XOR<PrivateMessageScalarRelationFilter, PrivateMessageWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type PrivateMessageVisibilityOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    message?: PrivateMessageOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type PrivateMessageVisibilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_accountId?: PrivateMessageVisibilityMessageIdAccountIdCompoundUniqueInput
    AND?: PrivateMessageVisibilityWhereInput | PrivateMessageVisibilityWhereInput[]
    OR?: PrivateMessageVisibilityWhereInput[]
    NOT?: PrivateMessageVisibilityWhereInput | PrivateMessageVisibilityWhereInput[]
    messageId?: StringFilter<"PrivateMessageVisibility"> | string
    accountId?: StringFilter<"PrivateMessageVisibility"> | string
    readAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    createdAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
    message?: XOR<PrivateMessageScalarRelationFilter, PrivateMessageWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "messageId_accountId">

  export type PrivateMessageVisibilityOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PrivateMessageVisibilityCountOrderByAggregateInput
    _max?: PrivateMessageVisibilityMaxOrderByAggregateInput
    _min?: PrivateMessageVisibilityMinOrderByAggregateInput
  }

  export type PrivateMessageVisibilityScalarWhereWithAggregatesInput = {
    AND?: PrivateMessageVisibilityScalarWhereWithAggregatesInput | PrivateMessageVisibilityScalarWhereWithAggregatesInput[]
    OR?: PrivateMessageVisibilityScalarWhereWithAggregatesInput[]
    NOT?: PrivateMessageVisibilityScalarWhereWithAggregatesInput | PrivateMessageVisibilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PrivateMessageVisibility"> | string
    messageId?: StringWithAggregatesFilter<"PrivateMessageVisibility"> | string
    accountId?: StringWithAggregatesFilter<"PrivateMessageVisibility"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"PrivateMessageVisibility"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PrivateMessageVisibility"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PrivateMessageVisibility"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PrivateMessageVisibility"> | Date | string
  }

  export type ProductWhereInput = {
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    id?: StringFilter<"Product"> | string
    brandId?: StringFilter<"Product"> | string
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attributes?: JsonNullableFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    material?: StringNullableFilter<"Product"> | string | null
    avgRating?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    images?: ProductImageListRelationFilter
    variants?: VariantListRelationFilter
    options?: ProductOptionListRelationFilter
    tags?: ProductTagListRelationFilter
    reviews?: ReviewListRelationFilter
    imageVectors?: ProductImageEmbeddingListRelationFilter
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    brandId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    status?: SortOrder
    material?: SortOrderInput | SortOrder
    avgRating?: SortOrder
    ratingsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: BrandOrderByWithRelationInput
    images?: ProductImageOrderByRelationAggregateInput
    variants?: VariantOrderByRelationAggregateInput
    options?: ProductOptionOrderByRelationAggregateInput
    tags?: ProductTagOrderByRelationAggregateInput
    reviews?: ReviewOrderByRelationAggregateInput
    imageVectors?: ProductImageEmbeddingOrderByRelationAggregateInput
  }

  export type ProductWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    brandId_slug?: ProductBrandIdSlugCompoundUniqueInput
    AND?: ProductWhereInput | ProductWhereInput[]
    OR?: ProductWhereInput[]
    NOT?: ProductWhereInput | ProductWhereInput[]
    brandId?: StringFilter<"Product"> | string
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attributes?: JsonNullableFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    material?: StringNullableFilter<"Product"> | string | null
    avgRating?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
    brand?: XOR<BrandScalarRelationFilter, BrandWhereInput>
    images?: ProductImageListRelationFilter
    variants?: VariantListRelationFilter
    options?: ProductOptionListRelationFilter
    tags?: ProductTagListRelationFilter
    reviews?: ReviewListRelationFilter
    imageVectors?: ProductImageEmbeddingListRelationFilter
  }, "id" | "brandId_slug">

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    brandId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    attributes?: SortOrderInput | SortOrder
    status?: SortOrder
    material?: SortOrderInput | SortOrder
    avgRating?: SortOrder
    ratingsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    OR?: ProductScalarWhereWithAggregatesInput[]
    NOT?: ProductScalarWhereWithAggregatesInput | ProductScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Product"> | string
    brandId?: StringWithAggregatesFilter<"Product"> | string
    category?: EnumCategoryWithAggregatesFilter<"Product"> | $Enums.Category
    title?: StringWithAggregatesFilter<"Product"> | string
    slug?: StringWithAggregatesFilter<"Product"> | string
    description?: StringNullableWithAggregatesFilter<"Product"> | string | null
    attributes?: JsonNullableWithAggregatesFilter<"Product">
    status?: EnumProductStatusWithAggregatesFilter<"Product"> | $Enums.ProductStatus
    material?: StringNullableWithAggregatesFilter<"Product"> | string | null
    avgRating?: DecimalWithAggregatesFilter<"Product"> | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntWithAggregatesFilter<"Product"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Product"> | Date | string
  }

  export type ProductImageWhereInput = {
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    altText?: StringNullableFilter<"ProductImage"> | string | null
    meta?: JsonNullableFilter<"ProductImage">
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    embedding?: XOR<ProductImageEmbeddingNullableScalarRelationFilter, ProductImageEmbeddingWhereInput> | null
  }

  export type ProductImageOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    embedding?: ProductImageEmbeddingOrderByWithRelationInput
  }

  export type ProductImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_sortOrder?: ProductImageProductIdSortOrderCompoundUniqueInput
    AND?: ProductImageWhereInput | ProductImageWhereInput[]
    OR?: ProductImageWhereInput[]
    NOT?: ProductImageWhereInput | ProductImageWhereInput[]
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    altText?: StringNullableFilter<"ProductImage"> | string | null
    meta?: JsonNullableFilter<"ProductImage">
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    embedding?: XOR<ProductImageEmbeddingNullableScalarRelationFilter, ProductImageEmbeddingWhereInput> | null
  }, "id" | "productId_sortOrder">

  export type ProductImageOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    meta?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: ProductImageCountOrderByAggregateInput
    _avg?: ProductImageAvgOrderByAggregateInput
    _max?: ProductImageMaxOrderByAggregateInput
    _min?: ProductImageMinOrderByAggregateInput
    _sum?: ProductImageSumOrderByAggregateInput
  }

  export type ProductImageScalarWhereWithAggregatesInput = {
    AND?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    OR?: ProductImageScalarWhereWithAggregatesInput[]
    NOT?: ProductImageScalarWhereWithAggregatesInput | ProductImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductImage"> | string
    productId?: StringWithAggregatesFilter<"ProductImage"> | string
    url?: StringWithAggregatesFilter<"ProductImage"> | string
    altText?: StringNullableWithAggregatesFilter<"ProductImage"> | string | null
    meta?: JsonNullableWithAggregatesFilter<"ProductImage">
    sortOrder?: IntWithAggregatesFilter<"ProductImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProductImage"> | Date | string
  }

  export type ProductOptionWhereInput = {
    AND?: ProductOptionWhereInput | ProductOptionWhereInput[]
    OR?: ProductOptionWhereInput[]
    NOT?: ProductOptionWhereInput | ProductOptionWhereInput[]
    id?: StringFilter<"ProductOption"> | string
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    label?: StringNullableFilter<"ProductOption"> | string | null
    sortOrder?: IntFilter<"ProductOption"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    values?: ProductOptionValueListRelationFilter
    VariantOption?: VariantOptionListRelationFilter
  }

  export type ProductOptionOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    product?: ProductOrderByWithRelationInput
    values?: ProductOptionValueOrderByRelationAggregateInput
    VariantOption?: VariantOptionOrderByRelationAggregateInput
  }

  export type ProductOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_name?: ProductOptionProductIdNameCompoundUniqueInput
    AND?: ProductOptionWhereInput | ProductOptionWhereInput[]
    OR?: ProductOptionWhereInput[]
    NOT?: ProductOptionWhereInput | ProductOptionWhereInput[]
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    label?: StringNullableFilter<"ProductOption"> | string | null
    sortOrder?: IntFilter<"ProductOption"> | number
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    values?: ProductOptionValueListRelationFilter
    VariantOption?: VariantOptionListRelationFilter
  }, "id" | "productId_name">

  export type ProductOptionOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    label?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    _count?: ProductOptionCountOrderByAggregateInput
    _avg?: ProductOptionAvgOrderByAggregateInput
    _max?: ProductOptionMaxOrderByAggregateInput
    _min?: ProductOptionMinOrderByAggregateInput
    _sum?: ProductOptionSumOrderByAggregateInput
  }

  export type ProductOptionScalarWhereWithAggregatesInput = {
    AND?: ProductOptionScalarWhereWithAggregatesInput | ProductOptionScalarWhereWithAggregatesInput[]
    OR?: ProductOptionScalarWhereWithAggregatesInput[]
    NOT?: ProductOptionScalarWhereWithAggregatesInput | ProductOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductOption"> | string
    productId?: StringWithAggregatesFilter<"ProductOption"> | string
    name?: StringWithAggregatesFilter<"ProductOption"> | string
    label?: StringNullableWithAggregatesFilter<"ProductOption"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ProductOption"> | number
  }

  export type ProductOptionValueWhereInput = {
    AND?: ProductOptionValueWhereInput | ProductOptionValueWhereInput[]
    OR?: ProductOptionValueWhereInput[]
    NOT?: ProductOptionValueWhereInput | ProductOptionValueWhereInput[]
    id?: StringFilter<"ProductOptionValue"> | string
    productOptionId?: StringFilter<"ProductOptionValue"> | string
    value?: StringFilter<"ProductOptionValue"> | string
    label?: StringNullableFilter<"ProductOptionValue"> | string | null
    colorHex?: StringNullableFilter<"ProductOptionValue"> | string | null
    sortOrder?: IntFilter<"ProductOptionValue"> | number
    option?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
    variantLinks?: VariantOptionListRelationFilter
  }

  export type ProductOptionValueOrderByWithRelationInput = {
    id?: SortOrder
    productOptionId?: SortOrder
    value?: SortOrder
    label?: SortOrderInput | SortOrder
    colorHex?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    option?: ProductOptionOrderByWithRelationInput
    variantLinks?: VariantOptionOrderByRelationAggregateInput
  }

  export type ProductOptionValueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productOptionId_value?: ProductOptionValueProductOptionIdValueCompoundUniqueInput
    AND?: ProductOptionValueWhereInput | ProductOptionValueWhereInput[]
    OR?: ProductOptionValueWhereInput[]
    NOT?: ProductOptionValueWhereInput | ProductOptionValueWhereInput[]
    productOptionId?: StringFilter<"ProductOptionValue"> | string
    value?: StringFilter<"ProductOptionValue"> | string
    label?: StringNullableFilter<"ProductOptionValue"> | string | null
    colorHex?: StringNullableFilter<"ProductOptionValue"> | string | null
    sortOrder?: IntFilter<"ProductOptionValue"> | number
    option?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
    variantLinks?: VariantOptionListRelationFilter
  }, "id" | "productOptionId_value">

  export type ProductOptionValueOrderByWithAggregationInput = {
    id?: SortOrder
    productOptionId?: SortOrder
    value?: SortOrder
    label?: SortOrderInput | SortOrder
    colorHex?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    _count?: ProductOptionValueCountOrderByAggregateInput
    _avg?: ProductOptionValueAvgOrderByAggregateInput
    _max?: ProductOptionValueMaxOrderByAggregateInput
    _min?: ProductOptionValueMinOrderByAggregateInput
    _sum?: ProductOptionValueSumOrderByAggregateInput
  }

  export type ProductOptionValueScalarWhereWithAggregatesInput = {
    AND?: ProductOptionValueScalarWhereWithAggregatesInput | ProductOptionValueScalarWhereWithAggregatesInput[]
    OR?: ProductOptionValueScalarWhereWithAggregatesInput[]
    NOT?: ProductOptionValueScalarWhereWithAggregatesInput | ProductOptionValueScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductOptionValue"> | string
    productOptionId?: StringWithAggregatesFilter<"ProductOptionValue"> | string
    value?: StringWithAggregatesFilter<"ProductOptionValue"> | string
    label?: StringNullableWithAggregatesFilter<"ProductOptionValue"> | string | null
    colorHex?: StringNullableWithAggregatesFilter<"ProductOptionValue"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ProductOptionValue"> | number
  }

  export type VariantOptionWhereInput = {
    AND?: VariantOptionWhereInput | VariantOptionWhereInput[]
    OR?: VariantOptionWhereInput[]
    NOT?: VariantOptionWhereInput | VariantOptionWhereInput[]
    id?: StringFilter<"VariantOption"> | string
    variantId?: StringFilter<"VariantOption"> | string
    productOptionId?: StringFilter<"VariantOption"> | string
    productOptionValueId?: StringFilter<"VariantOption"> | string
    variant?: XOR<VariantScalarRelationFilter, VariantWhereInput>
    option?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
    value?: XOR<ProductOptionValueScalarRelationFilter, ProductOptionValueWhereInput>
  }

  export type VariantOptionOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    productOptionId?: SortOrder
    productOptionValueId?: SortOrder
    variant?: VariantOrderByWithRelationInput
    option?: ProductOptionOrderByWithRelationInput
    value?: ProductOptionValueOrderByWithRelationInput
  }

  export type VariantOptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variantId_productOptionId?: VariantOptionVariantIdProductOptionIdCompoundUniqueInput
    AND?: VariantOptionWhereInput | VariantOptionWhereInput[]
    OR?: VariantOptionWhereInput[]
    NOT?: VariantOptionWhereInput | VariantOptionWhereInput[]
    variantId?: StringFilter<"VariantOption"> | string
    productOptionId?: StringFilter<"VariantOption"> | string
    productOptionValueId?: StringFilter<"VariantOption"> | string
    variant?: XOR<VariantScalarRelationFilter, VariantWhereInput>
    option?: XOR<ProductOptionScalarRelationFilter, ProductOptionWhereInput>
    value?: XOR<ProductOptionValueScalarRelationFilter, ProductOptionValueWhereInput>
  }, "id" | "variantId_productOptionId">

  export type VariantOptionOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    productOptionId?: SortOrder
    productOptionValueId?: SortOrder
    _count?: VariantOptionCountOrderByAggregateInput
    _max?: VariantOptionMaxOrderByAggregateInput
    _min?: VariantOptionMinOrderByAggregateInput
  }

  export type VariantOptionScalarWhereWithAggregatesInput = {
    AND?: VariantOptionScalarWhereWithAggregatesInput | VariantOptionScalarWhereWithAggregatesInput[]
    OR?: VariantOptionScalarWhereWithAggregatesInput[]
    NOT?: VariantOptionScalarWhereWithAggregatesInput | VariantOptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariantOption"> | string
    variantId?: StringWithAggregatesFilter<"VariantOption"> | string
    productOptionId?: StringWithAggregatesFilter<"VariantOption"> | string
    productOptionValueId?: StringWithAggregatesFilter<"VariantOption"> | string
  }

  export type VariantWhereInput = {
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    id?: StringFilter<"Variant"> | string
    productId?: StringFilter<"Variant"> | string
    sku?: StringFilter<"Variant"> | string
    price?: DecimalFilter<"Variant"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Variant"> | string
    stock?: IntFilter<"Variant"> | number
    weight?: DecimalNullableFilter<"Variant"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Variant">
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: VariantImageListRelationFilter
    options?: VariantOptionListRelationFilter
  }

  export type VariantOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    images?: VariantImageOrderByRelationAggregateInput
    options?: VariantOptionOrderByRelationAggregateInput
  }

  export type VariantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_sku?: VariantProductIdSkuCompoundUniqueInput
    AND?: VariantWhereInput | VariantWhereInput[]
    OR?: VariantWhereInput[]
    NOT?: VariantWhereInput | VariantWhereInput[]
    productId?: StringFilter<"Variant"> | string
    sku?: StringFilter<"Variant"> | string
    price?: DecimalFilter<"Variant"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Variant"> | string
    stock?: IntFilter<"Variant"> | number
    weight?: DecimalNullableFilter<"Variant"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Variant">
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    images?: VariantImageListRelationFilter
    options?: VariantOptionListRelationFilter
  }, "id" | "productId_sku">

  export type VariantOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    weight?: SortOrderInput | SortOrder
    dimensions?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: VariantCountOrderByAggregateInput
    _avg?: VariantAvgOrderByAggregateInput
    _max?: VariantMaxOrderByAggregateInput
    _min?: VariantMinOrderByAggregateInput
    _sum?: VariantSumOrderByAggregateInput
  }

  export type VariantScalarWhereWithAggregatesInput = {
    AND?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    OR?: VariantScalarWhereWithAggregatesInput[]
    NOT?: VariantScalarWhereWithAggregatesInput | VariantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Variant"> | string
    productId?: StringWithAggregatesFilter<"Variant"> | string
    sku?: StringWithAggregatesFilter<"Variant"> | string
    price?: DecimalWithAggregatesFilter<"Variant"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Variant"> | string
    stock?: IntWithAggregatesFilter<"Variant"> | number
    weight?: DecimalNullableWithAggregatesFilter<"Variant"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableWithAggregatesFilter<"Variant">
    createdAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Variant"> | Date | string
  }

  export type VariantImageWhereInput = {
    AND?: VariantImageWhereInput | VariantImageWhereInput[]
    OR?: VariantImageWhereInput[]
    NOT?: VariantImageWhereInput | VariantImageWhereInput[]
    id?: StringFilter<"VariantImage"> | string
    variantId?: StringFilter<"VariantImage"> | string
    url?: StringFilter<"VariantImage"> | string
    altText?: StringNullableFilter<"VariantImage"> | string | null
    sortOrder?: IntFilter<"VariantImage"> | number
    createdAt?: DateTimeFilter<"VariantImage"> | Date | string
    variant?: XOR<VariantScalarRelationFilter, VariantWhereInput>
  }

  export type VariantImageOrderByWithRelationInput = {
    id?: SortOrder
    variantId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    variant?: VariantOrderByWithRelationInput
  }

  export type VariantImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    variantId_sortOrder?: VariantImageVariantIdSortOrderCompoundUniqueInput
    AND?: VariantImageWhereInput | VariantImageWhereInput[]
    OR?: VariantImageWhereInput[]
    NOT?: VariantImageWhereInput | VariantImageWhereInput[]
    variantId?: StringFilter<"VariantImage"> | string
    url?: StringFilter<"VariantImage"> | string
    altText?: StringNullableFilter<"VariantImage"> | string | null
    sortOrder?: IntFilter<"VariantImage"> | number
    createdAt?: DateTimeFilter<"VariantImage"> | Date | string
    variant?: XOR<VariantScalarRelationFilter, VariantWhereInput>
  }, "id" | "variantId_sortOrder">

  export type VariantImageOrderByWithAggregationInput = {
    id?: SortOrder
    variantId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: VariantImageCountOrderByAggregateInput
    _avg?: VariantImageAvgOrderByAggregateInput
    _max?: VariantImageMaxOrderByAggregateInput
    _min?: VariantImageMinOrderByAggregateInput
    _sum?: VariantImageSumOrderByAggregateInput
  }

  export type VariantImageScalarWhereWithAggregatesInput = {
    AND?: VariantImageScalarWhereWithAggregatesInput | VariantImageScalarWhereWithAggregatesInput[]
    OR?: VariantImageScalarWhereWithAggregatesInput[]
    NOT?: VariantImageScalarWhereWithAggregatesInput | VariantImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VariantImage"> | string
    variantId?: StringWithAggregatesFilter<"VariantImage"> | string
    url?: StringWithAggregatesFilter<"VariantImage"> | string
    altText?: StringNullableWithAggregatesFilter<"VariantImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"VariantImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"VariantImage"> | Date | string
  }

  export type TagWhereInput = {
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    id?: StringFilter<"Tag"> | string
    name?: StringFilter<"Tag"> | string
    slug?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    products?: ProductTagListRelationFilter
  }

  export type TagOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    products?: ProductTagOrderByRelationAggregateInput
  }

  export type TagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TagWhereInput | TagWhereInput[]
    OR?: TagWhereInput[]
    NOT?: TagWhereInput | TagWhereInput[]
    name?: StringFilter<"Tag"> | string
    createdAt?: DateTimeFilter<"Tag"> | Date | string
    updatedAt?: DateTimeFilter<"Tag"> | Date | string
    products?: ProductTagListRelationFilter
  }, "id" | "slug">

  export type TagOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TagCountOrderByAggregateInput
    _max?: TagMaxOrderByAggregateInput
    _min?: TagMinOrderByAggregateInput
  }

  export type TagScalarWhereWithAggregatesInput = {
    AND?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    OR?: TagScalarWhereWithAggregatesInput[]
    NOT?: TagScalarWhereWithAggregatesInput | TagScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tag"> | string
    name?: StringWithAggregatesFilter<"Tag"> | string
    slug?: StringWithAggregatesFilter<"Tag"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tag"> | Date | string
  }

  export type ProductTagWhereInput = {
    AND?: ProductTagWhereInput | ProductTagWhereInput[]
    OR?: ProductTagWhereInput[]
    NOT?: ProductTagWhereInput | ProductTagWhereInput[]
    productId?: StringFilter<"ProductTag"> | string
    tagId?: StringFilter<"ProductTag"> | string
    pinned?: BoolFilter<"ProductTag"> | boolean
    addedAt?: DateTimeFilter<"ProductTag"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }

  export type ProductTagOrderByWithRelationInput = {
    productId?: SortOrder
    tagId?: SortOrder
    pinned?: SortOrder
    addedAt?: SortOrder
    product?: ProductOrderByWithRelationInput
    tag?: TagOrderByWithRelationInput
  }

  export type ProductTagWhereUniqueInput = Prisma.AtLeast<{
    productId_tagId?: ProductTagProductIdTagIdCompoundUniqueInput
    AND?: ProductTagWhereInput | ProductTagWhereInput[]
    OR?: ProductTagWhereInput[]
    NOT?: ProductTagWhereInput | ProductTagWhereInput[]
    productId?: StringFilter<"ProductTag"> | string
    tagId?: StringFilter<"ProductTag"> | string
    pinned?: BoolFilter<"ProductTag"> | boolean
    addedAt?: DateTimeFilter<"ProductTag"> | Date | string
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
    tag?: XOR<TagScalarRelationFilter, TagWhereInput>
  }, "productId_tagId">

  export type ProductTagOrderByWithAggregationInput = {
    productId?: SortOrder
    tagId?: SortOrder
    pinned?: SortOrder
    addedAt?: SortOrder
    _count?: ProductTagCountOrderByAggregateInput
    _max?: ProductTagMaxOrderByAggregateInput
    _min?: ProductTagMinOrderByAggregateInput
  }

  export type ProductTagScalarWhereWithAggregatesInput = {
    AND?: ProductTagScalarWhereWithAggregatesInput | ProductTagScalarWhereWithAggregatesInput[]
    OR?: ProductTagScalarWhereWithAggregatesInput[]
    NOT?: ProductTagScalarWhereWithAggregatesInput | ProductTagScalarWhereWithAggregatesInput[]
    productId?: StringWithAggregatesFilter<"ProductTag"> | string
    tagId?: StringWithAggregatesFilter<"ProductTag"> | string
    pinned?: BoolWithAggregatesFilter<"ProductTag"> | boolean
    addedAt?: DateTimeWithAggregatesFilter<"ProductTag"> | Date | string
  }

  export type ProductImageEmbeddingWhereInput = {
    AND?: ProductImageEmbeddingWhereInput | ProductImageEmbeddingWhereInput[]
    OR?: ProductImageEmbeddingWhereInput[]
    NOT?: ProductImageEmbeddingWhereInput | ProductImageEmbeddingWhereInput[]
    id?: StringFilter<"ProductImageEmbedding"> | string
    productImageId?: StringFilter<"ProductImageEmbedding"> | string
    productId?: StringFilter<"ProductImageEmbedding"> | string
    model?: StringFilter<"ProductImageEmbedding"> | string
    dim?: IntFilter<"ProductImageEmbedding"> | number
    updatedAt?: DateTimeFilter<"ProductImageEmbedding"> | Date | string
    image?: XOR<ProductImageScalarRelationFilter, ProductImageWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ProductImageEmbeddingOrderByWithRelationInput = {
    id?: SortOrder
    productImageId?: SortOrder
    productId?: SortOrder
    model?: SortOrder
    dim?: SortOrder
    updatedAt?: SortOrder
    image?: ProductImageOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ProductImageEmbeddingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productImageId?: string
    AND?: ProductImageEmbeddingWhereInput | ProductImageEmbeddingWhereInput[]
    OR?: ProductImageEmbeddingWhereInput[]
    NOT?: ProductImageEmbeddingWhereInput | ProductImageEmbeddingWhereInput[]
    productId?: StringFilter<"ProductImageEmbedding"> | string
    model?: StringFilter<"ProductImageEmbedding"> | string
    dim?: IntFilter<"ProductImageEmbedding"> | number
    updatedAt?: DateTimeFilter<"ProductImageEmbedding"> | Date | string
    image?: XOR<ProductImageScalarRelationFilter, ProductImageWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productImageId">

  export type ProductImageEmbeddingOrderByWithAggregationInput = {
    id?: SortOrder
    productImageId?: SortOrder
    productId?: SortOrder
    model?: SortOrder
    dim?: SortOrder
    updatedAt?: SortOrder
    _count?: ProductImageEmbeddingCountOrderByAggregateInput
    _avg?: ProductImageEmbeddingAvgOrderByAggregateInput
    _max?: ProductImageEmbeddingMaxOrderByAggregateInput
    _min?: ProductImageEmbeddingMinOrderByAggregateInput
    _sum?: ProductImageEmbeddingSumOrderByAggregateInput
  }

  export type ProductImageEmbeddingScalarWhereWithAggregatesInput = {
    AND?: ProductImageEmbeddingScalarWhereWithAggregatesInput | ProductImageEmbeddingScalarWhereWithAggregatesInput[]
    OR?: ProductImageEmbeddingScalarWhereWithAggregatesInput[]
    NOT?: ProductImageEmbeddingScalarWhereWithAggregatesInput | ProductImageEmbeddingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProductImageEmbedding"> | string
    productImageId?: StringWithAggregatesFilter<"ProductImageEmbedding"> | string
    productId?: StringWithAggregatesFilter<"ProductImageEmbedding"> | string
    model?: StringWithAggregatesFilter<"ProductImageEmbedding"> | string
    dim?: IntWithAggregatesFilter<"ProductImageEmbedding"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"ProductImageEmbedding"> | Date | string
  }

  export type ReviewWhereInput = {
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    id?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: FloatFilter<"Review"> | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    isVerified?: BoolFilter<"Review"> | boolean
    visibility?: EnumReviewVisibilityFilter<"Review"> | $Enums.ReviewVisibility
    reported?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    images?: ReviewImageListRelationFilter
    votes?: ReviewVoteListRelationFilter
    reports?: ReviewReportListRelationFilter
    replies?: ReviewReplyListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }

  export type ReviewOrderByWithRelationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isVerified?: SortOrder
    visibility?: SortOrder
    reported?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    images?: ReviewImageOrderByRelationAggregateInput
    votes?: ReviewVoteOrderByRelationAggregateInput
    reports?: ReviewReportOrderByRelationAggregateInput
    replies?: ReviewReplyOrderByRelationAggregateInput
    user?: UserOrderByWithRelationInput
    product?: ProductOrderByWithRelationInput
  }

  export type ReviewWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    productId_userId?: ReviewProductIdUserIdCompoundUniqueInput
    AND?: ReviewWhereInput | ReviewWhereInput[]
    OR?: ReviewWhereInput[]
    NOT?: ReviewWhereInput | ReviewWhereInput[]
    productId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: FloatFilter<"Review"> | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    isVerified?: BoolFilter<"Review"> | boolean
    visibility?: EnumReviewVisibilityFilter<"Review"> | $Enums.ReviewVisibility
    reported?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
    images?: ReviewImageListRelationFilter
    votes?: ReviewVoteListRelationFilter
    reports?: ReviewReportListRelationFilter
    replies?: ReviewReplyListRelationFilter
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    product?: XOR<ProductScalarRelationFilter, ProductWhereInput>
  }, "id" | "productId_userId">

  export type ReviewOrderByWithAggregationInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isVerified?: SortOrder
    visibility?: SortOrder
    reported?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewCountOrderByAggregateInput
    _avg?: ReviewAvgOrderByAggregateInput
    _max?: ReviewMaxOrderByAggregateInput
    _min?: ReviewMinOrderByAggregateInput
    _sum?: ReviewSumOrderByAggregateInput
  }

  export type ReviewScalarWhereWithAggregatesInput = {
    AND?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    OR?: ReviewScalarWhereWithAggregatesInput[]
    NOT?: ReviewScalarWhereWithAggregatesInput | ReviewScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Review"> | string
    productId?: StringWithAggregatesFilter<"Review"> | string
    userId?: StringWithAggregatesFilter<"Review"> | string
    rating?: FloatWithAggregatesFilter<"Review"> | number
    title?: StringWithAggregatesFilter<"Review"> | string
    content?: StringWithAggregatesFilter<"Review"> | string
    isVerified?: BoolWithAggregatesFilter<"Review"> | boolean
    visibility?: EnumReviewVisibilityWithAggregatesFilter<"Review"> | $Enums.ReviewVisibility
    reported?: BoolWithAggregatesFilter<"Review"> | boolean
    helpfulCount?: IntWithAggregatesFilter<"Review"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Review"> | Date | string
  }

  export type ReviewImageWhereInput = {
    AND?: ReviewImageWhereInput | ReviewImageWhereInput[]
    OR?: ReviewImageWhereInput[]
    NOT?: ReviewImageWhereInput | ReviewImageWhereInput[]
    id?: StringFilter<"ReviewImage"> | string
    reviewId?: StringFilter<"ReviewImage"> | string
    url?: StringFilter<"ReviewImage"> | string
    altText?: StringNullableFilter<"ReviewImage"> | string | null
    sortOrder?: IntFilter<"ReviewImage"> | number
    createdAt?: DateTimeFilter<"ReviewImage"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }

  export type ReviewImageOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
  }

  export type ReviewImageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewImageWhereInput | ReviewImageWhereInput[]
    OR?: ReviewImageWhereInput[]
    NOT?: ReviewImageWhereInput | ReviewImageWhereInput[]
    reviewId?: StringFilter<"ReviewImage"> | string
    url?: StringFilter<"ReviewImage"> | string
    altText?: StringNullableFilter<"ReviewImage"> | string | null
    sortOrder?: IntFilter<"ReviewImage"> | number
    createdAt?: DateTimeFilter<"ReviewImage"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
  }, "id">

  export type ReviewImageOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    url?: SortOrder
    altText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewImageCountOrderByAggregateInput
    _avg?: ReviewImageAvgOrderByAggregateInput
    _max?: ReviewImageMaxOrderByAggregateInput
    _min?: ReviewImageMinOrderByAggregateInput
    _sum?: ReviewImageSumOrderByAggregateInput
  }

  export type ReviewImageScalarWhereWithAggregatesInput = {
    AND?: ReviewImageScalarWhereWithAggregatesInput | ReviewImageScalarWhereWithAggregatesInput[]
    OR?: ReviewImageScalarWhereWithAggregatesInput[]
    NOT?: ReviewImageScalarWhereWithAggregatesInput | ReviewImageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewImage"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewImage"> | string
    url?: StringWithAggregatesFilter<"ReviewImage"> | string
    altText?: StringNullableWithAggregatesFilter<"ReviewImage"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ReviewImage"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ReviewImage"> | Date | string
  }

  export type ReviewVoteWhereInput = {
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    type?: EnumVoteTypeFilter<"ReviewVote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewVoteOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewVoteWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    reviewId_userId?: ReviewVoteReviewIdUserIdCompoundUniqueInput
    AND?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    OR?: ReviewVoteWhereInput[]
    NOT?: ReviewVoteWhereInput | ReviewVoteWhereInput[]
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    type?: EnumVoteTypeFilter<"ReviewVote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "reviewId_userId">

  export type ReviewVoteOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
    _count?: ReviewVoteCountOrderByAggregateInput
    _max?: ReviewVoteMaxOrderByAggregateInput
    _min?: ReviewVoteMinOrderByAggregateInput
  }

  export type ReviewVoteScalarWhereWithAggregatesInput = {
    AND?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    OR?: ReviewVoteScalarWhereWithAggregatesInput[]
    NOT?: ReviewVoteScalarWhereWithAggregatesInput | ReviewVoteScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewVote"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewVote"> | string
    userId?: StringWithAggregatesFilter<"ReviewVote"> | string
    type?: EnumVoteTypeWithAggregatesFilter<"ReviewVote"> | $Enums.VoteType
    createdAt?: DateTimeWithAggregatesFilter<"ReviewVote"> | Date | string
  }

  export type ReviewReportWhereInput = {
    AND?: ReviewReportWhereInput | ReviewReportWhereInput[]
    OR?: ReviewReportWhereInput[]
    NOT?: ReviewReportWhereInput | ReviewReportWhereInput[]
    id?: StringFilter<"ReviewReport"> | string
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: EnumReportReasonFilter<"ReviewReport"> | $Enums.ReportReason
    details?: StringNullableFilter<"ReviewReport"> | string | null
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewReportOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type ReviewReportWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewReportWhereInput | ReviewReportWhereInput[]
    OR?: ReviewReportWhereInput[]
    NOT?: ReviewReportWhereInput | ReviewReportWhereInput[]
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: EnumReportReasonFilter<"ReviewReport"> | $Enums.ReportReason
    details?: StringNullableFilter<"ReviewReport"> | string | null
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewReportOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    details?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ReviewReportCountOrderByAggregateInput
    _max?: ReviewReportMaxOrderByAggregateInput
    _min?: ReviewReportMinOrderByAggregateInput
  }

  export type ReviewReportScalarWhereWithAggregatesInput = {
    AND?: ReviewReportScalarWhereWithAggregatesInput | ReviewReportScalarWhereWithAggregatesInput[]
    OR?: ReviewReportScalarWhereWithAggregatesInput[]
    NOT?: ReviewReportScalarWhereWithAggregatesInput | ReviewReportScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewReport"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewReport"> | string
    userId?: StringWithAggregatesFilter<"ReviewReport"> | string
    reason?: EnumReportReasonWithAggregatesFilter<"ReviewReport"> | $Enums.ReportReason
    details?: StringNullableWithAggregatesFilter<"ReviewReport"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ReviewReport"> | Date | string
  }

  export type ReviewReplyWhereInput = {
    AND?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    OR?: ReviewReplyWhereInput[]
    NOT?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    id?: StringFilter<"ReviewReply"> | string
    reviewId?: StringFilter<"ReviewReply"> | string
    authorId?: StringFilter<"ReviewReply"> | string
    content?: StringFilter<"ReviewReply"> | string
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ReviewReplyOrderByWithRelationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    review?: ReviewOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ReviewReplyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    OR?: ReviewReplyWhereInput[]
    NOT?: ReviewReplyWhereInput | ReviewReplyWhereInput[]
    reviewId?: StringFilter<"ReviewReply"> | string
    authorId?: StringFilter<"ReviewReply"> | string
    content?: StringFilter<"ReviewReply"> | string
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
    review?: XOR<ReviewScalarRelationFilter, ReviewWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ReviewReplyOrderByWithAggregationInput = {
    id?: SortOrder
    reviewId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ReviewReplyCountOrderByAggregateInput
    _max?: ReviewReplyMaxOrderByAggregateInput
    _min?: ReviewReplyMinOrderByAggregateInput
  }

  export type ReviewReplyScalarWhereWithAggregatesInput = {
    AND?: ReviewReplyScalarWhereWithAggregatesInput | ReviewReplyScalarWhereWithAggregatesInput[]
    OR?: ReviewReplyScalarWhereWithAggregatesInput[]
    NOT?: ReviewReplyScalarWhereWithAggregatesInput | ReviewReplyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ReviewReply"> | string
    reviewId?: StringWithAggregatesFilter<"ReviewReply"> | string
    authorId?: StringWithAggregatesFilter<"ReviewReply"> | string
    content?: StringWithAggregatesFilter<"ReviewReply"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ReviewReply"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    actorId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    actor?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    recipients?: NotificationRecipientListRelationFilter
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    actor?: AccountOrderByWithRelationInput
    recipients?: NotificationRecipientOrderByRelationAggregateInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    actorId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    actor?: XOR<AccountNullableScalarRelationFilter, AccountWhereInput> | null
    recipients?: NotificationRecipientListRelationFilter
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    actorId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    actorId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    data?: JsonNullableWithAggregatesFilter<"Notification">
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type NotificationRecipientWhereInput = {
    AND?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    OR?: NotificationRecipientWhereInput[]
    NOT?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    id?: StringFilter<"NotificationRecipient"> | string
    notificationId?: StringFilter<"NotificationRecipient"> | string
    accountId?: StringFilter<"NotificationRecipient"> | string
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }

  export type NotificationRecipientOrderByWithRelationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    notification?: NotificationOrderByWithRelationInput
    account?: AccountOrderByWithRelationInput
  }

  export type NotificationRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    notificationId_accountId?: NotificationRecipientNotificationIdAccountIdCompoundUniqueInput
    AND?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    OR?: NotificationRecipientWhereInput[]
    NOT?: NotificationRecipientWhereInput | NotificationRecipientWhereInput[]
    notificationId?: StringFilter<"NotificationRecipient"> | string
    accountId?: StringFilter<"NotificationRecipient"> | string
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    notification?: XOR<NotificationScalarRelationFilter, NotificationWhereInput>
    account?: XOR<AccountScalarRelationFilter, AccountWhereInput>
  }, "id" | "notificationId_accountId">

  export type NotificationRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    notificationId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrderInput | SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: NotificationRecipientCountOrderByAggregateInput
    _max?: NotificationRecipientMaxOrderByAggregateInput
    _min?: NotificationRecipientMinOrderByAggregateInput
  }

  export type NotificationRecipientScalarWhereWithAggregatesInput = {
    AND?: NotificationRecipientScalarWhereWithAggregatesInput | NotificationRecipientScalarWhereWithAggregatesInput[]
    OR?: NotificationRecipientScalarWhereWithAggregatesInput[]
    NOT?: NotificationRecipientScalarWhereWithAggregatesInput | NotificationRecipientScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    notificationId?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    accountId?: StringWithAggregatesFilter<"NotificationRecipient"> | string
    readAt?: DateTimeNullableWithAggregatesFilter<"NotificationRecipient"> | Date | string | null
    deletedAt?: DateTimeNullableWithAggregatesFilter<"NotificationRecipient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"NotificationRecipient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"NotificationRecipient"> | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateManyInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type DeviceTokenCreateInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
    account: AccountCreateNestedOneWithoutDeviceTokensInput
  }

  export type DeviceTokenUncheckedCreateInput = {
    id?: string
    accountId: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
  }

  export type DeviceTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutDeviceTokensNestedInput
  }

  export type DeviceTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenCreateManyInput = {
    id?: string
    accountId: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
  }

  export type DeviceTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
  }

  export type AddressCreateInput = {
    id?: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutAddressesInput
  }

  export type AddressUncheckedCreateInput = {
    id?: string
    userId: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAddressesNestedInput
  }

  export type AddressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyInput = {
    id?: string
    userId: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandCreateInput = {
    id?: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutBrandInput
    Products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateInput = {
    id?: string
    accountId: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutBrandNestedInput
    Products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type BrandCreateManyInput = {
    id?: string
    accountId: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BrandUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RefreshTokenCreateInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
    account: AccountCreateNestedOneWithoutRefreshTokensInput
  }

  export type RefreshTokenUncheckedCreateInput = {
    id?: string
    accountId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
  }

  export type RefreshTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
    account?: AccountUpdateOneRequiredWithoutRefreshTokensNestedInput
  }

  export type RefreshTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenCreateManyInput = {
    id?: string
    accountId: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
  }

  export type RefreshTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type PrivateConversationCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    participants?: PrivateConversationParticipantCreateNestedManyWithoutConversationInput
    messages?: PrivateMessageCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationUncheckedCreateInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    participants?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
    messages?: PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: PrivateConversationParticipantUpdateManyWithoutConversationNestedInput
    messages?: PrivateMessageUpdateManyWithoutConversationNestedInput
  }

  export type PrivateConversationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: PrivateConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
    messages?: PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type PrivateConversationCreateManyInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
  }

  export type PrivateConversationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrivateConversationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PrivateConversationParticipantCreateInput = {
    id?: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: PrivateConversationCreateNestedOneWithoutParticipantsInput
    account: AccountCreateNestedOneWithoutConversationParticipantInput
  }

  export type PrivateConversationParticipantUncheckedCreateInput = {
    id?: string
    conversationId: string
    accountId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateConversationParticipantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: PrivateConversationUpdateOneRequiredWithoutParticipantsNestedInput
    account?: AccountUpdateOneRequiredWithoutConversationParticipantNestedInput
  }

  export type PrivateConversationParticipantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateConversationParticipantCreateManyInput = {
    id?: string
    conversationId: string
    accountId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateConversationParticipantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateConversationParticipantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageCreateInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    conversation: PrivateConversationCreateNestedOneWithoutMessagesInput
    sender: AccountCreateNestedOneWithoutSentPrivateMessagesInput
    attachments?: PrivateMessageAttachmentCreateNestedManyWithoutMessageInput
    reactedBy?: AccountCreateNestedOneWithoutReactedMessagesInput
    visibilities?: PrivateMessageVisibilityCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUncheckedCreateInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
    attachments?: PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    visibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    conversation?: PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput
    attachments?: PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput
    reactedBy?: AccountUpdateOneWithoutReactedMessagesNestedInput
    visibilities?: PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    visibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageCreateManyInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
  }

  export type PrivateMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
  }

  export type PrivateMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivateMessageAttachmentCreateInput = {
    id?: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message: PrivateMessageCreateNestedOneWithoutAttachmentsInput
  }

  export type PrivateMessageAttachmentUncheckedCreateInput = {
    id?: string
    messageId: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageAttachmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: PrivateMessageUpdateOneRequiredWithoutAttachmentsNestedInput
  }

  export type PrivateMessageAttachmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageAttachmentCreateManyInput = {
    id?: string
    messageId: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageAttachmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageAttachmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityCreateInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message: PrivateMessageCreateNestedOneWithoutVisibilitiesInput
    account: AccountCreateNestedOneWithoutPrivateMessageVisibilitiesInput
  }

  export type PrivateMessageVisibilityUncheckedCreateInput = {
    id?: string
    messageId: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageVisibilityUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: PrivateMessageUpdateOneRequiredWithoutVisibilitiesNestedInput
    account?: AccountUpdateOneRequiredWithoutPrivateMessageVisibilitiesNestedInput
  }

  export type PrivateMessageVisibilityUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityCreateManyInput = {
    id?: string
    messageId: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageVisibilityUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductCreateManyInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateInput = {
    id?: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutImagesInput
    embedding?: ProductImageEmbeddingCreateNestedOneWithoutImageInput
  }

  export type ProductImageUncheckedCreateInput = {
    id?: string
    productId: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    embedding?: ProductImageEmbeddingUncheckedCreateNestedOneWithoutImageInput
  }

  export type ProductImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
    embedding?: ProductImageEmbeddingUpdateOneWithoutImageNestedInput
  }

  export type ProductImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embedding?: ProductImageEmbeddingUncheckedUpdateOneWithoutImageNestedInput
  }

  export type ProductImageCreateManyInput = {
    id?: string
    productId: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionCreateInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
    product: ProductCreateNestedOneWithoutOptionsInput
    values?: ProductOptionValueCreateNestedManyWithoutOptionInput
    VariantOption?: VariantOptionCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionUncheckedCreateInput = {
    id?: string
    productId: string
    name: string
    label?: string | null
    sortOrder?: number
    values?: ProductOptionValueUncheckedCreateNestedManyWithoutOptionInput
    VariantOption?: VariantOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    values?: ProductOptionValueUpdateManyWithoutOptionNestedInput
    VariantOption?: VariantOptionUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    values?: ProductOptionValueUncheckedUpdateManyWithoutOptionNestedInput
    VariantOption?: VariantOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionCreateManyInput = {
    id?: string
    productId: string
    name: string
    label?: string | null
    sortOrder?: number
  }

  export type ProductOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOptionValueCreateInput = {
    id?: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
    option: ProductOptionCreateNestedOneWithoutValuesInput
    variantLinks?: VariantOptionCreateNestedManyWithoutValueInput
  }

  export type ProductOptionValueUncheckedCreateInput = {
    id?: string
    productOptionId: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
    variantLinks?: VariantOptionUncheckedCreateNestedManyWithoutValueInput
  }

  export type ProductOptionValueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    option?: ProductOptionUpdateOneRequiredWithoutValuesNestedInput
    variantLinks?: VariantOptionUpdateManyWithoutValueNestedInput
  }

  export type ProductOptionValueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    variantLinks?: VariantOptionUncheckedUpdateManyWithoutValueNestedInput
  }

  export type ProductOptionValueCreateManyInput = {
    id?: string
    productOptionId: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
  }

  export type ProductOptionValueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductOptionValueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type VariantOptionCreateInput = {
    id?: string
    variant: VariantCreateNestedOneWithoutOptionsInput
    option: ProductOptionCreateNestedOneWithoutVariantOptionInput
    value: ProductOptionValueCreateNestedOneWithoutVariantLinksInput
  }

  export type VariantOptionUncheckedCreateInput = {
    id?: string
    variantId: string
    productOptionId: string
    productOptionValueId: string
  }

  export type VariantOptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variant?: VariantUpdateOneRequiredWithoutOptionsNestedInput
    option?: ProductOptionUpdateOneRequiredWithoutVariantOptionNestedInput
    value?: ProductOptionValueUpdateOneRequiredWithoutVariantLinksNestedInput
  }

  export type VariantOptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionCreateManyInput = {
    id?: string
    variantId: string
    productOptionId: string
    productOptionValueId: string
  }

  export type VariantOptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantCreateInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    images?: VariantImageCreateNestedManyWithoutVariantInput
    options?: VariantOptionCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateInput = {
    id?: string
    productId: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VariantImageUncheckedCreateNestedManyWithoutVariantInput
    options?: VariantOptionUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    images?: VariantImageUpdateManyWithoutVariantNestedInput
    options?: VariantOptionUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VariantImageUncheckedUpdateManyWithoutVariantNestedInput
    options?: VariantOptionUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VariantCreateManyInput = {
    id?: string
    productId: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type VariantUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantImageCreateInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
    variant: VariantCreateNestedOneWithoutImagesInput
  }

  export type VariantImageUncheckedCreateInput = {
    id?: string
    variantId: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variant?: VariantUpdateOneRequiredWithoutImagesNestedInput
  }

  export type VariantImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantImageCreateManyInput = {
    id?: string
    variantId: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductTagCreateNestedManyWithoutTagInput
  }

  export type TagUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    products?: ProductTagUncheckedCreateNestedManyWithoutTagInput
  }

  export type TagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductTagUpdateManyWithoutTagNestedInput
  }

  export type TagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    products?: ProductTagUncheckedUpdateManyWithoutTagNestedInput
  }

  export type TagCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTagCreateInput = {
    pinned?: boolean
    addedAt?: Date | string
    product: ProductCreateNestedOneWithoutTagsInput
    tag: TagCreateNestedOneWithoutProductsInput
  }

  export type ProductTagUncheckedCreateInput = {
    productId: string
    tagId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ProductTagUpdateInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTagsNestedInput
    tag?: TagUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductTagUncheckedUpdateInput = {
    productId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTagCreateManyInput = {
    productId: string
    tagId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ProductTagUpdateManyMutationInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTagUncheckedUpdateManyInput = {
    productId?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageEmbeddingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: ProductImageUpdateOneRequiredWithoutEmbeddingNestedInput
    product?: ProductUpdateOneRequiredWithoutImageVectorsNestedInput
  }

  export type ProductImageEmbeddingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productImageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageEmbeddingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageEmbeddingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productImageId?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewCreateInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateManyInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageCreateInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutImagesInput
  }

  export type ReviewImageUncheckedCreateInput = {
    id?: string
    reviewId: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ReviewImageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ReviewImageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageCreateManyInput = {
    id?: string
    reviewId: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ReviewImageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutVotesInput
    user: UserCreateNestedOneWithoutReviewVotesInput
  }

  export type ReviewVoteUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutVotesNestedInput
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewVoteUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportCreateInput = {
    id?: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutReportsInput
    user: UserCreateNestedOneWithoutReviewReportsInput
  }

  export type ReviewReportUncheckedCreateInput = {
    id?: string
    reviewId: string
    userId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutReportsNestedInput
    user?: UserUpdateOneRequiredWithoutReviewReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportCreateManyInput = {
    id?: string
    reviewId: string
    userId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    review: ReviewCreateNestedOneWithoutRepliesInput
    author: UserCreateNestedOneWithoutReviewReplaysInput
  }

  export type ReviewReplyUncheckedCreateInput = {
    id?: string
    reviewId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutRepliesNestedInput
    author?: UserUpdateOneRequiredWithoutReviewReplaysNestedInput
  }

  export type ReviewReplyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyCreateManyInput = {
    id?: string
    reviewId: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: AccountCreateNestedOneWithoutNotificationInput
    recipients?: NotificationRecipientCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    actorId?: string | null
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    recipients?: NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: AccountUpdateOneWithoutNotificationNestedInput
    recipients?: NotificationRecipientUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationCreateManyInput = {
    id?: string
    actorId?: string | null
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientCreateInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
    account: AccountCreateNestedOneWithoutNotificationRecipientInput
  }

  export type NotificationRecipientUncheckedCreateInput = {
    id?: string
    notificationId: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
    account?: AccountUpdateOneRequiredWithoutNotificationRecipientNestedInput
  }

  export type NotificationRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientCreateManyInput = {
    id?: string
    notificationId: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type EnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type RefreshTokenListRelationFilter = {
    every?: RefreshTokenWhereInput
    some?: RefreshTokenWhereInput
    none?: RefreshTokenWhereInput
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type BrandNullableScalarRelationFilter = {
    is?: BrandWhereInput | null
    isNot?: BrandWhereInput | null
  }

  export type PrivateConversationParticipantListRelationFilter = {
    every?: PrivateConversationParticipantWhereInput
    some?: PrivateConversationParticipantWhereInput
    none?: PrivateConversationParticipantWhereInput
  }

  export type PrivateMessageListRelationFilter = {
    every?: PrivateMessageWhereInput
    some?: PrivateMessageWhereInput
    none?: PrivateMessageWhereInput
  }

  export type PrivateMessageVisibilityListRelationFilter = {
    every?: PrivateMessageVisibilityWhereInput
    some?: PrivateMessageVisibilityWhereInput
    none?: PrivateMessageVisibilityWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type NotificationRecipientListRelationFilter = {
    every?: NotificationRecipientWhereInput
    some?: NotificationRecipientWhereInput
    none?: NotificationRecipientWhereInput
  }

  export type DeviceTokenListRelationFilter = {
    every?: DeviceTokenWhereInput
    some?: DeviceTokenWhereInput
    none?: DeviceTokenWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type RefreshTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateConversationParticipantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateMessageVisibilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccountProviderProviderIdCompoundUniqueInput = {
    provider: $Enums.Provider
    providerId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    passwordResetCode?: SortOrder
    passwordResetCodeExpiresAt?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    passwordResetCode?: SortOrder
    passwordResetCodeExpiresAt?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email?: SortOrder
    password?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    status?: SortOrder
    verificationCode?: SortOrder
    verificationCodeExpiresAt?: SortOrder
    passwordResetCode?: SortOrder
    passwordResetCodeExpiresAt?: SortOrder
    provider?: SortOrder
    providerId?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AccountScalarRelationFilter = {
    is?: AccountWhereInput
    isNot?: AccountWhereInput
  }

  export type DeviceTokenCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type DeviceTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type DeviceTokenMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isActive?: SortOrder
    lastSeenAt?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type EnumPaymentMethodNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel> | null
    has?: $Enums.PaymentMethod | EnumPaymentMethodFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    hasSome?: $Enums.PaymentMethod[] | ListEnumPaymentMethodFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type AddressListRelationFilter = {
    every?: AddressWhereInput
    some?: AddressWhereInput
    none?: AddressWhereInput
  }

  export type ReviewListRelationFilter = {
    every?: ReviewWhereInput
    some?: ReviewWhereInput
    none?: ReviewWhereInput
  }

  export type ReviewVoteListRelationFilter = {
    every?: ReviewVoteWhereInput
    some?: ReviewVoteWhereInput
    none?: ReviewVoteWhereInput
  }

  export type ReviewReportListRelationFilter = {
    every?: ReviewReportWhereInput
    some?: ReviewReportWhereInput
    none?: ReviewReportWhereInput
  }

  export type ReviewReplyListRelationFilter = {
    every?: ReviewReplyWhereInput
    some?: ReviewReplyWhereInput
    none?: ReviewReplyWhereInput
  }

  export type AddressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewVoteOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewReportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewReplyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userName?: SortOrder
    photo?: SortOrder
    phone?: SortOrder
    photoPublicId?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    paymentMethods?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userName?: SortOrder
    photo?: SortOrder
    phone?: SortOrder
    photoPublicId?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    userName?: SortOrder
    photo?: SortOrder
    phone?: SortOrder
    photoPublicId?: SortOrder
    gender?: SortOrder
    birthDate?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AddressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    government?: SortOrder
    city?: SortOrder
    addressLine?: SortOrder
    landmark?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    government?: SortOrder
    city?: SortOrder
    addressLine?: SortOrder
    landmark?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AddressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    government?: SortOrder
    city?: SortOrder
    addressLine?: SortOrder
    landmark?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCategoryNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel> | null
    has?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    hasSome?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumBrandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BrandStatus | EnumBrandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBrandStatusFilter<$PrismaModel> | $Enums.BrandStatus
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BrandCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    categories?: SortOrder
    status?: SortOrder
    instagramUrl?: SortOrder
    tiktokUrl?: SortOrder
    businessPhone?: SortOrder
    ownerName?: SortOrder
    ownerNationalId?: SortOrder
    ownerPhone?: SortOrder
    crn?: SortOrder
    taxId?: SortOrder
    paymentMethods?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    instagramUrl?: SortOrder
    tiktokUrl?: SortOrder
    businessPhone?: SortOrder
    ownerName?: SortOrder
    ownerNationalId?: SortOrder
    ownerPhone?: SortOrder
    crn?: SortOrder
    taxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    description?: SortOrder
    logo?: SortOrder
    status?: SortOrder
    instagramUrl?: SortOrder
    tiktokUrl?: SortOrder
    businessPhone?: SortOrder
    ownerName?: SortOrder
    ownerNationalId?: SortOrder
    ownerPhone?: SortOrder
    crn?: SortOrder
    taxId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumBrandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BrandStatus | EnumBrandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBrandStatusWithAggregatesFilter<$PrismaModel> | $Enums.BrandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBrandStatusFilter<$PrismaModel>
    _max?: NestedEnumBrandStatusFilter<$PrismaModel>
  }

  export type EnumRevokedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RevokedReason | EnumRevokedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRevokedReasonNullableFilter<$PrismaModel> | $Enums.RevokedReason | null
  }

  export type RefreshTokenCountOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    jti?: SortOrder
  }

  export type RefreshTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    jti?: SortOrder
  }

  export type RefreshTokenMinOrderByAggregateInput = {
    id?: SortOrder
    accountId?: SortOrder
    token?: SortOrder
    expiresAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    revokedAt?: SortOrder
    revokedReason?: SortOrder
    jti?: SortOrder
  }

  export type EnumRevokedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevokedReason | EnumRevokedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRevokedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.RevokedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRevokedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumRevokedReasonNullableFilter<$PrismaModel>
  }

  export type PrivateConversationCountOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type PrivateConversationMaxOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type PrivateConversationMinOrderByAggregateInput = {
    id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    archivedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type PrivateConversationScalarRelationFilter = {
    is?: PrivateConversationWhereInput
    isNot?: PrivateConversationWhereInput
  }

  export type PrivateConversationParticipantConversationIdAccountIdCompoundUniqueInput = {
    conversationId: string
    accountId: string
  }

  export type PrivateConversationParticipantCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    accountId?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateConversationParticipantAvgOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type PrivateConversationParticipantMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    accountId?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateConversationParticipantMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    accountId?: SortOrder
    unreadCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateConversationParticipantSumOrderByAggregateInput = {
    unreadCount?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type EnumReactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableFilter<$PrismaModel> | $Enums.ReactionType | null
  }

  export type PrivateMessageAttachmentListRelationFilter = {
    every?: PrivateMessageAttachmentWhereInput
    some?: PrivateMessageAttachmentWhereInput
    none?: PrivateMessageAttachmentWhereInput
  }

  export type AccountNullableScalarRelationFilter = {
    is?: AccountWhereInput | null
    isNot?: AccountWhereInput | null
  }

  export type PrivateMessageAttachmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PrivateMessageCountOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    reactionType?: SortOrder
    reactedById?: SortOrder
  }

  export type PrivateMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    reactionType?: SortOrder
    reactedById?: SortOrder
  }

  export type PrivateMessageMinOrderByAggregateInput = {
    id?: SortOrder
    conversationId?: SortOrder
    senderId?: SortOrder
    content?: SortOrder
    contentType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    reactionType?: SortOrder
    reactedById?: SortOrder
  }

  export type EnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type EnumReactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
  }

  export type PrivateMessageScalarRelationFilter = {
    is?: PrivateMessageWhereInput
    isNot?: PrivateMessageWhereInput
  }

  export type PrivateMessageAttachmentCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateMessageAttachmentMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateMessageAttachmentMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    url?: SortOrder
    mimeType?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateMessageVisibilityMessageIdAccountIdCompoundUniqueInput = {
    messageId: string
    accountId: string
  }

  export type PrivateMessageVisibilityCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateMessageVisibilityMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PrivateMessageVisibilityMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type BrandScalarRelationFilter = {
    is?: BrandWhereInput
    isNot?: BrandWhereInput
  }

  export type ProductImageListRelationFilter = {
    every?: ProductImageWhereInput
    some?: ProductImageWhereInput
    none?: ProductImageWhereInput
  }

  export type VariantListRelationFilter = {
    every?: VariantWhereInput
    some?: VariantWhereInput
    none?: VariantWhereInput
  }

  export type ProductOptionListRelationFilter = {
    every?: ProductOptionWhereInput
    some?: ProductOptionWhereInput
    none?: ProductOptionWhereInput
  }

  export type ProductTagListRelationFilter = {
    every?: ProductTagWhereInput
    some?: ProductTagWhereInput
    none?: ProductTagWhereInput
  }

  export type ProductImageEmbeddingListRelationFilter = {
    every?: ProductImageEmbeddingWhereInput
    some?: ProductImageEmbeddingWhereInput
    none?: ProductImageEmbeddingWhereInput
  }

  export type ProductImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductTagOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductImageEmbeddingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductBrandIdSlugCompoundUniqueInput = {
    brandId: string
    slug: string
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    attributes?: SortOrder
    status?: SortOrder
    material?: SortOrder
    avgRating?: SortOrder
    ratingsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    avgRating?: SortOrder
    ratingsCount?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    status?: SortOrder
    material?: SortOrder
    avgRating?: SortOrder
    ratingsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    brandId?: SortOrder
    category?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    status?: SortOrder
    material?: SortOrder
    avgRating?: SortOrder
    ratingsCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    avgRating?: SortOrder
    ratingsCount?: SortOrder
  }

  export type EnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ProductScalarRelationFilter = {
    is?: ProductWhereInput
    isNot?: ProductWhereInput
  }

  export type ProductImageEmbeddingNullableScalarRelationFilter = {
    is?: ProductImageEmbeddingWhereInput | null
    isNot?: ProductImageEmbeddingWhereInput | null
  }

  export type ProductImageProductIdSortOrderCompoundUniqueInput = {
    productId: string
    sortOrder: number
  }

  export type ProductImageCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    meta?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductImageMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ProductImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductOptionValueListRelationFilter = {
    every?: ProductOptionValueWhereInput
    some?: ProductOptionValueWhereInput
    none?: ProductOptionValueWhereInput
  }

  export type VariantOptionListRelationFilter = {
    every?: VariantOptionWhereInput
    some?: VariantOptionWhereInput
    none?: VariantOptionWhereInput
  }

  export type ProductOptionValueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantOptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductOptionProductIdNameCompoundUniqueInput = {
    productId: string
    name: string
  }

  export type ProductOptionCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    name?: SortOrder
    label?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductOptionScalarRelationFilter = {
    is?: ProductOptionWhereInput
    isNot?: ProductOptionWhereInput
  }

  export type ProductOptionValueProductOptionIdValueCompoundUniqueInput = {
    productOptionId: string
    value: string
  }

  export type ProductOptionValueCountOrderByAggregateInput = {
    id?: SortOrder
    productOptionId?: SortOrder
    value?: SortOrder
    label?: SortOrder
    colorHex?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionValueAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ProductOptionValueMaxOrderByAggregateInput = {
    id?: SortOrder
    productOptionId?: SortOrder
    value?: SortOrder
    label?: SortOrder
    colorHex?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionValueMinOrderByAggregateInput = {
    id?: SortOrder
    productOptionId?: SortOrder
    value?: SortOrder
    label?: SortOrder
    colorHex?: SortOrder
    sortOrder?: SortOrder
  }

  export type ProductOptionValueSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type VariantScalarRelationFilter = {
    is?: VariantWhereInput
    isNot?: VariantWhereInput
  }

  export type ProductOptionValueScalarRelationFilter = {
    is?: ProductOptionValueWhereInput
    isNot?: ProductOptionValueWhereInput
  }

  export type VariantOptionVariantIdProductOptionIdCompoundUniqueInput = {
    variantId: string
    productOptionId: string
  }

  export type VariantOptionCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    productOptionId?: SortOrder
    productOptionValueId?: SortOrder
  }

  export type VariantOptionMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    productOptionId?: SortOrder
    productOptionValueId?: SortOrder
  }

  export type VariantOptionMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    productOptionId?: SortOrder
    productOptionValueId?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type VariantImageListRelationFilter = {
    every?: VariantImageWhereInput
    some?: VariantImageWhereInput
    none?: VariantImageWhereInput
  }

  export type VariantImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VariantProductIdSkuCompoundUniqueInput = {
    productId: string
    sku: string
  }

  export type VariantCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    weight?: SortOrder
    dimensions?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantAvgOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    weight?: SortOrder
  }

  export type VariantMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    sku?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    stock?: SortOrder
    weight?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VariantSumOrderByAggregateInput = {
    price?: SortOrder
    stock?: SortOrder
    weight?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type VariantImageVariantIdSortOrderCompoundUniqueInput = {
    variantId: string
    sortOrder: number
  }

  export type VariantImageCountOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type VariantImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type VariantImageMaxOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type VariantImageMinOrderByAggregateInput = {
    id?: SortOrder
    variantId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type VariantImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type TagCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TagScalarRelationFilter = {
    is?: TagWhereInput
    isNot?: TagWhereInput
  }

  export type ProductTagProductIdTagIdCompoundUniqueInput = {
    productId: string
    tagId: string
  }

  export type ProductTagCountOrderByAggregateInput = {
    productId?: SortOrder
    tagId?: SortOrder
    pinned?: SortOrder
    addedAt?: SortOrder
  }

  export type ProductTagMaxOrderByAggregateInput = {
    productId?: SortOrder
    tagId?: SortOrder
    pinned?: SortOrder
    addedAt?: SortOrder
  }

  export type ProductTagMinOrderByAggregateInput = {
    productId?: SortOrder
    tagId?: SortOrder
    pinned?: SortOrder
    addedAt?: SortOrder
  }

  export type ProductImageScalarRelationFilter = {
    is?: ProductImageWhereInput
    isNot?: ProductImageWhereInput
  }

  export type ProductImageEmbeddingCountOrderByAggregateInput = {
    id?: SortOrder
    productImageId?: SortOrder
    productId?: SortOrder
    model?: SortOrder
    dim?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageEmbeddingAvgOrderByAggregateInput = {
    dim?: SortOrder
  }

  export type ProductImageEmbeddingMaxOrderByAggregateInput = {
    id?: SortOrder
    productImageId?: SortOrder
    productId?: SortOrder
    model?: SortOrder
    dim?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageEmbeddingMinOrderByAggregateInput = {
    id?: SortOrder
    productImageId?: SortOrder
    productId?: SortOrder
    model?: SortOrder
    dim?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProductImageEmbeddingSumOrderByAggregateInput = {
    dim?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EnumReviewVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewVisibility | EnumReviewVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewVisibilityFilter<$PrismaModel> | $Enums.ReviewVisibility
  }

  export type ReviewImageListRelationFilter = {
    every?: ReviewImageWhereInput
    some?: ReviewImageWhereInput
    none?: ReviewImageWhereInput
  }

  export type ReviewImageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReviewProductIdUserIdCompoundUniqueInput = {
    productId: string
    userId: string
  }

  export type ReviewCountOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isVerified?: SortOrder
    visibility?: SortOrder
    reported?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewAvgOrderByAggregateInput = {
    rating?: SortOrder
    helpfulCount?: SortOrder
  }

  export type ReviewMaxOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isVerified?: SortOrder
    visibility?: SortOrder
    reported?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewMinOrderByAggregateInput = {
    id?: SortOrder
    productId?: SortOrder
    userId?: SortOrder
    rating?: SortOrder
    title?: SortOrder
    content?: SortOrder
    isVerified?: SortOrder
    visibility?: SortOrder
    reported?: SortOrder
    helpfulCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewSumOrderByAggregateInput = {
    rating?: SortOrder
    helpfulCount?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumReviewVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewVisibility | EnumReviewVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ReviewVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewVisibilityFilter<$PrismaModel>
    _max?: NestedEnumReviewVisibilityFilter<$PrismaModel>
  }

  export type ReviewScalarRelationFilter = {
    is?: ReviewWhereInput
    isNot?: ReviewWhereInput
  }

  export type ReviewImageCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewImageAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ReviewImageMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewImageMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    url?: SortOrder
    altText?: SortOrder
    sortOrder?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewImageSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type ReviewVoteReviewIdUserIdCompoundUniqueInput = {
    reviewId: string
    userId: string
  }

  export type ReviewVoteCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewVoteMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type EnumReportReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonFilter<$PrismaModel> | $Enums.ReportReason
  }

  export type ReviewReportCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewReportMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type ReviewReportMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    userId?: SortOrder
    reason?: SortOrder
    details?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumReportReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReportReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportReasonFilter<$PrismaModel>
    _max?: NestedEnumReportReasonFilter<$PrismaModel>
  }

  export type ReviewReplyCountOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewReplyMaxOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ReviewReplyMinOrderByAggregateInput = {
    id?: SortOrder
    reviewId?: SortOrder
    authorId?: SortOrder
    content?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    actorId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    body?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type NotificationScalarRelationFilter = {
    is?: NotificationWhereInput
    isNot?: NotificationWhereInput
  }

  export type NotificationRecipientNotificationIdAccountIdCompoundUniqueInput = {
    notificationId: string
    accountId: string
  }

  export type NotificationRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type NotificationRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    notificationId?: SortOrder
    accountId?: SortOrder
    readAt?: SortOrder
    deletedAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type RefreshTokenCreateNestedManyWithoutAccountInput = {
    create?: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput> | RefreshTokenCreateWithoutAccountInput[] | RefreshTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAccountInput | RefreshTokenCreateOrConnectWithoutAccountInput[]
    createMany?: RefreshTokenCreateManyAccountInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type BrandCreateNestedOneWithoutAccountInput = {
    create?: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAccountInput
    connect?: BrandWhereUniqueInput
  }

  export type PrivateConversationParticipantCreateNestedManyWithoutAccountInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput> | PrivateConversationParticipantCreateWithoutAccountInput[] | PrivateConversationParticipantUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutAccountInput | PrivateConversationParticipantCreateOrConnectWithoutAccountInput[]
    createMany?: PrivateConversationParticipantCreateManyAccountInputEnvelope
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
  }

  export type PrivateMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput> | PrivateMessageCreateWithoutSenderInput[] | PrivateMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutSenderInput | PrivateMessageCreateOrConnectWithoutSenderInput[]
    createMany?: PrivateMessageCreateManySenderInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateMessageCreateNestedManyWithoutReactedByInput = {
    create?: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput> | PrivateMessageCreateWithoutReactedByInput[] | PrivateMessageUncheckedCreateWithoutReactedByInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutReactedByInput | PrivateMessageCreateOrConnectWithoutReactedByInput[]
    createMany?: PrivateMessageCreateManyReactedByInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateMessageVisibilityCreateNestedManyWithoutAccountInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput> | PrivateMessageVisibilityCreateWithoutAccountInput[] | PrivateMessageVisibilityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutAccountInput | PrivateMessageVisibilityCreateOrConnectWithoutAccountInput[]
    createMany?: PrivateMessageVisibilityCreateManyAccountInputEnvelope
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutActorInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationRecipientCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput> | NotificationRecipientCreateWithoutAccountInput[] | NotificationRecipientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutAccountInput | NotificationRecipientCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationRecipientCreateManyAccountInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type DeviceTokenCreateNestedManyWithoutAccountInput = {
    create?: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput> | DeviceTokenCreateWithoutAccountInput[] | DeviceTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutAccountInput | DeviceTokenCreateOrConnectWithoutAccountInput[]
    createMany?: DeviceTokenCreateManyAccountInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type RefreshTokenUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput> | RefreshTokenCreateWithoutAccountInput[] | RefreshTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAccountInput | RefreshTokenCreateOrConnectWithoutAccountInput[]
    createMany?: RefreshTokenCreateManyAccountInputEnvelope
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
  }

  export type UserUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    connect?: UserWhereUniqueInput
  }

  export type BrandUncheckedCreateNestedOneWithoutAccountInput = {
    create?: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAccountInput
    connect?: BrandWhereUniqueInput
  }

  export type PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput> | PrivateConversationParticipantCreateWithoutAccountInput[] | PrivateConversationParticipantUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutAccountInput | PrivateConversationParticipantCreateOrConnectWithoutAccountInput[]
    createMany?: PrivateConversationParticipantCreateManyAccountInputEnvelope
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
  }

  export type PrivateMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput> | PrivateMessageCreateWithoutSenderInput[] | PrivateMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutSenderInput | PrivateMessageCreateOrConnectWithoutSenderInput[]
    createMany?: PrivateMessageCreateManySenderInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput = {
    create?: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput> | PrivateMessageCreateWithoutReactedByInput[] | PrivateMessageUncheckedCreateWithoutReactedByInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutReactedByInput | PrivateMessageCreateOrConnectWithoutReactedByInput[]
    createMany?: PrivateMessageCreateManyReactedByInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput> | PrivateMessageVisibilityCreateWithoutAccountInput[] | PrivateMessageVisibilityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutAccountInput | PrivateMessageVisibilityCreateOrConnectWithoutAccountInput[]
    createMany?: PrivateMessageVisibilityCreateManyAccountInputEnvelope
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutActorInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput> | NotificationRecipientCreateWithoutAccountInput[] | NotificationRecipientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutAccountInput | NotificationRecipientCreateOrConnectWithoutAccountInput[]
    createMany?: NotificationRecipientCreateManyAccountInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type DeviceTokenUncheckedCreateNestedManyWithoutAccountInput = {
    create?: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput> | DeviceTokenCreateWithoutAccountInput[] | DeviceTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutAccountInput | DeviceTokenCreateOrConnectWithoutAccountInput[]
    createMany?: DeviceTokenCreateManyAccountInputEnvelope
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type EnumStatusFieldUpdateOperationsInput = {
    set?: $Enums.Status
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EnumProviderFieldUpdateOperationsInput = {
    set?: $Enums.Provider
  }

  export type RefreshTokenUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput> | RefreshTokenCreateWithoutAccountInput[] | RefreshTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAccountInput | RefreshTokenCreateOrConnectWithoutAccountInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutAccountInput | RefreshTokenUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RefreshTokenCreateManyAccountInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutAccountInput | RefreshTokenUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutAccountInput | RefreshTokenUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserUpdateOneWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type BrandUpdateOneWithoutAccountNestedInput = {
    create?: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAccountInput
    upsert?: BrandUpsertWithoutAccountInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutAccountInput, BrandUpdateWithoutAccountInput>, BrandUncheckedUpdateWithoutAccountInput>
  }

  export type PrivateConversationParticipantUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput> | PrivateConversationParticipantCreateWithoutAccountInput[] | PrivateConversationParticipantUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutAccountInput | PrivateConversationParticipantCreateOrConnectWithoutAccountInput[]
    upsert?: PrivateConversationParticipantUpsertWithWhereUniqueWithoutAccountInput | PrivateConversationParticipantUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PrivateConversationParticipantCreateManyAccountInputEnvelope
    set?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    disconnect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    delete?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    update?: PrivateConversationParticipantUpdateWithWhereUniqueWithoutAccountInput | PrivateConversationParticipantUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PrivateConversationParticipantUpdateManyWithWhereWithoutAccountInput | PrivateConversationParticipantUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
  }

  export type PrivateMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput> | PrivateMessageCreateWithoutSenderInput[] | PrivateMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutSenderInput | PrivateMessageCreateOrConnectWithoutSenderInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutSenderInput | PrivateMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PrivateMessageCreateManySenderInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutSenderInput | PrivateMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutSenderInput | PrivateMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateMessageUpdateManyWithoutReactedByNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput> | PrivateMessageCreateWithoutReactedByInput[] | PrivateMessageUncheckedCreateWithoutReactedByInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutReactedByInput | PrivateMessageCreateOrConnectWithoutReactedByInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutReactedByInput | PrivateMessageUpsertWithWhereUniqueWithoutReactedByInput[]
    createMany?: PrivateMessageCreateManyReactedByInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutReactedByInput | PrivateMessageUpdateWithWhereUniqueWithoutReactedByInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutReactedByInput | PrivateMessageUpdateManyWithWhereWithoutReactedByInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput> | PrivateMessageVisibilityCreateWithoutAccountInput[] | PrivateMessageVisibilityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutAccountInput | PrivateMessageVisibilityCreateOrConnectWithoutAccountInput[]
    upsert?: PrivateMessageVisibilityUpsertWithWhereUniqueWithoutAccountInput | PrivateMessageVisibilityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PrivateMessageVisibilityCreateManyAccountInputEnvelope
    set?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    disconnect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    delete?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    update?: PrivateMessageVisibilityUpdateWithWhereUniqueWithoutAccountInput | PrivateMessageVisibilityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PrivateMessageVisibilityUpdateManyWithWhereWithoutAccountInput | PrivateMessageVisibilityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutActorNestedInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutActorInput | NotificationUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutActorInput | NotificationUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutActorInput | NotificationUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationRecipientUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput> | NotificationRecipientCreateWithoutAccountInput[] | NotificationRecipientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutAccountInput | NotificationRecipientCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutAccountInput | NotificationRecipientUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationRecipientCreateManyAccountInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutAccountInput | NotificationRecipientUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutAccountInput | NotificationRecipientUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type DeviceTokenUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput> | DeviceTokenCreateWithoutAccountInput[] | DeviceTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutAccountInput | DeviceTokenCreateOrConnectWithoutAccountInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutAccountInput | DeviceTokenUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DeviceTokenCreateManyAccountInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutAccountInput | DeviceTokenUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutAccountInput | DeviceTokenUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput> | RefreshTokenCreateWithoutAccountInput[] | RefreshTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: RefreshTokenCreateOrConnectWithoutAccountInput | RefreshTokenCreateOrConnectWithoutAccountInput[]
    upsert?: RefreshTokenUpsertWithWhereUniqueWithoutAccountInput | RefreshTokenUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: RefreshTokenCreateManyAccountInputEnvelope
    set?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    disconnect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    delete?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    connect?: RefreshTokenWhereUniqueInput | RefreshTokenWhereUniqueInput[]
    update?: RefreshTokenUpdateWithWhereUniqueWithoutAccountInput | RefreshTokenUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: RefreshTokenUpdateManyWithWhereWithoutAccountInput | RefreshTokenUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
  }

  export type UserUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountInput
    upsert?: UserUpsertWithoutAccountInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountInput, UserUpdateWithoutAccountInput>, UserUncheckedUpdateWithoutAccountInput>
  }

  export type BrandUncheckedUpdateOneWithoutAccountNestedInput = {
    create?: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
    connectOrCreate?: BrandCreateOrConnectWithoutAccountInput
    upsert?: BrandUpsertWithoutAccountInput
    disconnect?: BrandWhereInput | boolean
    delete?: BrandWhereInput | boolean
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutAccountInput, BrandUpdateWithoutAccountInput>, BrandUncheckedUpdateWithoutAccountInput>
  }

  export type PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput> | PrivateConversationParticipantCreateWithoutAccountInput[] | PrivateConversationParticipantUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutAccountInput | PrivateConversationParticipantCreateOrConnectWithoutAccountInput[]
    upsert?: PrivateConversationParticipantUpsertWithWhereUniqueWithoutAccountInput | PrivateConversationParticipantUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PrivateConversationParticipantCreateManyAccountInputEnvelope
    set?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    disconnect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    delete?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    update?: PrivateConversationParticipantUpdateWithWhereUniqueWithoutAccountInput | PrivateConversationParticipantUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PrivateConversationParticipantUpdateManyWithWhereWithoutAccountInput | PrivateConversationParticipantUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
  }

  export type PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput> | PrivateMessageCreateWithoutSenderInput[] | PrivateMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutSenderInput | PrivateMessageCreateOrConnectWithoutSenderInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutSenderInput | PrivateMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: PrivateMessageCreateManySenderInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutSenderInput | PrivateMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutSenderInput | PrivateMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput> | PrivateMessageCreateWithoutReactedByInput[] | PrivateMessageUncheckedCreateWithoutReactedByInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutReactedByInput | PrivateMessageCreateOrConnectWithoutReactedByInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutReactedByInput | PrivateMessageUpsertWithWhereUniqueWithoutReactedByInput[]
    createMany?: PrivateMessageCreateManyReactedByInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutReactedByInput | PrivateMessageUpdateWithWhereUniqueWithoutReactedByInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutReactedByInput | PrivateMessageUpdateManyWithWhereWithoutReactedByInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput> | PrivateMessageVisibilityCreateWithoutAccountInput[] | PrivateMessageVisibilityUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutAccountInput | PrivateMessageVisibilityCreateOrConnectWithoutAccountInput[]
    upsert?: PrivateMessageVisibilityUpsertWithWhereUniqueWithoutAccountInput | PrivateMessageVisibilityUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: PrivateMessageVisibilityCreateManyAccountInputEnvelope
    set?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    disconnect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    delete?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    update?: PrivateMessageVisibilityUpdateWithWhereUniqueWithoutAccountInput | PrivateMessageVisibilityUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: PrivateMessageVisibilityUpdateManyWithWhereWithoutAccountInput | PrivateMessageVisibilityUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutActorNestedInput = {
    create?: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput> | NotificationCreateWithoutActorInput[] | NotificationUncheckedCreateWithoutActorInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutActorInput | NotificationCreateOrConnectWithoutActorInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutActorInput | NotificationUpsertWithWhereUniqueWithoutActorInput[]
    createMany?: NotificationCreateManyActorInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutActorInput | NotificationUpdateWithWhereUniqueWithoutActorInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutActorInput | NotificationUpdateManyWithWhereWithoutActorInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput> | NotificationRecipientCreateWithoutAccountInput[] | NotificationRecipientUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutAccountInput | NotificationRecipientCreateOrConnectWithoutAccountInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutAccountInput | NotificationRecipientUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: NotificationRecipientCreateManyAccountInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutAccountInput | NotificationRecipientUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutAccountInput | NotificationRecipientUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput = {
    create?: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput> | DeviceTokenCreateWithoutAccountInput[] | DeviceTokenUncheckedCreateWithoutAccountInput[]
    connectOrCreate?: DeviceTokenCreateOrConnectWithoutAccountInput | DeviceTokenCreateOrConnectWithoutAccountInput[]
    upsert?: DeviceTokenUpsertWithWhereUniqueWithoutAccountInput | DeviceTokenUpsertWithWhereUniqueWithoutAccountInput[]
    createMany?: DeviceTokenCreateManyAccountInputEnvelope
    set?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    disconnect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    delete?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    connect?: DeviceTokenWhereUniqueInput | DeviceTokenWhereUniqueInput[]
    update?: DeviceTokenUpdateWithWhereUniqueWithoutAccountInput | DeviceTokenUpdateWithWhereUniqueWithoutAccountInput[]
    updateMany?: DeviceTokenUpdateManyWithWhereWithoutAccountInput | DeviceTokenUpdateManyWithWhereWithoutAccountInput[]
    deleteMany?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutDeviceTokensInput = {
    create?: XOR<AccountCreateWithoutDeviceTokensInput, AccountUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDeviceTokensInput
    connect?: AccountWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AccountUpdateOneRequiredWithoutDeviceTokensNestedInput = {
    create?: XOR<AccountCreateWithoutDeviceTokensInput, AccountUncheckedCreateWithoutDeviceTokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutDeviceTokensInput
    upsert?: AccountUpsertWithoutDeviceTokensInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutDeviceTokensInput, AccountUpdateWithoutDeviceTokensInput>, AccountUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type UserCreatepaymentMethodsInput = {
    set: $Enums.PaymentMethod[]
  }

  export type AccountCreateNestedOneWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    connect?: AccountWhereUniqueInput
  }

  export type AddressCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewVoteCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type ReviewReplyCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput> | ReviewReplyCreateWithoutAuthorInput[] | ReviewReplyUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAuthorInput | ReviewReplyCreateOrConnectWithoutAuthorInput[]
    createMany?: ReviewReplyCreateManyAuthorInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type AddressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput> | ReviewReplyCreateWithoutAuthorInput[] | ReviewReplyUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAuthorInput | ReviewReplyCreateOrConnectWithoutAuthorInput[]
    createMany?: ReviewReplyCreateManyAuthorInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type NullableEnumGenderFieldUpdateOperationsInput = {
    set?: $Enums.Gender | null
  }

  export type UserUpdatepaymentMethodsInput = {
    set?: $Enums.PaymentMethod[]
    push?: $Enums.PaymentMethod | $Enums.PaymentMethod[]
  }

  export type AccountUpdateOneRequiredWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput
    upsert?: AccountUpsertWithoutUserInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutUserInput, AccountUpdateWithoutUserInput>, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewVoteUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutUserInput | ReviewReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutUserInput | ReviewReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutUserInput | ReviewReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type ReviewReplyUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput> | ReviewReplyCreateWithoutAuthorInput[] | ReviewReplyUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAuthorInput | ReviewReplyCreateOrConnectWithoutAuthorInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutAuthorInput | ReviewReplyUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReviewReplyCreateManyAuthorInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutAuthorInput | ReviewReplyUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutAuthorInput | ReviewReplyUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type AddressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput> | AddressCreateWithoutUserInput[] | AddressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AddressCreateOrConnectWithoutUserInput | AddressCreateOrConnectWithoutUserInput[]
    upsert?: AddressUpsertWithWhereUniqueWithoutUserInput | AddressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AddressCreateManyUserInputEnvelope
    set?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    disconnect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    delete?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    connect?: AddressWhereUniqueInput | AddressWhereUniqueInput[]
    update?: AddressUpdateWithWhereUniqueWithoutUserInput | AddressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AddressUpdateManyWithWhereWithoutUserInput | AddressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AddressScalarWhereInput | AddressScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput> | ReviewCreateWithoutUserInput[] | ReviewUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutUserInput | ReviewCreateOrConnectWithoutUserInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutUserInput | ReviewUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewCreateManyUserInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutUserInput | ReviewUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutUserInput | ReviewUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput> | ReviewVoteCreateWithoutUserInput[] | ReviewVoteUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutUserInput | ReviewVoteCreateOrConnectWithoutUserInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutUserInput | ReviewVoteUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewVoteCreateManyUserInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutUserInput | ReviewVoteUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutUserInput | ReviewVoteUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput> | ReviewReportCreateWithoutUserInput[] | ReviewReportUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutUserInput | ReviewReportCreateOrConnectWithoutUserInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutUserInput | ReviewReportUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ReviewReportCreateManyUserInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutUserInput | ReviewReportUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutUserInput | ReviewReportUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput> | ReviewReplyCreateWithoutAuthorInput[] | ReviewReplyUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutAuthorInput | ReviewReplyCreateOrConnectWithoutAuthorInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutAuthorInput | ReviewReplyUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ReviewReplyCreateManyAuthorInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutAuthorInput | ReviewReplyUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutAuthorInput | ReviewReplyUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAddressesInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAddressesNestedInput = {
    create?: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    connectOrCreate?: UserCreateOrConnectWithoutAddressesInput
    upsert?: UserUpsertWithoutAddressesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAddressesInput, UserUpdateWithoutAddressesInput>, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type BrandCreatecategoriesInput = {
    set: $Enums.Category[]
  }

  export type BrandCreatepaymentMethodsInput = {
    set: $Enums.PaymentMethod[]
  }

  export type AccountCreateNestedOneWithoutBrandInput = {
    create?: XOR<AccountCreateWithoutBrandInput, AccountUncheckedCreateWithoutBrandInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBrandInput
    connect?: AccountWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type ProductUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
  }

  export type BrandUpdatecategoriesInput = {
    set?: $Enums.Category[]
    push?: $Enums.Category | $Enums.Category[]
  }

  export type EnumBrandStatusFieldUpdateOperationsInput = {
    set?: $Enums.BrandStatus
  }

  export type BrandUpdatepaymentMethodsInput = {
    set?: $Enums.PaymentMethod[]
    push?: $Enums.PaymentMethod | $Enums.PaymentMethod[]
  }

  export type AccountUpdateOneRequiredWithoutBrandNestedInput = {
    create?: XOR<AccountCreateWithoutBrandInput, AccountUncheckedCreateWithoutBrandInput>
    connectOrCreate?: AccountCreateOrConnectWithoutBrandInput
    upsert?: AccountUpsertWithoutBrandInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutBrandInput, AccountUpdateWithoutBrandInput>, AccountUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type ProductUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput> | ProductCreateWithoutBrandInput[] | ProductUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: ProductCreateOrConnectWithoutBrandInput | ProductCreateOrConnectWithoutBrandInput[]
    upsert?: ProductUpsertWithWhereUniqueWithoutBrandInput | ProductUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: ProductCreateManyBrandInputEnvelope
    set?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    disconnect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    delete?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    connect?: ProductWhereUniqueInput | ProductWhereUniqueInput[]
    update?: ProductUpdateWithWhereUniqueWithoutBrandInput | ProductUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: ProductUpdateManyWithWhereWithoutBrandInput | ProductUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: ProductScalarWhereInput | ProductScalarWhereInput[]
  }

  export type AccountCreateNestedOneWithoutRefreshTokensInput = {
    create?: XOR<AccountCreateWithoutRefreshTokensInput, AccountUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRefreshTokensInput
    connect?: AccountWhereUniqueInput
  }

  export type NullableEnumRevokedReasonFieldUpdateOperationsInput = {
    set?: $Enums.RevokedReason | null
  }

  export type AccountUpdateOneRequiredWithoutRefreshTokensNestedInput = {
    create?: XOR<AccountCreateWithoutRefreshTokensInput, AccountUncheckedCreateWithoutRefreshTokensInput>
    connectOrCreate?: AccountCreateOrConnectWithoutRefreshTokensInput
    upsert?: AccountUpsertWithoutRefreshTokensInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutRefreshTokensInput, AccountUpdateWithoutRefreshTokensInput>, AccountUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type PrivateConversationParticipantCreateNestedManyWithoutConversationInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput> | PrivateConversationParticipantCreateWithoutConversationInput[] | PrivateConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutConversationInput | PrivateConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: PrivateConversationParticipantCreateManyConversationInputEnvelope
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
  }

  export type PrivateMessageCreateNestedManyWithoutConversationInput = {
    create?: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput> | PrivateMessageCreateWithoutConversationInput[] | PrivateMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutConversationInput | PrivateMessageCreateOrConnectWithoutConversationInput[]
    createMany?: PrivateMessageCreateManyConversationInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateConversationParticipantUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput> | PrivateConversationParticipantCreateWithoutConversationInput[] | PrivateConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutConversationInput | PrivateConversationParticipantCreateOrConnectWithoutConversationInput[]
    createMany?: PrivateConversationParticipantCreateManyConversationInputEnvelope
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
  }

  export type PrivateMessageUncheckedCreateNestedManyWithoutConversationInput = {
    create?: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput> | PrivateMessageCreateWithoutConversationInput[] | PrivateMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutConversationInput | PrivateMessageCreateOrConnectWithoutConversationInput[]
    createMany?: PrivateMessageCreateManyConversationInputEnvelope
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
  }

  export type PrivateConversationParticipantUpdateManyWithoutConversationNestedInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput> | PrivateConversationParticipantCreateWithoutConversationInput[] | PrivateConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutConversationInput | PrivateConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: PrivateConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | PrivateConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: PrivateConversationParticipantCreateManyConversationInputEnvelope
    set?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    disconnect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    delete?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    update?: PrivateConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | PrivateConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: PrivateConversationParticipantUpdateManyWithWhereWithoutConversationInput | PrivateConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
  }

  export type PrivateMessageUpdateManyWithoutConversationNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput> | PrivateMessageCreateWithoutConversationInput[] | PrivateMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutConversationInput | PrivateMessageCreateOrConnectWithoutConversationInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutConversationInput | PrivateMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: PrivateMessageCreateManyConversationInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutConversationInput | PrivateMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutConversationInput | PrivateMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput> | PrivateConversationParticipantCreateWithoutConversationInput[] | PrivateConversationParticipantUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateConversationParticipantCreateOrConnectWithoutConversationInput | PrivateConversationParticipantCreateOrConnectWithoutConversationInput[]
    upsert?: PrivateConversationParticipantUpsertWithWhereUniqueWithoutConversationInput | PrivateConversationParticipantUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: PrivateConversationParticipantCreateManyConversationInputEnvelope
    set?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    disconnect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    delete?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    connect?: PrivateConversationParticipantWhereUniqueInput | PrivateConversationParticipantWhereUniqueInput[]
    update?: PrivateConversationParticipantUpdateWithWhereUniqueWithoutConversationInput | PrivateConversationParticipantUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: PrivateConversationParticipantUpdateManyWithWhereWithoutConversationInput | PrivateConversationParticipantUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
  }

  export type PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput> | PrivateMessageCreateWithoutConversationInput[] | PrivateMessageUncheckedCreateWithoutConversationInput[]
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutConversationInput | PrivateMessageCreateOrConnectWithoutConversationInput[]
    upsert?: PrivateMessageUpsertWithWhereUniqueWithoutConversationInput | PrivateMessageUpsertWithWhereUniqueWithoutConversationInput[]
    createMany?: PrivateMessageCreateManyConversationInputEnvelope
    set?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    disconnect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    delete?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    connect?: PrivateMessageWhereUniqueInput | PrivateMessageWhereUniqueInput[]
    update?: PrivateMessageUpdateWithWhereUniqueWithoutConversationInput | PrivateMessageUpdateWithWhereUniqueWithoutConversationInput[]
    updateMany?: PrivateMessageUpdateManyWithWhereWithoutConversationInput | PrivateMessageUpdateManyWithWhereWithoutConversationInput[]
    deleteMany?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
  }

  export type PrivateConversationCreateNestedOneWithoutParticipantsInput = {
    create?: XOR<PrivateConversationCreateWithoutParticipantsInput, PrivateConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: PrivateConversationCreateOrConnectWithoutParticipantsInput
    connect?: PrivateConversationWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutConversationParticipantInput = {
    create?: XOR<AccountCreateWithoutConversationParticipantInput, AccountUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: AccountCreateOrConnectWithoutConversationParticipantInput
    connect?: AccountWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type PrivateConversationUpdateOneRequiredWithoutParticipantsNestedInput = {
    create?: XOR<PrivateConversationCreateWithoutParticipantsInput, PrivateConversationUncheckedCreateWithoutParticipantsInput>
    connectOrCreate?: PrivateConversationCreateOrConnectWithoutParticipantsInput
    upsert?: PrivateConversationUpsertWithoutParticipantsInput
    connect?: PrivateConversationWhereUniqueInput
    update?: XOR<XOR<PrivateConversationUpdateToOneWithWhereWithoutParticipantsInput, PrivateConversationUpdateWithoutParticipantsInput>, PrivateConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type AccountUpdateOneRequiredWithoutConversationParticipantNestedInput = {
    create?: XOR<AccountCreateWithoutConversationParticipantInput, AccountUncheckedCreateWithoutConversationParticipantInput>
    connectOrCreate?: AccountCreateOrConnectWithoutConversationParticipantInput
    upsert?: AccountUpsertWithoutConversationParticipantInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutConversationParticipantInput, AccountUpdateWithoutConversationParticipantInput>, AccountUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type PrivateConversationCreateNestedOneWithoutMessagesInput = {
    create?: XOR<PrivateConversationCreateWithoutMessagesInput, PrivateConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: PrivateConversationCreateOrConnectWithoutMessagesInput
    connect?: PrivateConversationWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutSentPrivateMessagesInput = {
    create?: XOR<AccountCreateWithoutSentPrivateMessagesInput, AccountUncheckedCreateWithoutSentPrivateMessagesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSentPrivateMessagesInput
    connect?: AccountWhereUniqueInput
  }

  export type PrivateMessageAttachmentCreateNestedManyWithoutMessageInput = {
    create?: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput> | PrivateMessageAttachmentCreateWithoutMessageInput[] | PrivateMessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageAttachmentCreateOrConnectWithoutMessageInput | PrivateMessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: PrivateMessageAttachmentCreateManyMessageInputEnvelope
    connect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
  }

  export type AccountCreateNestedOneWithoutReactedMessagesInput = {
    create?: XOR<AccountCreateWithoutReactedMessagesInput, AccountUncheckedCreateWithoutReactedMessagesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutReactedMessagesInput
    connect?: AccountWhereUniqueInput
  }

  export type PrivateMessageVisibilityCreateNestedManyWithoutMessageInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput> | PrivateMessageVisibilityCreateWithoutMessageInput[] | PrivateMessageVisibilityUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutMessageInput | PrivateMessageVisibilityCreateOrConnectWithoutMessageInput[]
    createMany?: PrivateMessageVisibilityCreateManyMessageInputEnvelope
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
  }

  export type PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput> | PrivateMessageAttachmentCreateWithoutMessageInput[] | PrivateMessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageAttachmentCreateOrConnectWithoutMessageInput | PrivateMessageAttachmentCreateOrConnectWithoutMessageInput[]
    createMany?: PrivateMessageAttachmentCreateManyMessageInputEnvelope
    connect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
  }

  export type PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput> | PrivateMessageVisibilityCreateWithoutMessageInput[] | PrivateMessageVisibilityUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutMessageInput | PrivateMessageVisibilityCreateOrConnectWithoutMessageInput[]
    createMany?: PrivateMessageVisibilityCreateManyMessageInputEnvelope
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
  }

  export type EnumContentTypeFieldUpdateOperationsInput = {
    set?: $Enums.ContentType
  }

  export type NullableEnumReactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.ReactionType | null
  }

  export type PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<PrivateConversationCreateWithoutMessagesInput, PrivateConversationUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: PrivateConversationCreateOrConnectWithoutMessagesInput
    upsert?: PrivateConversationUpsertWithoutMessagesInput
    connect?: PrivateConversationWhereUniqueInput
    update?: XOR<XOR<PrivateConversationUpdateToOneWithWhereWithoutMessagesInput, PrivateConversationUpdateWithoutMessagesInput>, PrivateConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput = {
    create?: XOR<AccountCreateWithoutSentPrivateMessagesInput, AccountUncheckedCreateWithoutSentPrivateMessagesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutSentPrivateMessagesInput
    upsert?: AccountUpsertWithoutSentPrivateMessagesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutSentPrivateMessagesInput, AccountUpdateWithoutSentPrivateMessagesInput>, AccountUncheckedUpdateWithoutSentPrivateMessagesInput>
  }

  export type PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput = {
    create?: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput> | PrivateMessageAttachmentCreateWithoutMessageInput[] | PrivateMessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageAttachmentCreateOrConnectWithoutMessageInput | PrivateMessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: PrivateMessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | PrivateMessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: PrivateMessageAttachmentCreateManyMessageInputEnvelope
    set?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    disconnect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    delete?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    connect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    update?: PrivateMessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | PrivateMessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: PrivateMessageAttachmentUpdateManyWithWhereWithoutMessageInput | PrivateMessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: PrivateMessageAttachmentScalarWhereInput | PrivateMessageAttachmentScalarWhereInput[]
  }

  export type AccountUpdateOneWithoutReactedMessagesNestedInput = {
    create?: XOR<AccountCreateWithoutReactedMessagesInput, AccountUncheckedCreateWithoutReactedMessagesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutReactedMessagesInput
    upsert?: AccountUpsertWithoutReactedMessagesInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutReactedMessagesInput, AccountUpdateWithoutReactedMessagesInput>, AccountUncheckedUpdateWithoutReactedMessagesInput>
  }

  export type PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput> | PrivateMessageVisibilityCreateWithoutMessageInput[] | PrivateMessageVisibilityUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutMessageInput | PrivateMessageVisibilityCreateOrConnectWithoutMessageInput[]
    upsert?: PrivateMessageVisibilityUpsertWithWhereUniqueWithoutMessageInput | PrivateMessageVisibilityUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: PrivateMessageVisibilityCreateManyMessageInputEnvelope
    set?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    disconnect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    delete?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    update?: PrivateMessageVisibilityUpdateWithWhereUniqueWithoutMessageInput | PrivateMessageVisibilityUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: PrivateMessageVisibilityUpdateManyWithWhereWithoutMessageInput | PrivateMessageVisibilityUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
  }

  export type PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput> | PrivateMessageAttachmentCreateWithoutMessageInput[] | PrivateMessageAttachmentUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageAttachmentCreateOrConnectWithoutMessageInput | PrivateMessageAttachmentCreateOrConnectWithoutMessageInput[]
    upsert?: PrivateMessageAttachmentUpsertWithWhereUniqueWithoutMessageInput | PrivateMessageAttachmentUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: PrivateMessageAttachmentCreateManyMessageInputEnvelope
    set?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    disconnect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    delete?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    connect?: PrivateMessageAttachmentWhereUniqueInput | PrivateMessageAttachmentWhereUniqueInput[]
    update?: PrivateMessageAttachmentUpdateWithWhereUniqueWithoutMessageInput | PrivateMessageAttachmentUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: PrivateMessageAttachmentUpdateManyWithWhereWithoutMessageInput | PrivateMessageAttachmentUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: PrivateMessageAttachmentScalarWhereInput | PrivateMessageAttachmentScalarWhereInput[]
  }

  export type PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput> | PrivateMessageVisibilityCreateWithoutMessageInput[] | PrivateMessageVisibilityUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: PrivateMessageVisibilityCreateOrConnectWithoutMessageInput | PrivateMessageVisibilityCreateOrConnectWithoutMessageInput[]
    upsert?: PrivateMessageVisibilityUpsertWithWhereUniqueWithoutMessageInput | PrivateMessageVisibilityUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: PrivateMessageVisibilityCreateManyMessageInputEnvelope
    set?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    disconnect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    delete?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    connect?: PrivateMessageVisibilityWhereUniqueInput | PrivateMessageVisibilityWhereUniqueInput[]
    update?: PrivateMessageVisibilityUpdateWithWhereUniqueWithoutMessageInput | PrivateMessageVisibilityUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: PrivateMessageVisibilityUpdateManyWithWhereWithoutMessageInput | PrivateMessageVisibilityUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
  }

  export type PrivateMessageCreateNestedOneWithoutAttachmentsInput = {
    create?: XOR<PrivateMessageCreateWithoutAttachmentsInput, PrivateMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutAttachmentsInput
    connect?: PrivateMessageWhereUniqueInput
  }

  export type PrivateMessageUpdateOneRequiredWithoutAttachmentsNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutAttachmentsInput, PrivateMessageUncheckedCreateWithoutAttachmentsInput>
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutAttachmentsInput
    upsert?: PrivateMessageUpsertWithoutAttachmentsInput
    connect?: PrivateMessageWhereUniqueInput
    update?: XOR<XOR<PrivateMessageUpdateToOneWithWhereWithoutAttachmentsInput, PrivateMessageUpdateWithoutAttachmentsInput>, PrivateMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PrivateMessageCreateNestedOneWithoutVisibilitiesInput = {
    create?: XOR<PrivateMessageCreateWithoutVisibilitiesInput, PrivateMessageUncheckedCreateWithoutVisibilitiesInput>
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutVisibilitiesInput
    connect?: PrivateMessageWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutPrivateMessageVisibilitiesInput = {
    create?: XOR<AccountCreateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedCreateWithoutPrivateMessageVisibilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPrivateMessageVisibilitiesInput
    connect?: AccountWhereUniqueInput
  }

  export type PrivateMessageUpdateOneRequiredWithoutVisibilitiesNestedInput = {
    create?: XOR<PrivateMessageCreateWithoutVisibilitiesInput, PrivateMessageUncheckedCreateWithoutVisibilitiesInput>
    connectOrCreate?: PrivateMessageCreateOrConnectWithoutVisibilitiesInput
    upsert?: PrivateMessageUpsertWithoutVisibilitiesInput
    connect?: PrivateMessageWhereUniqueInput
    update?: XOR<XOR<PrivateMessageUpdateToOneWithWhereWithoutVisibilitiesInput, PrivateMessageUpdateWithoutVisibilitiesInput>, PrivateMessageUncheckedUpdateWithoutVisibilitiesInput>
  }

  export type AccountUpdateOneRequiredWithoutPrivateMessageVisibilitiesNestedInput = {
    create?: XOR<AccountCreateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedCreateWithoutPrivateMessageVisibilitiesInput>
    connectOrCreate?: AccountCreateOrConnectWithoutPrivateMessageVisibilitiesInput
    upsert?: AccountUpsertWithoutPrivateMessageVisibilitiesInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutPrivateMessageVisibilitiesInput, AccountUpdateWithoutPrivateMessageVisibilitiesInput>, AccountUncheckedUpdateWithoutPrivateMessageVisibilitiesInput>
  }

  export type BrandCreateNestedOneWithoutProductsInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    connect?: BrandWhereUniqueInput
  }

  export type ProductImageCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type VariantCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type ProductOptionCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
  }

  export type ProductTagCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ReviewCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ProductImageEmbeddingCreateNestedManyWithoutProductInput = {
    connect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
  }

  export type ProductImageUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
  }

  export type VariantUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
  }

  export type ProductOptionUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
  }

  export type ProductTagUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ReviewUncheckedCreateNestedManyWithoutProductInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
  }

  export type ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput = {
    connect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
  }

  export type EnumCategoryFieldUpdateOperationsInput = {
    set?: $Enums.Category
  }

  export type EnumProductStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProductStatus
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BrandUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    connectOrCreate?: BrandCreateOrConnectWithoutProductsInput
    upsert?: BrandUpsertWithoutProductsInput
    connect?: BrandWhereUniqueInput
    update?: XOR<XOR<BrandUpdateToOneWithWhereWithoutProductsInput, BrandUpdateWithoutProductsInput>, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type ProductImageUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type VariantUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type ProductOptionUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    upsert?: ProductOptionUpsertWithWhereUniqueWithoutProductInput | ProductOptionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    set?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    disconnect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    delete?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    update?: ProductOptionUpdateWithWhereUniqueWithoutProductInput | ProductOptionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductOptionUpdateManyWithWhereWithoutProductInput | ProductOptionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
  }

  export type ProductTagUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutProductInput | ProductTagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutProductInput | ProductTagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutProductInput | ProductTagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ReviewUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ProductImageEmbeddingUpdateManyWithoutProductNestedInput = {
    set?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    disconnect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    delete?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    connect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    update?: ProductImageEmbeddingUpdateWithWhereUniqueWithoutProductInput | ProductImageEmbeddingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageEmbeddingUpdateManyWithWhereWithoutProductInput | ProductImageEmbeddingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageEmbeddingScalarWhereInput | ProductImageEmbeddingScalarWhereInput[]
  }

  export type ProductImageUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput> | ProductImageCreateWithoutProductInput[] | ProductImageUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductImageCreateOrConnectWithoutProductInput | ProductImageCreateOrConnectWithoutProductInput[]
    upsert?: ProductImageUpsertWithWhereUniqueWithoutProductInput | ProductImageUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductImageCreateManyProductInputEnvelope
    set?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    disconnect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    delete?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    connect?: ProductImageWhereUniqueInput | ProductImageWhereUniqueInput[]
    update?: ProductImageUpdateWithWhereUniqueWithoutProductInput | ProductImageUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageUpdateManyWithWhereWithoutProductInput | ProductImageUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
  }

  export type VariantUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput> | VariantCreateWithoutProductInput[] | VariantUncheckedCreateWithoutProductInput[]
    connectOrCreate?: VariantCreateOrConnectWithoutProductInput | VariantCreateOrConnectWithoutProductInput[]
    upsert?: VariantUpsertWithWhereUniqueWithoutProductInput | VariantUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: VariantCreateManyProductInputEnvelope
    set?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    disconnect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    delete?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    connect?: VariantWhereUniqueInput | VariantWhereUniqueInput[]
    update?: VariantUpdateWithWhereUniqueWithoutProductInput | VariantUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: VariantUpdateManyWithWhereWithoutProductInput | VariantUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: VariantScalarWhereInput | VariantScalarWhereInput[]
  }

  export type ProductOptionUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput> | ProductOptionCreateWithoutProductInput[] | ProductOptionUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductOptionCreateOrConnectWithoutProductInput | ProductOptionCreateOrConnectWithoutProductInput[]
    upsert?: ProductOptionUpsertWithWhereUniqueWithoutProductInput | ProductOptionUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductOptionCreateManyProductInputEnvelope
    set?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    disconnect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    delete?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    connect?: ProductOptionWhereUniqueInput | ProductOptionWhereUniqueInput[]
    update?: ProductOptionUpdateWithWhereUniqueWithoutProductInput | ProductOptionUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductOptionUpdateManyWithWhereWithoutProductInput | ProductOptionUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
  }

  export type ProductTagUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput> | ProductTagCreateWithoutProductInput[] | ProductTagUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutProductInput | ProductTagCreateOrConnectWithoutProductInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutProductInput | ProductTagUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ProductTagCreateManyProductInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutProductInput | ProductTagUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutProductInput | ProductTagUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ReviewUncheckedUpdateManyWithoutProductNestedInput = {
    create?: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput> | ReviewCreateWithoutProductInput[] | ReviewUncheckedCreateWithoutProductInput[]
    connectOrCreate?: ReviewCreateOrConnectWithoutProductInput | ReviewCreateOrConnectWithoutProductInput[]
    upsert?: ReviewUpsertWithWhereUniqueWithoutProductInput | ReviewUpsertWithWhereUniqueWithoutProductInput[]
    createMany?: ReviewCreateManyProductInputEnvelope
    set?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    disconnect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    delete?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    connect?: ReviewWhereUniqueInput | ReviewWhereUniqueInput[]
    update?: ReviewUpdateWithWhereUniqueWithoutProductInput | ReviewUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ReviewUpdateManyWithWhereWithoutProductInput | ReviewUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
  }

  export type ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput = {
    set?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    disconnect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    delete?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    connect?: ProductImageEmbeddingWhereUniqueInput | ProductImageEmbeddingWhereUniqueInput[]
    update?: ProductImageEmbeddingUpdateWithWhereUniqueWithoutProductInput | ProductImageEmbeddingUpdateWithWhereUniqueWithoutProductInput[]
    updateMany?: ProductImageEmbeddingUpdateManyWithWhereWithoutProductInput | ProductImageEmbeddingUpdateManyWithWhereWithoutProductInput[]
    deleteMany?: ProductImageEmbeddingScalarWhereInput | ProductImageEmbeddingScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutImagesInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductImageEmbeddingCreateNestedOneWithoutImageInput = {
    connect?: ProductImageEmbeddingWhereUniqueInput
  }

  export type ProductImageEmbeddingUncheckedCreateNestedOneWithoutImageInput = {
    connect?: ProductImageEmbeddingWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImagesInput
    upsert?: ProductUpsertWithoutImagesInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImagesInput, ProductUpdateWithoutImagesInput>, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductImageEmbeddingUpdateOneWithoutImageNestedInput = {
    disconnect?: ProductImageEmbeddingWhereInput | boolean
    delete?: ProductImageEmbeddingWhereInput | boolean
    connect?: ProductImageEmbeddingWhereUniqueInput
    update?: XOR<XOR<ProductImageEmbeddingUpdateToOneWithWhereWithoutImageInput, ProductImageEmbeddingUpdateWithoutImageInput>, ProductImageEmbeddingUncheckedUpdateWithoutImageInput>
  }

  export type ProductImageEmbeddingUncheckedUpdateOneWithoutImageNestedInput = {
    disconnect?: ProductImageEmbeddingWhereInput | boolean
    delete?: ProductImageEmbeddingWhereInput | boolean
    connect?: ProductImageEmbeddingWhereUniqueInput
    update?: XOR<XOR<ProductImageEmbeddingUpdateToOneWithWhereWithoutImageInput, ProductImageEmbeddingUpdateWithoutImageInput>, ProductImageEmbeddingUncheckedUpdateWithoutImageInput>
  }

  export type ProductCreateNestedOneWithoutOptionsInput = {
    create?: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOptionsInput
    connect?: ProductWhereUniqueInput
  }

  export type ProductOptionValueCreateNestedManyWithoutOptionInput = {
    create?: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput> | ProductOptionValueCreateWithoutOptionInput[] | ProductOptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutOptionInput | ProductOptionValueCreateOrConnectWithoutOptionInput[]
    createMany?: ProductOptionValueCreateManyOptionInputEnvelope
    connect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
  }

  export type VariantOptionCreateNestedManyWithoutOptionInput = {
    create?: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput> | VariantOptionCreateWithoutOptionInput[] | VariantOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutOptionInput | VariantOptionCreateOrConnectWithoutOptionInput[]
    createMany?: VariantOptionCreateManyOptionInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type ProductOptionValueUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput> | ProductOptionValueCreateWithoutOptionInput[] | ProductOptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutOptionInput | ProductOptionValueCreateOrConnectWithoutOptionInput[]
    createMany?: ProductOptionValueCreateManyOptionInputEnvelope
    connect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
  }

  export type VariantOptionUncheckedCreateNestedManyWithoutOptionInput = {
    create?: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput> | VariantOptionCreateWithoutOptionInput[] | VariantOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutOptionInput | VariantOptionCreateOrConnectWithoutOptionInput[]
    createMany?: VariantOptionCreateManyOptionInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type ProductUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutOptionsInput
    upsert?: ProductUpsertWithoutOptionsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutOptionsInput, ProductUpdateWithoutOptionsInput>, ProductUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductOptionValueUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput> | ProductOptionValueCreateWithoutOptionInput[] | ProductOptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutOptionInput | ProductOptionValueCreateOrConnectWithoutOptionInput[]
    upsert?: ProductOptionValueUpsertWithWhereUniqueWithoutOptionInput | ProductOptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ProductOptionValueCreateManyOptionInputEnvelope
    set?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    disconnect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    delete?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    connect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    update?: ProductOptionValueUpdateWithWhereUniqueWithoutOptionInput | ProductOptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ProductOptionValueUpdateManyWithWhereWithoutOptionInput | ProductOptionValueUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ProductOptionValueScalarWhereInput | ProductOptionValueScalarWhereInput[]
  }

  export type VariantOptionUpdateManyWithoutOptionNestedInput = {
    create?: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput> | VariantOptionCreateWithoutOptionInput[] | VariantOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutOptionInput | VariantOptionCreateOrConnectWithoutOptionInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutOptionInput | VariantOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: VariantOptionCreateManyOptionInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutOptionInput | VariantOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutOptionInput | VariantOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type ProductOptionValueUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput> | ProductOptionValueCreateWithoutOptionInput[] | ProductOptionValueUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutOptionInput | ProductOptionValueCreateOrConnectWithoutOptionInput[]
    upsert?: ProductOptionValueUpsertWithWhereUniqueWithoutOptionInput | ProductOptionValueUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: ProductOptionValueCreateManyOptionInputEnvelope
    set?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    disconnect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    delete?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    connect?: ProductOptionValueWhereUniqueInput | ProductOptionValueWhereUniqueInput[]
    update?: ProductOptionValueUpdateWithWhereUniqueWithoutOptionInput | ProductOptionValueUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: ProductOptionValueUpdateManyWithWhereWithoutOptionInput | ProductOptionValueUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: ProductOptionValueScalarWhereInput | ProductOptionValueScalarWhereInput[]
  }

  export type VariantOptionUncheckedUpdateManyWithoutOptionNestedInput = {
    create?: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput> | VariantOptionCreateWithoutOptionInput[] | VariantOptionUncheckedCreateWithoutOptionInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutOptionInput | VariantOptionCreateOrConnectWithoutOptionInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutOptionInput | VariantOptionUpsertWithWhereUniqueWithoutOptionInput[]
    createMany?: VariantOptionCreateManyOptionInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutOptionInput | VariantOptionUpdateWithWhereUniqueWithoutOptionInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutOptionInput | VariantOptionUpdateManyWithWhereWithoutOptionInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type ProductOptionCreateNestedOneWithoutValuesInput = {
    create?: XOR<ProductOptionCreateWithoutValuesInput, ProductOptionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutValuesInput
    connect?: ProductOptionWhereUniqueInput
  }

  export type VariantOptionCreateNestedManyWithoutValueInput = {
    create?: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput> | VariantOptionCreateWithoutValueInput[] | VariantOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutValueInput | VariantOptionCreateOrConnectWithoutValueInput[]
    createMany?: VariantOptionCreateManyValueInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type VariantOptionUncheckedCreateNestedManyWithoutValueInput = {
    create?: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput> | VariantOptionCreateWithoutValueInput[] | VariantOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutValueInput | VariantOptionCreateOrConnectWithoutValueInput[]
    createMany?: VariantOptionCreateManyValueInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type ProductOptionUpdateOneRequiredWithoutValuesNestedInput = {
    create?: XOR<ProductOptionCreateWithoutValuesInput, ProductOptionUncheckedCreateWithoutValuesInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutValuesInput
    upsert?: ProductOptionUpsertWithoutValuesInput
    connect?: ProductOptionWhereUniqueInput
    update?: XOR<XOR<ProductOptionUpdateToOneWithWhereWithoutValuesInput, ProductOptionUpdateWithoutValuesInput>, ProductOptionUncheckedUpdateWithoutValuesInput>
  }

  export type VariantOptionUpdateManyWithoutValueNestedInput = {
    create?: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput> | VariantOptionCreateWithoutValueInput[] | VariantOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutValueInput | VariantOptionCreateOrConnectWithoutValueInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutValueInput | VariantOptionUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: VariantOptionCreateManyValueInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutValueInput | VariantOptionUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutValueInput | VariantOptionUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type VariantOptionUncheckedUpdateManyWithoutValueNestedInput = {
    create?: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput> | VariantOptionCreateWithoutValueInput[] | VariantOptionUncheckedCreateWithoutValueInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutValueInput | VariantOptionCreateOrConnectWithoutValueInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutValueInput | VariantOptionUpsertWithWhereUniqueWithoutValueInput[]
    createMany?: VariantOptionCreateManyValueInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutValueInput | VariantOptionUpdateWithWhereUniqueWithoutValueInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutValueInput | VariantOptionUpdateManyWithWhereWithoutValueInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type VariantCreateNestedOneWithoutOptionsInput = {
    create?: XOR<VariantCreateWithoutOptionsInput, VariantUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: VariantCreateOrConnectWithoutOptionsInput
    connect?: VariantWhereUniqueInput
  }

  export type ProductOptionCreateNestedOneWithoutVariantOptionInput = {
    create?: XOR<ProductOptionCreateWithoutVariantOptionInput, ProductOptionUncheckedCreateWithoutVariantOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutVariantOptionInput
    connect?: ProductOptionWhereUniqueInput
  }

  export type ProductOptionValueCreateNestedOneWithoutVariantLinksInput = {
    create?: XOR<ProductOptionValueCreateWithoutVariantLinksInput, ProductOptionValueUncheckedCreateWithoutVariantLinksInput>
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutVariantLinksInput
    connect?: ProductOptionValueWhereUniqueInput
  }

  export type VariantUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<VariantCreateWithoutOptionsInput, VariantUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: VariantCreateOrConnectWithoutOptionsInput
    upsert?: VariantUpsertWithoutOptionsInput
    connect?: VariantWhereUniqueInput
    update?: XOR<XOR<VariantUpdateToOneWithWhereWithoutOptionsInput, VariantUpdateWithoutOptionsInput>, VariantUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductOptionUpdateOneRequiredWithoutVariantOptionNestedInput = {
    create?: XOR<ProductOptionCreateWithoutVariantOptionInput, ProductOptionUncheckedCreateWithoutVariantOptionInput>
    connectOrCreate?: ProductOptionCreateOrConnectWithoutVariantOptionInput
    upsert?: ProductOptionUpsertWithoutVariantOptionInput
    connect?: ProductOptionWhereUniqueInput
    update?: XOR<XOR<ProductOptionUpdateToOneWithWhereWithoutVariantOptionInput, ProductOptionUpdateWithoutVariantOptionInput>, ProductOptionUncheckedUpdateWithoutVariantOptionInput>
  }

  export type ProductOptionValueUpdateOneRequiredWithoutVariantLinksNestedInput = {
    create?: XOR<ProductOptionValueCreateWithoutVariantLinksInput, ProductOptionValueUncheckedCreateWithoutVariantLinksInput>
    connectOrCreate?: ProductOptionValueCreateOrConnectWithoutVariantLinksInput
    upsert?: ProductOptionValueUpsertWithoutVariantLinksInput
    connect?: ProductOptionValueWhereUniqueInput
    update?: XOR<XOR<ProductOptionValueUpdateToOneWithWhereWithoutVariantLinksInput, ProductOptionValueUpdateWithoutVariantLinksInput>, ProductOptionValueUncheckedUpdateWithoutVariantLinksInput>
  }

  export type ProductCreateNestedOneWithoutVariantsInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    connect?: ProductWhereUniqueInput
  }

  export type VariantImageCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput> | VariantImageCreateWithoutVariantInput[] | VariantImageUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantImageCreateOrConnectWithoutVariantInput | VariantImageCreateOrConnectWithoutVariantInput[]
    createMany?: VariantImageCreateManyVariantInputEnvelope
    connect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
  }

  export type VariantOptionCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput> | VariantOptionCreateWithoutVariantInput[] | VariantOptionUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutVariantInput | VariantOptionCreateOrConnectWithoutVariantInput[]
    createMany?: VariantOptionCreateManyVariantInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type VariantImageUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput> | VariantImageCreateWithoutVariantInput[] | VariantImageUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantImageCreateOrConnectWithoutVariantInput | VariantImageCreateOrConnectWithoutVariantInput[]
    createMany?: VariantImageCreateManyVariantInputEnvelope
    connect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
  }

  export type VariantOptionUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput> | VariantOptionCreateWithoutVariantInput[] | VariantOptionUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutVariantInput | VariantOptionCreateOrConnectWithoutVariantInput[]
    createMany?: VariantOptionCreateManyVariantInputEnvelope
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type ProductUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutVariantsInput
    upsert?: ProductUpsertWithoutVariantsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutVariantsInput, ProductUpdateWithoutVariantsInput>, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type VariantImageUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput> | VariantImageCreateWithoutVariantInput[] | VariantImageUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantImageCreateOrConnectWithoutVariantInput | VariantImageCreateOrConnectWithoutVariantInput[]
    upsert?: VariantImageUpsertWithWhereUniqueWithoutVariantInput | VariantImageUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantImageCreateManyVariantInputEnvelope
    set?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    disconnect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    delete?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    connect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    update?: VariantImageUpdateWithWhereUniqueWithoutVariantInput | VariantImageUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantImageUpdateManyWithWhereWithoutVariantInput | VariantImageUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantImageScalarWhereInput | VariantImageScalarWhereInput[]
  }

  export type VariantOptionUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput> | VariantOptionCreateWithoutVariantInput[] | VariantOptionUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutVariantInput | VariantOptionCreateOrConnectWithoutVariantInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutVariantInput | VariantOptionUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantOptionCreateManyVariantInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutVariantInput | VariantOptionUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutVariantInput | VariantOptionUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type VariantImageUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput> | VariantImageCreateWithoutVariantInput[] | VariantImageUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantImageCreateOrConnectWithoutVariantInput | VariantImageCreateOrConnectWithoutVariantInput[]
    upsert?: VariantImageUpsertWithWhereUniqueWithoutVariantInput | VariantImageUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantImageCreateManyVariantInputEnvelope
    set?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    disconnect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    delete?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    connect?: VariantImageWhereUniqueInput | VariantImageWhereUniqueInput[]
    update?: VariantImageUpdateWithWhereUniqueWithoutVariantInput | VariantImageUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantImageUpdateManyWithWhereWithoutVariantInput | VariantImageUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantImageScalarWhereInput | VariantImageScalarWhereInput[]
  }

  export type VariantOptionUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput> | VariantOptionCreateWithoutVariantInput[] | VariantOptionUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: VariantOptionCreateOrConnectWithoutVariantInput | VariantOptionCreateOrConnectWithoutVariantInput[]
    upsert?: VariantOptionUpsertWithWhereUniqueWithoutVariantInput | VariantOptionUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: VariantOptionCreateManyVariantInputEnvelope
    set?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    disconnect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    delete?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    connect?: VariantOptionWhereUniqueInput | VariantOptionWhereUniqueInput[]
    update?: VariantOptionUpdateWithWhereUniqueWithoutVariantInput | VariantOptionUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: VariantOptionUpdateManyWithWhereWithoutVariantInput | VariantOptionUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
  }

  export type VariantCreateNestedOneWithoutImagesInput = {
    create?: XOR<VariantCreateWithoutImagesInput, VariantUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VariantCreateOrConnectWithoutImagesInput
    connect?: VariantWhereUniqueInput
  }

  export type VariantUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<VariantCreateWithoutImagesInput, VariantUncheckedCreateWithoutImagesInput>
    connectOrCreate?: VariantCreateOrConnectWithoutImagesInput
    upsert?: VariantUpsertWithoutImagesInput
    connect?: VariantWhereUniqueInput
    update?: XOR<XOR<VariantUpdateToOneWithWhereWithoutImagesInput, VariantUpdateWithoutImagesInput>, VariantUncheckedUpdateWithoutImagesInput>
  }

  export type ProductTagCreateNestedManyWithoutTagInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ProductTagUncheckedCreateNestedManyWithoutTagInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
  }

  export type ProductTagUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutTagInput | ProductTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutTagInput | ProductTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutTagInput | ProductTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ProductTagUncheckedUpdateManyWithoutTagNestedInput = {
    create?: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput> | ProductTagCreateWithoutTagInput[] | ProductTagUncheckedCreateWithoutTagInput[]
    connectOrCreate?: ProductTagCreateOrConnectWithoutTagInput | ProductTagCreateOrConnectWithoutTagInput[]
    upsert?: ProductTagUpsertWithWhereUniqueWithoutTagInput | ProductTagUpsertWithWhereUniqueWithoutTagInput[]
    createMany?: ProductTagCreateManyTagInputEnvelope
    set?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    disconnect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    delete?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    connect?: ProductTagWhereUniqueInput | ProductTagWhereUniqueInput[]
    update?: ProductTagUpdateWithWhereUniqueWithoutTagInput | ProductTagUpdateWithWhereUniqueWithoutTagInput[]
    updateMany?: ProductTagUpdateManyWithWhereWithoutTagInput | ProductTagUpdateManyWithWhereWithoutTagInput[]
    deleteMany?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
  }

  export type ProductCreateNestedOneWithoutTagsInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput
    connect?: ProductWhereUniqueInput
  }

  export type TagCreateNestedOneWithoutProductsInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput
    connect?: TagWhereUniqueInput
  }

  export type ProductUpdateOneRequiredWithoutTagsNestedInput = {
    create?: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutTagsInput
    upsert?: ProductUpsertWithoutTagsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutTagsInput, ProductUpdateWithoutTagsInput>, ProductUncheckedUpdateWithoutTagsInput>
  }

  export type TagUpdateOneRequiredWithoutProductsNestedInput = {
    create?: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
    connectOrCreate?: TagCreateOrConnectWithoutProductsInput
    upsert?: TagUpsertWithoutProductsInput
    connect?: TagWhereUniqueInput
    update?: XOR<XOR<TagUpdateToOneWithWhereWithoutProductsInput, TagUpdateWithoutProductsInput>, TagUncheckedUpdateWithoutProductsInput>
  }

  export type ProductImageUpdateOneRequiredWithoutEmbeddingNestedInput = {
    create?: XOR<ProductImageCreateWithoutEmbeddingInput, ProductImageUncheckedCreateWithoutEmbeddingInput>
    connectOrCreate?: ProductImageCreateOrConnectWithoutEmbeddingInput
    upsert?: ProductImageUpsertWithoutEmbeddingInput
    connect?: ProductImageWhereUniqueInput
    update?: XOR<XOR<ProductImageUpdateToOneWithWhereWithoutEmbeddingInput, ProductImageUpdateWithoutEmbeddingInput>, ProductImageUncheckedUpdateWithoutEmbeddingInput>
  }

  export type ProductUpdateOneRequiredWithoutImageVectorsNestedInput = {
    create?: XOR<ProductCreateWithoutImageVectorsInput, ProductUncheckedCreateWithoutImageVectorsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutImageVectorsInput
    upsert?: ProductUpsertWithoutImageVectorsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutImageVectorsInput, ProductUpdateWithoutImageVectorsInput>, ProductUncheckedUpdateWithoutImageVectorsInput>
  }

  export type ReviewImageCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput> | ReviewImageCreateWithoutReviewInput[] | ReviewImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewImageCreateOrConnectWithoutReviewInput | ReviewImageCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewImageCreateManyReviewInputEnvelope
    connect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
  }

  export type ReviewVoteCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type ReviewReplyCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type UserCreateNestedOneWithoutReviewsInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    connect?: UserWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutReviewsInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    connect?: ProductWhereUniqueInput
  }

  export type ReviewImageUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput> | ReviewImageCreateWithoutReviewInput[] | ReviewImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewImageCreateOrConnectWithoutReviewInput | ReviewImageCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewImageCreateManyReviewInputEnvelope
    connect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
  }

  export type ReviewVoteUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
  }

  export type ReviewReportUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
  }

  export type ReviewReplyUncheckedCreateNestedManyWithoutReviewInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumReviewVisibilityFieldUpdateOperationsInput = {
    set?: $Enums.ReviewVisibility
  }

  export type ReviewImageUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput> | ReviewImageCreateWithoutReviewInput[] | ReviewImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewImageCreateOrConnectWithoutReviewInput | ReviewImageCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewImageUpsertWithWhereUniqueWithoutReviewInput | ReviewImageUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewImageCreateManyReviewInputEnvelope
    set?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    disconnect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    delete?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    connect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    update?: ReviewImageUpdateWithWhereUniqueWithoutReviewInput | ReviewImageUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewImageUpdateManyWithWhereWithoutReviewInput | ReviewImageUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewImageScalarWhereInput | ReviewImageScalarWhereInput[]
  }

  export type ReviewVoteUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutReviewInput | ReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutReviewInput | ReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutReviewInput | ReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type ReviewReplyUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutReviewInput | ReviewReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutReviewInput | ReviewReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutReviewInput | ReviewReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type UserUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewsInput
    upsert?: UserUpsertWithoutReviewsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewsInput, UserUpdateWithoutReviewsInput>, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateOneRequiredWithoutReviewsNestedInput = {
    create?: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    connectOrCreate?: ProductCreateOrConnectWithoutReviewsInput
    upsert?: ProductUpsertWithoutReviewsInput
    connect?: ProductWhereUniqueInput
    update?: XOR<XOR<ProductUpdateToOneWithWhereWithoutReviewsInput, ProductUpdateWithoutReviewsInput>, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ReviewImageUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput> | ReviewImageCreateWithoutReviewInput[] | ReviewImageUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewImageCreateOrConnectWithoutReviewInput | ReviewImageCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewImageUpsertWithWhereUniqueWithoutReviewInput | ReviewImageUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewImageCreateManyReviewInputEnvelope
    set?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    disconnect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    delete?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    connect?: ReviewImageWhereUniqueInput | ReviewImageWhereUniqueInput[]
    update?: ReviewImageUpdateWithWhereUniqueWithoutReviewInput | ReviewImageUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewImageUpdateManyWithWhereWithoutReviewInput | ReviewImageUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewImageScalarWhereInput | ReviewImageScalarWhereInput[]
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput> | ReviewVoteCreateWithoutReviewInput[] | ReviewVoteUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewVoteCreateOrConnectWithoutReviewInput | ReviewVoteCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewVoteUpsertWithWhereUniqueWithoutReviewInput | ReviewVoteUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewVoteCreateManyReviewInputEnvelope
    set?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    disconnect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    delete?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    connect?: ReviewVoteWhereUniqueInput | ReviewVoteWhereUniqueInput[]
    update?: ReviewVoteUpdateWithWhereUniqueWithoutReviewInput | ReviewVoteUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewVoteUpdateManyWithWhereWithoutReviewInput | ReviewVoteUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
  }

  export type ReviewReportUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput> | ReviewReportCreateWithoutReviewInput[] | ReviewReportUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReportCreateOrConnectWithoutReviewInput | ReviewReportCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReportUpsertWithWhereUniqueWithoutReviewInput | ReviewReportUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReportCreateManyReviewInputEnvelope
    set?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    disconnect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    delete?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    connect?: ReviewReportWhereUniqueInput | ReviewReportWhereUniqueInput[]
    update?: ReviewReportUpdateWithWhereUniqueWithoutReviewInput | ReviewReportUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReportUpdateManyWithWhereWithoutReviewInput | ReviewReportUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
  }

  export type ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput = {
    create?: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput> | ReviewReplyCreateWithoutReviewInput[] | ReviewReplyUncheckedCreateWithoutReviewInput[]
    connectOrCreate?: ReviewReplyCreateOrConnectWithoutReviewInput | ReviewReplyCreateOrConnectWithoutReviewInput[]
    upsert?: ReviewReplyUpsertWithWhereUniqueWithoutReviewInput | ReviewReplyUpsertWithWhereUniqueWithoutReviewInput[]
    createMany?: ReviewReplyCreateManyReviewInputEnvelope
    set?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    disconnect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    delete?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    connect?: ReviewReplyWhereUniqueInput | ReviewReplyWhereUniqueInput[]
    update?: ReviewReplyUpdateWithWhereUniqueWithoutReviewInput | ReviewReplyUpdateWithWhereUniqueWithoutReviewInput[]
    updateMany?: ReviewReplyUpdateManyWithWhereWithoutReviewInput | ReviewReplyUpdateManyWithWhereWithoutReviewInput[]
    deleteMany?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
  }

  export type ReviewCreateNestedOneWithoutImagesInput = {
    create?: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutImagesInput
    connect?: ReviewWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutImagesInput
    upsert?: ReviewUpsertWithoutImagesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutImagesInput, ReviewUpdateWithoutImagesInput>, ReviewUncheckedUpdateWithoutImagesInput>
  }

  export type ReviewCreateNestedOneWithoutVotesInput = {
    create?: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutVotesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewVotesInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumVoteTypeFieldUpdateOperationsInput = {
    set?: $Enums.VoteType
  }

  export type ReviewUpdateOneRequiredWithoutVotesNestedInput = {
    create?: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutVotesInput
    upsert?: ReviewUpsertWithoutVotesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutVotesInput, ReviewUpdateWithoutVotesInput>, ReviewUncheckedUpdateWithoutVotesInput>
  }

  export type UserUpdateOneRequiredWithoutReviewVotesNestedInput = {
    create?: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewVotesInput
    upsert?: UserUpsertWithoutReviewVotesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewVotesInput, UserUpdateWithoutReviewVotesInput>, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type ReviewCreateNestedOneWithoutReportsInput = {
    create?: XOR<ReviewCreateWithoutReportsInput, ReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReportsInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewReportsInput = {
    create?: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReportsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumReportReasonFieldUpdateOperationsInput = {
    set?: $Enums.ReportReason
  }

  export type ReviewUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<ReviewCreateWithoutReportsInput, ReviewUncheckedCreateWithoutReportsInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutReportsInput
    upsert?: ReviewUpsertWithoutReportsInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutReportsInput, ReviewUpdateWithoutReportsInput>, ReviewUncheckedUpdateWithoutReportsInput>
  }

  export type UserUpdateOneRequiredWithoutReviewReportsNestedInput = {
    create?: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReportsInput
    upsert?: UserUpsertWithoutReviewReportsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewReportsInput, UserUpdateWithoutReviewReportsInput>, UserUncheckedUpdateWithoutReviewReportsInput>
  }

  export type ReviewCreateNestedOneWithoutRepliesInput = {
    create?: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutRepliesInput
    connect?: ReviewWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReviewReplaysInput = {
    create?: XOR<UserCreateWithoutReviewReplaysInput, UserUncheckedCreateWithoutReviewReplaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReplaysInput
    connect?: UserWhereUniqueInput
  }

  export type ReviewUpdateOneRequiredWithoutRepliesNestedInput = {
    create?: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    connectOrCreate?: ReviewCreateOrConnectWithoutRepliesInput
    upsert?: ReviewUpsertWithoutRepliesInput
    connect?: ReviewWhereUniqueInput
    update?: XOR<XOR<ReviewUpdateToOneWithWhereWithoutRepliesInput, ReviewUpdateWithoutRepliesInput>, ReviewUncheckedUpdateWithoutRepliesInput>
  }

  export type UserUpdateOneRequiredWithoutReviewReplaysNestedInput = {
    create?: XOR<UserCreateWithoutReviewReplaysInput, UserUncheckedCreateWithoutReviewReplaysInput>
    connectOrCreate?: UserCreateOrConnectWithoutReviewReplaysInput
    upsert?: UserUpsertWithoutReviewReplaysInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReviewReplaysInput, UserUpdateWithoutReviewReplaysInput>, UserUncheckedUpdateWithoutReviewReplaysInput>
  }

  export type AccountCreateNestedOneWithoutNotificationInput = {
    create?: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationInput
    connect?: AccountWhereUniqueInput
  }

  export type NotificationRecipientCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type AccountUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationInput
    upsert?: AccountUpsertWithoutNotificationInput
    disconnect?: AccountWhereInput | boolean
    delete?: AccountWhereInput | boolean
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNotificationInput, AccountUpdateWithoutNotificationInput>, AccountUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationRecipientUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutNotificationInput | NotificationRecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput = {
    create?: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput> | NotificationRecipientCreateWithoutNotificationInput[] | NotificationRecipientUncheckedCreateWithoutNotificationInput[]
    connectOrCreate?: NotificationRecipientCreateOrConnectWithoutNotificationInput | NotificationRecipientCreateOrConnectWithoutNotificationInput[]
    upsert?: NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput[]
    createMany?: NotificationRecipientCreateManyNotificationInputEnvelope
    set?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    disconnect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    delete?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    connect?: NotificationRecipientWhereUniqueInput | NotificationRecipientWhereUniqueInput[]
    update?: NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput | NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput[]
    updateMany?: NotificationRecipientUpdateManyWithWhereWithoutNotificationInput | NotificationRecipientUpdateManyWithWhereWithoutNotificationInput[]
    deleteMany?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
  }

  export type NotificationCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
  }

  export type AccountCreateNestedOneWithoutNotificationRecipientInput = {
    create?: XOR<AccountCreateWithoutNotificationRecipientInput, AccountUncheckedCreateWithoutNotificationRecipientInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationRecipientInput
    connect?: AccountWhereUniqueInput
  }

  export type NotificationUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: NotificationCreateOrConnectWithoutRecipientsInput
    upsert?: NotificationUpsertWithoutRecipientsInput
    connect?: NotificationWhereUniqueInput
    update?: XOR<XOR<NotificationUpdateToOneWithWhereWithoutRecipientsInput, NotificationUpdateWithoutRecipientsInput>, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type AccountUpdateOneRequiredWithoutNotificationRecipientNestedInput = {
    create?: XOR<AccountCreateWithoutNotificationRecipientInput, AccountUncheckedCreateWithoutNotificationRecipientInput>
    connectOrCreate?: AccountCreateOrConnectWithoutNotificationRecipientInput
    upsert?: AccountUpsertWithoutNotificationRecipientInput
    connect?: AccountWhereUniqueInput
    update?: XOR<XOR<AccountUpdateToOneWithWhereWithoutNotificationRecipientInput, AccountUpdateWithoutNotificationRecipientInput>, AccountUncheckedUpdateWithoutNotificationRecipientInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedEnumStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusFilter<$PrismaModel> | $Enums.Status
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumProviderFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderFilter<$PrismaModel> | $Enums.Provider
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Status | EnumStatusFieldRefInput<$PrismaModel>
    in?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.Status[] | ListEnumStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumStatusWithAggregatesFilter<$PrismaModel> | $Enums.Status
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumStatusFilter<$PrismaModel>
    _max?: NestedEnumStatusFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedEnumProviderWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Provider | EnumProviderFieldRefInput<$PrismaModel>
    in?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    notIn?: $Enums.Provider[] | ListEnumProviderFieldRefInput<$PrismaModel>
    not?: NestedEnumProviderWithAggregatesFilter<$PrismaModel> | $Enums.Provider
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProviderFilter<$PrismaModel>
    _max?: NestedEnumProviderFilter<$PrismaModel>
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumGenderNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableFilter<$PrismaModel> | $Enums.Gender | null
  }

  export type NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Gender | EnumGenderFieldRefInput<$PrismaModel> | null
    in?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Gender[] | ListEnumGenderFieldRefInput<$PrismaModel> | null
    not?: NestedEnumGenderNullableWithAggregatesFilter<$PrismaModel> | $Enums.Gender | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumGenderNullableFilter<$PrismaModel>
    _max?: NestedEnumGenderNullableFilter<$PrismaModel>
  }

  export type NestedEnumBrandStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BrandStatus | EnumBrandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBrandStatusFilter<$PrismaModel> | $Enums.BrandStatus
  }

  export type NestedEnumBrandStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BrandStatus | EnumBrandStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BrandStatus[] | ListEnumBrandStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBrandStatusWithAggregatesFilter<$PrismaModel> | $Enums.BrandStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBrandStatusFilter<$PrismaModel>
    _max?: NestedEnumBrandStatusFilter<$PrismaModel>
  }

  export type NestedEnumRevokedReasonNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.RevokedReason | EnumRevokedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRevokedReasonNullableFilter<$PrismaModel> | $Enums.RevokedReason | null
  }

  export type NestedEnumRevokedReasonNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RevokedReason | EnumRevokedReasonFieldRefInput<$PrismaModel> | null
    in?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.RevokedReason[] | ListEnumRevokedReasonFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRevokedReasonNullableWithAggregatesFilter<$PrismaModel> | $Enums.RevokedReason | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRevokedReasonNullableFilter<$PrismaModel>
    _max?: NestedEnumRevokedReasonNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumContentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeFilter<$PrismaModel> | $Enums.ContentType
  }

  export type NestedEnumReactionTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableFilter<$PrismaModel> | $Enums.ReactionType | null
  }

  export type NestedEnumContentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ContentType | EnumContentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ContentType[] | ListEnumContentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumContentTypeWithAggregatesFilter<$PrismaModel> | $Enums.ContentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumContentTypeFilter<$PrismaModel>
    _max?: NestedEnumContentTypeFilter<$PrismaModel>
  }

  export type NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReactionType | EnumReactionTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.ReactionType[] | ListEnumReactionTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumReactionTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.ReactionType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumReactionTypeNullableFilter<$PrismaModel>
  }

  export type NestedEnumCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryFilter<$PrismaModel> | $Enums.Category
  }

  export type NestedEnumProductStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusFilter<$PrismaModel> | $Enums.ProductStatus
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Category | EnumCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.Category[] | ListEnumCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumCategoryWithAggregatesFilter<$PrismaModel> | $Enums.Category
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCategoryFilter<$PrismaModel>
    _max?: NestedEnumCategoryFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumProductStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProductStatus | EnumProductStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProductStatus[] | ListEnumProductStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProductStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProductStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProductStatusFilter<$PrismaModel>
    _max?: NestedEnumProductStatusFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumReviewVisibilityFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewVisibility | EnumReviewVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewVisibilityFilter<$PrismaModel> | $Enums.ReviewVisibility
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumReviewVisibilityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReviewVisibility | EnumReviewVisibilityFieldRefInput<$PrismaModel>
    in?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReviewVisibility[] | ListEnumReviewVisibilityFieldRefInput<$PrismaModel>
    not?: NestedEnumReviewVisibilityWithAggregatesFilter<$PrismaModel> | $Enums.ReviewVisibility
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReviewVisibilityFilter<$PrismaModel>
    _max?: NestedEnumReviewVisibilityFilter<$PrismaModel>
  }

  export type NestedEnumVoteTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeFilter<$PrismaModel> | $Enums.VoteType
  }

  export type NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VoteType | EnumVoteTypeFieldRefInput<$PrismaModel>
    in?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.VoteType[] | ListEnumVoteTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumVoteTypeWithAggregatesFilter<$PrismaModel> | $Enums.VoteType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVoteTypeFilter<$PrismaModel>
    _max?: NestedEnumVoteTypeFilter<$PrismaModel>
  }

  export type NestedEnumReportReasonFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonFilter<$PrismaModel> | $Enums.ReportReason
  }

  export type NestedEnumReportReasonWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ReportReason | EnumReportReasonFieldRefInput<$PrismaModel>
    in?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    notIn?: $Enums.ReportReason[] | ListEnumReportReasonFieldRefInput<$PrismaModel>
    not?: NestedEnumReportReasonWithAggregatesFilter<$PrismaModel> | $Enums.ReportReason
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumReportReasonFilter<$PrismaModel>
    _max?: NestedEnumReportReasonFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type RefreshTokenCreateWithoutAccountInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
  }

  export type RefreshTokenUncheckedCreateWithoutAccountInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
  }

  export type RefreshTokenCreateOrConnectWithoutAccountInput = {
    where: RefreshTokenWhereUniqueInput
    create: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput>
  }

  export type RefreshTokenCreateManyAccountInputEnvelope = {
    data: RefreshTokenCreateManyAccountInput | RefreshTokenCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutAccountInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAccountInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAccountInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
  }

  export type BrandCreateWithoutAccountInput = {
    id?: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductCreateNestedManyWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutAccountInput = {
    id?: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
    Products?: ProductUncheckedCreateNestedManyWithoutBrandInput
  }

  export type BrandCreateOrConnectWithoutAccountInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
  }

  export type PrivateConversationParticipantCreateWithoutAccountInput = {
    id?: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    conversation: PrivateConversationCreateNestedOneWithoutParticipantsInput
  }

  export type PrivateConversationParticipantUncheckedCreateWithoutAccountInput = {
    id?: string
    conversationId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateConversationParticipantCreateOrConnectWithoutAccountInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    create: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput>
  }

  export type PrivateConversationParticipantCreateManyAccountInputEnvelope = {
    data: PrivateConversationParticipantCreateManyAccountInput | PrivateConversationParticipantCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessageCreateWithoutSenderInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    conversation: PrivateConversationCreateNestedOneWithoutMessagesInput
    attachments?: PrivateMessageAttachmentCreateNestedManyWithoutMessageInput
    reactedBy?: AccountCreateNestedOneWithoutReactedMessagesInput
    visibilities?: PrivateMessageVisibilityCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    conversationId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
    attachments?: PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    visibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageCreateOrConnectWithoutSenderInput = {
    where: PrivateMessageWhereUniqueInput
    create: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput>
  }

  export type PrivateMessageCreateManySenderInputEnvelope = {
    data: PrivateMessageCreateManySenderInput | PrivateMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessageCreateWithoutReactedByInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    conversation: PrivateConversationCreateNestedOneWithoutMessagesInput
    sender: AccountCreateNestedOneWithoutSentPrivateMessagesInput
    attachments?: PrivateMessageAttachmentCreateNestedManyWithoutMessageInput
    visibilities?: PrivateMessageVisibilityCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUncheckedCreateWithoutReactedByInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    attachments?: PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    visibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageCreateOrConnectWithoutReactedByInput = {
    where: PrivateMessageWhereUniqueInput
    create: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput>
  }

  export type PrivateMessageCreateManyReactedByInputEnvelope = {
    data: PrivateMessageCreateManyReactedByInput | PrivateMessageCreateManyReactedByInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessageVisibilityCreateWithoutAccountInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    message: PrivateMessageCreateNestedOneWithoutVisibilitiesInput
  }

  export type PrivateMessageVisibilityUncheckedCreateWithoutAccountInput = {
    id?: string
    messageId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageVisibilityCreateOrConnectWithoutAccountInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    create: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput>
  }

  export type PrivateMessageVisibilityCreateManyAccountInputEnvelope = {
    data: PrivateMessageVisibilityCreateManyAccountInput | PrivateMessageVisibilityCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutActorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    recipients?: NotificationRecipientCreateNestedManyWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutActorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    recipients?: NotificationRecipientUncheckedCreateNestedManyWithoutNotificationInput
  }

  export type NotificationCreateOrConnectWithoutActorInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput>
  }

  export type NotificationCreateManyActorInputEnvelope = {
    data: NotificationCreateManyActorInput | NotificationCreateManyActorInput[]
    skipDuplicates?: boolean
  }

  export type NotificationRecipientCreateWithoutAccountInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    notification: NotificationCreateNestedOneWithoutRecipientsInput
  }

  export type NotificationRecipientUncheckedCreateWithoutAccountInput = {
    id?: string
    notificationId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientCreateOrConnectWithoutAccountInput = {
    where: NotificationRecipientWhereUniqueInput
    create: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput>
  }

  export type NotificationRecipientCreateManyAccountInputEnvelope = {
    data: NotificationRecipientCreateManyAccountInput | NotificationRecipientCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type DeviceTokenCreateWithoutAccountInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
  }

  export type DeviceTokenUncheckedCreateWithoutAccountInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
  }

  export type DeviceTokenCreateOrConnectWithoutAccountInput = {
    where: DeviceTokenWhereUniqueInput
    create: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput>
  }

  export type DeviceTokenCreateManyAccountInputEnvelope = {
    data: DeviceTokenCreateManyAccountInput | DeviceTokenCreateManyAccountInput[]
    skipDuplicates?: boolean
  }

  export type RefreshTokenUpsertWithWhereUniqueWithoutAccountInput = {
    where: RefreshTokenWhereUniqueInput
    update: XOR<RefreshTokenUpdateWithoutAccountInput, RefreshTokenUncheckedUpdateWithoutAccountInput>
    create: XOR<RefreshTokenCreateWithoutAccountInput, RefreshTokenUncheckedCreateWithoutAccountInput>
  }

  export type RefreshTokenUpdateWithWhereUniqueWithoutAccountInput = {
    where: RefreshTokenWhereUniqueInput
    data: XOR<RefreshTokenUpdateWithoutAccountInput, RefreshTokenUncheckedUpdateWithoutAccountInput>
  }

  export type RefreshTokenUpdateManyWithWhereWithoutAccountInput = {
    where: RefreshTokenScalarWhereInput
    data: XOR<RefreshTokenUpdateManyMutationInput, RefreshTokenUncheckedUpdateManyWithoutAccountInput>
  }

  export type RefreshTokenScalarWhereInput = {
    AND?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    OR?: RefreshTokenScalarWhereInput[]
    NOT?: RefreshTokenScalarWhereInput | RefreshTokenScalarWhereInput[]
    id?: StringFilter<"RefreshToken"> | string
    accountId?: StringFilter<"RefreshToken"> | string
    token?: StringFilter<"RefreshToken"> | string
    expiresAt?: DateTimeFilter<"RefreshToken"> | Date | string
    createdAt?: DateTimeFilter<"RefreshToken"> | Date | string
    updatedAt?: DateTimeFilter<"RefreshToken"> | Date | string
    revokedAt?: DateTimeNullableFilter<"RefreshToken"> | Date | string | null
    revokedReason?: EnumRevokedReasonNullableFilter<"RefreshToken"> | $Enums.RevokedReason | null
    jti?: StringFilter<"RefreshToken"> | string
  }

  export type UserUpsertWithoutAccountInput = {
    update: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
    create: XOR<UserCreateWithoutAccountInput, UserUncheckedCreateWithoutAccountInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountInput, UserUncheckedUpdateWithoutAccountInput>
  }

  export type UserUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type BrandUpsertWithoutAccountInput = {
    update: XOR<BrandUpdateWithoutAccountInput, BrandUncheckedUpdateWithoutAccountInput>
    create: XOR<BrandCreateWithoutAccountInput, BrandUncheckedCreateWithoutAccountInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutAccountInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutAccountInput, BrandUncheckedUpdateWithoutAccountInput>
  }

  export type BrandUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductUpdateManyWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Products?: ProductUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type PrivateConversationParticipantUpsertWithWhereUniqueWithoutAccountInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    update: XOR<PrivateConversationParticipantUpdateWithoutAccountInput, PrivateConversationParticipantUncheckedUpdateWithoutAccountInput>
    create: XOR<PrivateConversationParticipantCreateWithoutAccountInput, PrivateConversationParticipantUncheckedCreateWithoutAccountInput>
  }

  export type PrivateConversationParticipantUpdateWithWhereUniqueWithoutAccountInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    data: XOR<PrivateConversationParticipantUpdateWithoutAccountInput, PrivateConversationParticipantUncheckedUpdateWithoutAccountInput>
  }

  export type PrivateConversationParticipantUpdateManyWithWhereWithoutAccountInput = {
    where: PrivateConversationParticipantScalarWhereInput
    data: XOR<PrivateConversationParticipantUpdateManyMutationInput, PrivateConversationParticipantUncheckedUpdateManyWithoutAccountInput>
  }

  export type PrivateConversationParticipantScalarWhereInput = {
    AND?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
    OR?: PrivateConversationParticipantScalarWhereInput[]
    NOT?: PrivateConversationParticipantScalarWhereInput | PrivateConversationParticipantScalarWhereInput[]
    id?: StringFilter<"PrivateConversationParticipant"> | string
    conversationId?: StringFilter<"PrivateConversationParticipant"> | string
    accountId?: StringFilter<"PrivateConversationParticipant"> | string
    unreadCount?: IntFilter<"PrivateConversationParticipant"> | number
    createdAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateConversationParticipant"> | Date | string
  }

  export type PrivateMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: PrivateMessageWhereUniqueInput
    update: XOR<PrivateMessageUpdateWithoutSenderInput, PrivateMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<PrivateMessageCreateWithoutSenderInput, PrivateMessageUncheckedCreateWithoutSenderInput>
  }

  export type PrivateMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: PrivateMessageWhereUniqueInput
    data: XOR<PrivateMessageUpdateWithoutSenderInput, PrivateMessageUncheckedUpdateWithoutSenderInput>
  }

  export type PrivateMessageUpdateManyWithWhereWithoutSenderInput = {
    where: PrivateMessageScalarWhereInput
    data: XOR<PrivateMessageUpdateManyMutationInput, PrivateMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type PrivateMessageScalarWhereInput = {
    AND?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
    OR?: PrivateMessageScalarWhereInput[]
    NOT?: PrivateMessageScalarWhereInput | PrivateMessageScalarWhereInput[]
    id?: StringFilter<"PrivateMessage"> | string
    conversationId?: StringFilter<"PrivateMessage"> | string
    senderId?: StringFilter<"PrivateMessage"> | string
    content?: StringFilter<"PrivateMessage"> | string
    contentType?: EnumContentTypeFilter<"PrivateMessage"> | $Enums.ContentType
    createdAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessage"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PrivateMessage"> | Date | string | null
    reactionType?: EnumReactionTypeNullableFilter<"PrivateMessage"> | $Enums.ReactionType | null
    reactedById?: StringNullableFilter<"PrivateMessage"> | string | null
  }

  export type PrivateMessageUpsertWithWhereUniqueWithoutReactedByInput = {
    where: PrivateMessageWhereUniqueInput
    update: XOR<PrivateMessageUpdateWithoutReactedByInput, PrivateMessageUncheckedUpdateWithoutReactedByInput>
    create: XOR<PrivateMessageCreateWithoutReactedByInput, PrivateMessageUncheckedCreateWithoutReactedByInput>
  }

  export type PrivateMessageUpdateWithWhereUniqueWithoutReactedByInput = {
    where: PrivateMessageWhereUniqueInput
    data: XOR<PrivateMessageUpdateWithoutReactedByInput, PrivateMessageUncheckedUpdateWithoutReactedByInput>
  }

  export type PrivateMessageUpdateManyWithWhereWithoutReactedByInput = {
    where: PrivateMessageScalarWhereInput
    data: XOR<PrivateMessageUpdateManyMutationInput, PrivateMessageUncheckedUpdateManyWithoutReactedByInput>
  }

  export type PrivateMessageVisibilityUpsertWithWhereUniqueWithoutAccountInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    update: XOR<PrivateMessageVisibilityUpdateWithoutAccountInput, PrivateMessageVisibilityUncheckedUpdateWithoutAccountInput>
    create: XOR<PrivateMessageVisibilityCreateWithoutAccountInput, PrivateMessageVisibilityUncheckedCreateWithoutAccountInput>
  }

  export type PrivateMessageVisibilityUpdateWithWhereUniqueWithoutAccountInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    data: XOR<PrivateMessageVisibilityUpdateWithoutAccountInput, PrivateMessageVisibilityUncheckedUpdateWithoutAccountInput>
  }

  export type PrivateMessageVisibilityUpdateManyWithWhereWithoutAccountInput = {
    where: PrivateMessageVisibilityScalarWhereInput
    data: XOR<PrivateMessageVisibilityUpdateManyMutationInput, PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountInput>
  }

  export type PrivateMessageVisibilityScalarWhereInput = {
    AND?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
    OR?: PrivateMessageVisibilityScalarWhereInput[]
    NOT?: PrivateMessageVisibilityScalarWhereInput | PrivateMessageVisibilityScalarWhereInput[]
    id?: StringFilter<"PrivateMessageVisibility"> | string
    messageId?: StringFilter<"PrivateMessageVisibility"> | string
    accountId?: StringFilter<"PrivateMessageVisibility"> | string
    readAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"PrivateMessageVisibility"> | Date | string | null
    createdAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageVisibility"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutActorInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutActorInput, NotificationUncheckedUpdateWithoutActorInput>
    create: XOR<NotificationCreateWithoutActorInput, NotificationUncheckedCreateWithoutActorInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutActorInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutActorInput, NotificationUncheckedUpdateWithoutActorInput>
  }

  export type NotificationUpdateManyWithWhereWithoutActorInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutActorInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    actorId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    data?: JsonNullableFilter<"Notification">
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type NotificationRecipientUpsertWithWhereUniqueWithoutAccountInput = {
    where: NotificationRecipientWhereUniqueInput
    update: XOR<NotificationRecipientUpdateWithoutAccountInput, NotificationRecipientUncheckedUpdateWithoutAccountInput>
    create: XOR<NotificationRecipientCreateWithoutAccountInput, NotificationRecipientUncheckedCreateWithoutAccountInput>
  }

  export type NotificationRecipientUpdateWithWhereUniqueWithoutAccountInput = {
    where: NotificationRecipientWhereUniqueInput
    data: XOR<NotificationRecipientUpdateWithoutAccountInput, NotificationRecipientUncheckedUpdateWithoutAccountInput>
  }

  export type NotificationRecipientUpdateManyWithWhereWithoutAccountInput = {
    where: NotificationRecipientScalarWhereInput
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyWithoutAccountInput>
  }

  export type NotificationRecipientScalarWhereInput = {
    AND?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
    OR?: NotificationRecipientScalarWhereInput[]
    NOT?: NotificationRecipientScalarWhereInput | NotificationRecipientScalarWhereInput[]
    id?: StringFilter<"NotificationRecipient"> | string
    notificationId?: StringFilter<"NotificationRecipient"> | string
    accountId?: StringFilter<"NotificationRecipient"> | string
    readAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    deletedAt?: DateTimeNullableFilter<"NotificationRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"NotificationRecipient"> | Date | string
  }

  export type DeviceTokenUpsertWithWhereUniqueWithoutAccountInput = {
    where: DeviceTokenWhereUniqueInput
    update: XOR<DeviceTokenUpdateWithoutAccountInput, DeviceTokenUncheckedUpdateWithoutAccountInput>
    create: XOR<DeviceTokenCreateWithoutAccountInput, DeviceTokenUncheckedCreateWithoutAccountInput>
  }

  export type DeviceTokenUpdateWithWhereUniqueWithoutAccountInput = {
    where: DeviceTokenWhereUniqueInput
    data: XOR<DeviceTokenUpdateWithoutAccountInput, DeviceTokenUncheckedUpdateWithoutAccountInput>
  }

  export type DeviceTokenUpdateManyWithWhereWithoutAccountInput = {
    where: DeviceTokenScalarWhereInput
    data: XOR<DeviceTokenUpdateManyMutationInput, DeviceTokenUncheckedUpdateManyWithoutAccountInput>
  }

  export type DeviceTokenScalarWhereInput = {
    AND?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    OR?: DeviceTokenScalarWhereInput[]
    NOT?: DeviceTokenScalarWhereInput | DeviceTokenScalarWhereInput[]
    id?: StringFilter<"DeviceToken"> | string
    accountId?: StringFilter<"DeviceToken"> | string
    token?: StringFilter<"DeviceToken"> | string
    createdAt?: DateTimeFilter<"DeviceToken"> | Date | string
    updatedAt?: DateTimeFilter<"DeviceToken"> | Date | string
    isActive?: BoolFilter<"DeviceToken"> | boolean
    lastSeenAt?: DateTimeFilter<"DeviceToken"> | Date | string
  }

  export type AccountCreateWithoutDeviceTokensInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutDeviceTokensInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutDeviceTokensInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutDeviceTokensInput, AccountUncheckedCreateWithoutDeviceTokensInput>
  }

  export type AccountUpsertWithoutDeviceTokensInput = {
    update: XOR<AccountUpdateWithoutDeviceTokensInput, AccountUncheckedUpdateWithoutDeviceTokensInput>
    create: XOR<AccountCreateWithoutDeviceTokensInput, AccountUncheckedCreateWithoutDeviceTokensInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutDeviceTokensInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutDeviceTokensInput, AccountUncheckedUpdateWithoutDeviceTokensInput>
  }

  export type AccountUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutDeviceTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateWithoutUserInput = {
    id?: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUncheckedCreateWithoutUserInput = {
    id?: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressCreateOrConnectWithoutUserInput = {
    where: AddressWhereUniqueInput
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressCreateManyUserInputEnvelope = {
    data: AddressCreateManyUserInput | AddressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutUserInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutUserInput = {
    id?: string
    productId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutUserInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewCreateManyUserInputEnvelope = {
    data: ReviewCreateManyUserInput | ReviewCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewVoteCreateWithoutUserInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteCreateManyUserInputEnvelope = {
    data: ReviewVoteCreateManyUserInput | ReviewVoteCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReportCreateWithoutUserInput = {
    id?: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
    review: ReviewCreateNestedOneWithoutReportsInput
  }

  export type ReviewReportUncheckedCreateWithoutUserInput = {
    id?: string
    reviewId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReportCreateOrConnectWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    create: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput>
  }

  export type ReviewReportCreateManyUserInputEnvelope = {
    data: ReviewReportCreateManyUserInput | ReviewReportCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReplyCreateWithoutAuthorInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    review: ReviewCreateNestedOneWithoutRepliesInput
  }

  export type ReviewReplyUncheckedCreateWithoutAuthorInput = {
    id?: string
    reviewId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateOrConnectWithoutAuthorInput = {
    where: ReviewReplyWhereUniqueInput
    create: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewReplyCreateManyAuthorInputEnvelope = {
    data: ReviewReplyCreateManyAuthorInput | ReviewReplyCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutUserInput = {
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutUserInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type AddressUpsertWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    update: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
    create: XOR<AddressCreateWithoutUserInput, AddressUncheckedCreateWithoutUserInput>
  }

  export type AddressUpdateWithWhereUniqueWithoutUserInput = {
    where: AddressWhereUniqueInput
    data: XOR<AddressUpdateWithoutUserInput, AddressUncheckedUpdateWithoutUserInput>
  }

  export type AddressUpdateManyWithWhereWithoutUserInput = {
    where: AddressScalarWhereInput
    data: XOR<AddressUpdateManyMutationInput, AddressUncheckedUpdateManyWithoutUserInput>
  }

  export type AddressScalarWhereInput = {
    AND?: AddressScalarWhereInput | AddressScalarWhereInput[]
    OR?: AddressScalarWhereInput[]
    NOT?: AddressScalarWhereInput | AddressScalarWhereInput[]
    id?: StringFilter<"Address"> | string
    userId?: StringFilter<"Address"> | string
    government?: StringNullableFilter<"Address"> | string | null
    city?: StringNullableFilter<"Address"> | string | null
    addressLine?: StringNullableFilter<"Address"> | string | null
    landmark?: StringNullableFilter<"Address"> | string | null
    isPrimary?: BoolFilter<"Address"> | boolean
    createdAt?: DateTimeFilter<"Address"> | Date | string
    updatedAt?: DateTimeFilter<"Address"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewCreateWithoutUserInput, ReviewUncheckedCreateWithoutUserInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutUserInput, ReviewUncheckedUpdateWithoutUserInput>
  }

  export type ReviewUpdateManyWithWhereWithoutUserInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewScalarWhereInput = {
    AND?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    OR?: ReviewScalarWhereInput[]
    NOT?: ReviewScalarWhereInput | ReviewScalarWhereInput[]
    id?: StringFilter<"Review"> | string
    productId?: StringFilter<"Review"> | string
    userId?: StringFilter<"Review"> | string
    rating?: FloatFilter<"Review"> | number
    title?: StringFilter<"Review"> | string
    content?: StringFilter<"Review"> | string
    isVerified?: BoolFilter<"Review"> | boolean
    visibility?: EnumReviewVisibilityFilter<"Review"> | $Enums.ReviewVisibility
    reported?: BoolFilter<"Review"> | boolean
    helpfulCount?: IntFilter<"Review"> | number
    createdAt?: DateTimeFilter<"Review"> | Date | string
    updatedAt?: DateTimeFilter<"Review"> | Date | string
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewVoteCreateWithoutUserInput, ReviewVoteUncheckedCreateWithoutUserInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutUserInput, ReviewVoteUncheckedUpdateWithoutUserInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutUserInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewVoteScalarWhereInput = {
    AND?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    OR?: ReviewVoteScalarWhereInput[]
    NOT?: ReviewVoteScalarWhereInput | ReviewVoteScalarWhereInput[]
    id?: StringFilter<"ReviewVote"> | string
    reviewId?: StringFilter<"ReviewVote"> | string
    userId?: StringFilter<"ReviewVote"> | string
    type?: EnumVoteTypeFilter<"ReviewVote"> | $Enums.VoteType
    createdAt?: DateTimeFilter<"ReviewVote"> | Date | string
  }

  export type ReviewReportUpsertWithWhereUniqueWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    update: XOR<ReviewReportUpdateWithoutUserInput, ReviewReportUncheckedUpdateWithoutUserInput>
    create: XOR<ReviewReportCreateWithoutUserInput, ReviewReportUncheckedCreateWithoutUserInput>
  }

  export type ReviewReportUpdateWithWhereUniqueWithoutUserInput = {
    where: ReviewReportWhereUniqueInput
    data: XOR<ReviewReportUpdateWithoutUserInput, ReviewReportUncheckedUpdateWithoutUserInput>
  }

  export type ReviewReportUpdateManyWithWhereWithoutUserInput = {
    where: ReviewReportScalarWhereInput
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyWithoutUserInput>
  }

  export type ReviewReportScalarWhereInput = {
    AND?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
    OR?: ReviewReportScalarWhereInput[]
    NOT?: ReviewReportScalarWhereInput | ReviewReportScalarWhereInput[]
    id?: StringFilter<"ReviewReport"> | string
    reviewId?: StringFilter<"ReviewReport"> | string
    userId?: StringFilter<"ReviewReport"> | string
    reason?: EnumReportReasonFilter<"ReviewReport"> | $Enums.ReportReason
    details?: StringNullableFilter<"ReviewReport"> | string | null
    createdAt?: DateTimeFilter<"ReviewReport"> | Date | string
  }

  export type ReviewReplyUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ReviewReplyWhereUniqueInput
    update: XOR<ReviewReplyUpdateWithoutAuthorInput, ReviewReplyUncheckedUpdateWithoutAuthorInput>
    create: XOR<ReviewReplyCreateWithoutAuthorInput, ReviewReplyUncheckedCreateWithoutAuthorInput>
  }

  export type ReviewReplyUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ReviewReplyWhereUniqueInput
    data: XOR<ReviewReplyUpdateWithoutAuthorInput, ReviewReplyUncheckedUpdateWithoutAuthorInput>
  }

  export type ReviewReplyUpdateManyWithWhereWithoutAuthorInput = {
    where: ReviewReplyScalarWhereInput
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ReviewReplyScalarWhereInput = {
    AND?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
    OR?: ReviewReplyScalarWhereInput[]
    NOT?: ReviewReplyScalarWhereInput | ReviewReplyScalarWhereInput[]
    id?: StringFilter<"ReviewReply"> | string
    reviewId?: StringFilter<"ReviewReply"> | string
    authorId?: StringFilter<"ReviewReply"> | string
    content?: StringFilter<"ReviewReply"> | string
    createdAt?: DateTimeFilter<"ReviewReply"> | Date | string
    updatedAt?: DateTimeFilter<"ReviewReply"> | Date | string
  }

  export type UserCreateWithoutAddressesInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutAddressesInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutAddressesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
  }

  export type UserUpsertWithoutAddressesInput = {
    update: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
    create: XOR<UserCreateWithoutAddressesInput, UserUncheckedCreateWithoutAddressesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAddressesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAddressesInput, UserUncheckedUpdateWithoutAddressesInput>
  }

  export type UserUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutAddressesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type AccountCreateWithoutBrandInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutBrandInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutBrandInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutBrandInput, AccountUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateWithoutBrandInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutBrandInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutBrandInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductCreateManyBrandInputEnvelope = {
    data: ProductCreateManyBrandInput | ProductCreateManyBrandInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutBrandInput = {
    update: XOR<AccountUpdateWithoutBrandInput, AccountUncheckedUpdateWithoutBrandInput>
    create: XOR<AccountCreateWithoutBrandInput, AccountUncheckedCreateWithoutBrandInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutBrandInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutBrandInput, AccountUncheckedUpdateWithoutBrandInput>
  }

  export type AccountUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type ProductUpsertWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
    create: XOR<ProductCreateWithoutBrandInput, ProductUncheckedCreateWithoutBrandInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutBrandInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutBrandInput, ProductUncheckedUpdateWithoutBrandInput>
  }

  export type ProductUpdateManyWithWhereWithoutBrandInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutBrandInput>
  }

  export type ProductScalarWhereInput = {
    AND?: ProductScalarWhereInput | ProductScalarWhereInput[]
    OR?: ProductScalarWhereInput[]
    NOT?: ProductScalarWhereInput | ProductScalarWhereInput[]
    id?: StringFilter<"Product"> | string
    brandId?: StringFilter<"Product"> | string
    category?: EnumCategoryFilter<"Product"> | $Enums.Category
    title?: StringFilter<"Product"> | string
    slug?: StringFilter<"Product"> | string
    description?: StringNullableFilter<"Product"> | string | null
    attributes?: JsonNullableFilter<"Product">
    status?: EnumProductStatusFilter<"Product"> | $Enums.ProductStatus
    material?: StringNullableFilter<"Product"> | string | null
    avgRating?: DecimalFilter<"Product"> | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFilter<"Product"> | number
    createdAt?: DateTimeFilter<"Product"> | Date | string
    updatedAt?: DateTimeFilter<"Product"> | Date | string
  }

  export type AccountCreateWithoutRefreshTokensInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutRefreshTokensInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutRefreshTokensInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutRefreshTokensInput, AccountUncheckedCreateWithoutRefreshTokensInput>
  }

  export type AccountUpsertWithoutRefreshTokensInput = {
    update: XOR<AccountUpdateWithoutRefreshTokensInput, AccountUncheckedUpdateWithoutRefreshTokensInput>
    create: XOR<AccountCreateWithoutRefreshTokensInput, AccountUncheckedCreateWithoutRefreshTokensInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutRefreshTokensInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutRefreshTokensInput, AccountUncheckedUpdateWithoutRefreshTokensInput>
  }

  export type AccountUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutRefreshTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PrivateConversationParticipantCreateWithoutConversationInput = {
    id?: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutConversationParticipantInput
  }

  export type PrivateConversationParticipantUncheckedCreateWithoutConversationInput = {
    id?: string
    accountId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateConversationParticipantCreateOrConnectWithoutConversationInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    create: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type PrivateConversationParticipantCreateManyConversationInputEnvelope = {
    data: PrivateConversationParticipantCreateManyConversationInput | PrivateConversationParticipantCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type PrivateMessageCreateWithoutConversationInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    sender: AccountCreateNestedOneWithoutSentPrivateMessagesInput
    attachments?: PrivateMessageAttachmentCreateNestedManyWithoutMessageInput
    reactedBy?: AccountCreateNestedOneWithoutReactedMessagesInput
    visibilities?: PrivateMessageVisibilityCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUncheckedCreateWithoutConversationInput = {
    id?: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
    attachments?: PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
    visibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageCreateOrConnectWithoutConversationInput = {
    where: PrivateMessageWhereUniqueInput
    create: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput>
  }

  export type PrivateMessageCreateManyConversationInputEnvelope = {
    data: PrivateMessageCreateManyConversationInput | PrivateMessageCreateManyConversationInput[]
    skipDuplicates?: boolean
  }

  export type PrivateConversationParticipantUpsertWithWhereUniqueWithoutConversationInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    update: XOR<PrivateConversationParticipantUpdateWithoutConversationInput, PrivateConversationParticipantUncheckedUpdateWithoutConversationInput>
    create: XOR<PrivateConversationParticipantCreateWithoutConversationInput, PrivateConversationParticipantUncheckedCreateWithoutConversationInput>
  }

  export type PrivateConversationParticipantUpdateWithWhereUniqueWithoutConversationInput = {
    where: PrivateConversationParticipantWhereUniqueInput
    data: XOR<PrivateConversationParticipantUpdateWithoutConversationInput, PrivateConversationParticipantUncheckedUpdateWithoutConversationInput>
  }

  export type PrivateConversationParticipantUpdateManyWithWhereWithoutConversationInput = {
    where: PrivateConversationParticipantScalarWhereInput
    data: XOR<PrivateConversationParticipantUpdateManyMutationInput, PrivateConversationParticipantUncheckedUpdateManyWithoutConversationInput>
  }

  export type PrivateMessageUpsertWithWhereUniqueWithoutConversationInput = {
    where: PrivateMessageWhereUniqueInput
    update: XOR<PrivateMessageUpdateWithoutConversationInput, PrivateMessageUncheckedUpdateWithoutConversationInput>
    create: XOR<PrivateMessageCreateWithoutConversationInput, PrivateMessageUncheckedCreateWithoutConversationInput>
  }

  export type PrivateMessageUpdateWithWhereUniqueWithoutConversationInput = {
    where: PrivateMessageWhereUniqueInput
    data: XOR<PrivateMessageUpdateWithoutConversationInput, PrivateMessageUncheckedUpdateWithoutConversationInput>
  }

  export type PrivateMessageUpdateManyWithWhereWithoutConversationInput = {
    where: PrivateMessageScalarWhereInput
    data: XOR<PrivateMessageUpdateManyMutationInput, PrivateMessageUncheckedUpdateManyWithoutConversationInput>
  }

  export type PrivateConversationCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    messages?: PrivateMessageCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationUncheckedCreateWithoutParticipantsInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    messages?: PrivateMessageUncheckedCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationCreateOrConnectWithoutParticipantsInput = {
    where: PrivateConversationWhereUniqueInput
    create: XOR<PrivateConversationCreateWithoutParticipantsInput, PrivateConversationUncheckedCreateWithoutParticipantsInput>
  }

  export type AccountCreateWithoutConversationParticipantInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutConversationParticipantInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutConversationParticipantInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutConversationParticipantInput, AccountUncheckedCreateWithoutConversationParticipantInput>
  }

  export type PrivateConversationUpsertWithoutParticipantsInput = {
    update: XOR<PrivateConversationUpdateWithoutParticipantsInput, PrivateConversationUncheckedUpdateWithoutParticipantsInput>
    create: XOR<PrivateConversationCreateWithoutParticipantsInput, PrivateConversationUncheckedCreateWithoutParticipantsInput>
    where?: PrivateConversationWhereInput
  }

  export type PrivateConversationUpdateToOneWithWhereWithoutParticipantsInput = {
    where?: PrivateConversationWhereInput
    data: XOR<PrivateConversationUpdateWithoutParticipantsInput, PrivateConversationUncheckedUpdateWithoutParticipantsInput>
  }

  export type PrivateConversationUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: PrivateMessageUpdateManyWithoutConversationNestedInput
  }

  export type PrivateConversationUncheckedUpdateWithoutParticipantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    messages?: PrivateMessageUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AccountUpsertWithoutConversationParticipantInput = {
    update: XOR<AccountUpdateWithoutConversationParticipantInput, AccountUncheckedUpdateWithoutConversationParticipantInput>
    create: XOR<AccountCreateWithoutConversationParticipantInput, AccountUncheckedCreateWithoutConversationParticipantInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutConversationParticipantInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutConversationParticipantInput, AccountUncheckedUpdateWithoutConversationParticipantInput>
  }

  export type AccountUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutConversationParticipantInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PrivateConversationCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    participants?: PrivateConversationParticipantCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationUncheckedCreateWithoutMessagesInput = {
    id?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    archivedAt?: Date | string | null
    participants?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutConversationInput
  }

  export type PrivateConversationCreateOrConnectWithoutMessagesInput = {
    where: PrivateConversationWhereUniqueInput
    create: XOR<PrivateConversationCreateWithoutMessagesInput, PrivateConversationUncheckedCreateWithoutMessagesInput>
  }

  export type AccountCreateWithoutSentPrivateMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutSentPrivateMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutSentPrivateMessagesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutSentPrivateMessagesInput, AccountUncheckedCreateWithoutSentPrivateMessagesInput>
  }

  export type PrivateMessageAttachmentCreateWithoutMessageInput = {
    id?: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageAttachmentUncheckedCreateWithoutMessageInput = {
    id?: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageAttachmentCreateOrConnectWithoutMessageInput = {
    where: PrivateMessageAttachmentWhereUniqueInput
    create: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type PrivateMessageAttachmentCreateManyMessageInputEnvelope = {
    data: PrivateMessageAttachmentCreateManyMessageInput | PrivateMessageAttachmentCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type AccountCreateWithoutReactedMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutReactedMessagesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutReactedMessagesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutReactedMessagesInput, AccountUncheckedCreateWithoutReactedMessagesInput>
  }

  export type PrivateMessageVisibilityCreateWithoutMessageInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutPrivateMessageVisibilitiesInput
  }

  export type PrivateMessageVisibilityUncheckedCreateWithoutMessageInput = {
    id?: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageVisibilityCreateOrConnectWithoutMessageInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    create: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput>
  }

  export type PrivateMessageVisibilityCreateManyMessageInputEnvelope = {
    data: PrivateMessageVisibilityCreateManyMessageInput | PrivateMessageVisibilityCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type PrivateConversationUpsertWithoutMessagesInput = {
    update: XOR<PrivateConversationUpdateWithoutMessagesInput, PrivateConversationUncheckedUpdateWithoutMessagesInput>
    create: XOR<PrivateConversationCreateWithoutMessagesInput, PrivateConversationUncheckedCreateWithoutMessagesInput>
    where?: PrivateConversationWhereInput
  }

  export type PrivateConversationUpdateToOneWithWhereWithoutMessagesInput = {
    where?: PrivateConversationWhereInput
    data: XOR<PrivateConversationUpdateWithoutMessagesInput, PrivateConversationUncheckedUpdateWithoutMessagesInput>
  }

  export type PrivateConversationUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: PrivateConversationParticipantUpdateManyWithoutConversationNestedInput
  }

  export type PrivateConversationUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    archivedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    participants?: PrivateConversationParticipantUncheckedUpdateManyWithoutConversationNestedInput
  }

  export type AccountUpsertWithoutSentPrivateMessagesInput = {
    update: XOR<AccountUpdateWithoutSentPrivateMessagesInput, AccountUncheckedUpdateWithoutSentPrivateMessagesInput>
    create: XOR<AccountCreateWithoutSentPrivateMessagesInput, AccountUncheckedCreateWithoutSentPrivateMessagesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutSentPrivateMessagesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutSentPrivateMessagesInput, AccountUncheckedUpdateWithoutSentPrivateMessagesInput>
  }

  export type AccountUpdateWithoutSentPrivateMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutSentPrivateMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PrivateMessageAttachmentUpsertWithWhereUniqueWithoutMessageInput = {
    where: PrivateMessageAttachmentWhereUniqueInput
    update: XOR<PrivateMessageAttachmentUpdateWithoutMessageInput, PrivateMessageAttachmentUncheckedUpdateWithoutMessageInput>
    create: XOR<PrivateMessageAttachmentCreateWithoutMessageInput, PrivateMessageAttachmentUncheckedCreateWithoutMessageInput>
  }

  export type PrivateMessageAttachmentUpdateWithWhereUniqueWithoutMessageInput = {
    where: PrivateMessageAttachmentWhereUniqueInput
    data: XOR<PrivateMessageAttachmentUpdateWithoutMessageInput, PrivateMessageAttachmentUncheckedUpdateWithoutMessageInput>
  }

  export type PrivateMessageAttachmentUpdateManyWithWhereWithoutMessageInput = {
    where: PrivateMessageAttachmentScalarWhereInput
    data: XOR<PrivateMessageAttachmentUpdateManyMutationInput, PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageInput>
  }

  export type PrivateMessageAttachmentScalarWhereInput = {
    AND?: PrivateMessageAttachmentScalarWhereInput | PrivateMessageAttachmentScalarWhereInput[]
    OR?: PrivateMessageAttachmentScalarWhereInput[]
    NOT?: PrivateMessageAttachmentScalarWhereInput | PrivateMessageAttachmentScalarWhereInput[]
    id?: StringFilter<"PrivateMessageAttachment"> | string
    messageId?: StringFilter<"PrivateMessageAttachment"> | string
    url?: StringFilter<"PrivateMessageAttachment"> | string
    mimeType?: StringNullableFilter<"PrivateMessageAttachment"> | string | null
    createdAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
    updatedAt?: DateTimeFilter<"PrivateMessageAttachment"> | Date | string
  }

  export type AccountUpsertWithoutReactedMessagesInput = {
    update: XOR<AccountUpdateWithoutReactedMessagesInput, AccountUncheckedUpdateWithoutReactedMessagesInput>
    create: XOR<AccountCreateWithoutReactedMessagesInput, AccountUncheckedCreateWithoutReactedMessagesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutReactedMessagesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutReactedMessagesInput, AccountUncheckedUpdateWithoutReactedMessagesInput>
  }

  export type AccountUpdateWithoutReactedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutReactedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type PrivateMessageVisibilityUpsertWithWhereUniqueWithoutMessageInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    update: XOR<PrivateMessageVisibilityUpdateWithoutMessageInput, PrivateMessageVisibilityUncheckedUpdateWithoutMessageInput>
    create: XOR<PrivateMessageVisibilityCreateWithoutMessageInput, PrivateMessageVisibilityUncheckedCreateWithoutMessageInput>
  }

  export type PrivateMessageVisibilityUpdateWithWhereUniqueWithoutMessageInput = {
    where: PrivateMessageVisibilityWhereUniqueInput
    data: XOR<PrivateMessageVisibilityUpdateWithoutMessageInput, PrivateMessageVisibilityUncheckedUpdateWithoutMessageInput>
  }

  export type PrivateMessageVisibilityUpdateManyWithWhereWithoutMessageInput = {
    where: PrivateMessageVisibilityScalarWhereInput
    data: XOR<PrivateMessageVisibilityUpdateManyMutationInput, PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageInput>
  }

  export type PrivateMessageCreateWithoutAttachmentsInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    conversation: PrivateConversationCreateNestedOneWithoutMessagesInput
    sender: AccountCreateNestedOneWithoutSentPrivateMessagesInput
    reactedBy?: AccountCreateNestedOneWithoutReactedMessagesInput
    visibilities?: PrivateMessageVisibilityCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageUncheckedCreateWithoutAttachmentsInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
    visibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageCreateOrConnectWithoutAttachmentsInput = {
    where: PrivateMessageWhereUniqueInput
    create: XOR<PrivateMessageCreateWithoutAttachmentsInput, PrivateMessageUncheckedCreateWithoutAttachmentsInput>
  }

  export type PrivateMessageUpsertWithoutAttachmentsInput = {
    update: XOR<PrivateMessageUpdateWithoutAttachmentsInput, PrivateMessageUncheckedUpdateWithoutAttachmentsInput>
    create: XOR<PrivateMessageCreateWithoutAttachmentsInput, PrivateMessageUncheckedCreateWithoutAttachmentsInput>
    where?: PrivateMessageWhereInput
  }

  export type PrivateMessageUpdateToOneWithWhereWithoutAttachmentsInput = {
    where?: PrivateMessageWhereInput
    data: XOR<PrivateMessageUpdateWithoutAttachmentsInput, PrivateMessageUncheckedUpdateWithoutAttachmentsInput>
  }

  export type PrivateMessageUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    conversation?: PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput
    reactedBy?: AccountUpdateOneWithoutReactedMessagesNestedInput
    visibilities?: PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateWithoutAttachmentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
    visibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageCreateWithoutVisibilitiesInput = {
    id?: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    conversation: PrivateConversationCreateNestedOneWithoutMessagesInput
    sender: AccountCreateNestedOneWithoutSentPrivateMessagesInput
    attachments?: PrivateMessageAttachmentCreateNestedManyWithoutMessageInput
    reactedBy?: AccountCreateNestedOneWithoutReactedMessagesInput
  }

  export type PrivateMessageUncheckedCreateWithoutVisibilitiesInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
    attachments?: PrivateMessageAttachmentUncheckedCreateNestedManyWithoutMessageInput
  }

  export type PrivateMessageCreateOrConnectWithoutVisibilitiesInput = {
    where: PrivateMessageWhereUniqueInput
    create: XOR<PrivateMessageCreateWithoutVisibilitiesInput, PrivateMessageUncheckedCreateWithoutVisibilitiesInput>
  }

  export type AccountCreateWithoutPrivateMessageVisibilitiesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutPrivateMessageVisibilitiesInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutPrivateMessageVisibilitiesInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedCreateWithoutPrivateMessageVisibilitiesInput>
  }

  export type PrivateMessageUpsertWithoutVisibilitiesInput = {
    update: XOR<PrivateMessageUpdateWithoutVisibilitiesInput, PrivateMessageUncheckedUpdateWithoutVisibilitiesInput>
    create: XOR<PrivateMessageCreateWithoutVisibilitiesInput, PrivateMessageUncheckedCreateWithoutVisibilitiesInput>
    where?: PrivateMessageWhereInput
  }

  export type PrivateMessageUpdateToOneWithWhereWithoutVisibilitiesInput = {
    where?: PrivateMessageWhereInput
    data: XOR<PrivateMessageUpdateWithoutVisibilitiesInput, PrivateMessageUncheckedUpdateWithoutVisibilitiesInput>
  }

  export type PrivateMessageUpdateWithoutVisibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    conversation?: PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput
    attachments?: PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput
    reactedBy?: AccountUpdateOneWithoutReactedMessagesNestedInput
  }

  export type PrivateMessageUncheckedUpdateWithoutVisibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type AccountUpsertWithoutPrivateMessageVisibilitiesInput = {
    update: XOR<AccountUpdateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedUpdateWithoutPrivateMessageVisibilitiesInput>
    create: XOR<AccountCreateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedCreateWithoutPrivateMessageVisibilitiesInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutPrivateMessageVisibilitiesInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutPrivateMessageVisibilitiesInput, AccountUncheckedUpdateWithoutPrivateMessageVisibilitiesInput>
  }

  export type AccountUpdateWithoutPrivateMessageVisibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutPrivateMessageVisibilitiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type BrandCreateWithoutProductsInput = {
    id?: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutBrandInput
  }

  export type BrandUncheckedCreateWithoutProductsInput = {
    id?: string
    accountId: string
    description?: string | null
    logo?: string | null
    categories?: BrandCreatecategoriesInput | $Enums.Category[]
    status?: $Enums.BrandStatus
    instagramUrl?: string | null
    tiktokUrl?: string | null
    businessPhone?: string | null
    ownerName?: string | null
    ownerNationalId?: string | null
    ownerPhone?: string | null
    crn?: string | null
    taxId?: string | null
    paymentMethods?: BrandCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BrandCreateOrConnectWithoutProductsInput = {
    where: BrandWhereUniqueInput
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
  }

  export type ProductImageCreateWithoutProductInput = {
    id?: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    embedding?: ProductImageEmbeddingCreateNestedOneWithoutImageInput
  }

  export type ProductImageUncheckedCreateWithoutProductInput = {
    id?: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    embedding?: ProductImageEmbeddingUncheckedCreateNestedOneWithoutImageInput
  }

  export type ProductImageCreateOrConnectWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageCreateManyProductInputEnvelope = {
    data: ProductImageCreateManyProductInput | ProductImageCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type VariantCreateWithoutProductInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VariantImageCreateNestedManyWithoutVariantInput
    options?: VariantOptionCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutProductInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VariantImageUncheckedCreateNestedManyWithoutVariantInput
    options?: VariantOptionUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutProductInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantCreateManyProductInputEnvelope = {
    data: VariantCreateManyProductInput | VariantCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductOptionCreateWithoutProductInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
    values?: ProductOptionValueCreateNestedManyWithoutOptionInput
    VariantOption?: VariantOptionCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutProductInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
    values?: ProductOptionValueUncheckedCreateNestedManyWithoutOptionInput
    VariantOption?: VariantOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput>
  }

  export type ProductOptionCreateManyProductInputEnvelope = {
    data: ProductOptionCreateManyProductInput | ProductOptionCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ProductTagCreateWithoutProductInput = {
    pinned?: boolean
    addedAt?: Date | string
    tag: TagCreateNestedOneWithoutProductsInput
  }

  export type ProductTagUncheckedCreateWithoutProductInput = {
    tagId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ProductTagCreateOrConnectWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    create: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput>
  }

  export type ProductTagCreateManyProductInputEnvelope = {
    data: ProductTagCreateManyProductInput | ProductTagCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type ReviewCreateWithoutProductInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutProductInput = {
    id?: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutProductInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewCreateManyProductInputEnvelope = {
    data: ReviewCreateManyProductInput | ReviewCreateManyProductInput[]
    skipDuplicates?: boolean
  }

  export type BrandUpsertWithoutProductsInput = {
    update: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
    create: XOR<BrandCreateWithoutProductsInput, BrandUncheckedCreateWithoutProductsInput>
    where?: BrandWhereInput
  }

  export type BrandUpdateToOneWithWhereWithoutProductsInput = {
    where?: BrandWhereInput
    data: XOR<BrandUpdateWithoutProductsInput, BrandUncheckedUpdateWithoutProductsInput>
  }

  export type BrandUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutBrandNestedInput
  }

  export type BrandUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    categories?: BrandUpdatecategoriesInput | $Enums.Category[]
    status?: EnumBrandStatusFieldUpdateOperationsInput | $Enums.BrandStatus
    instagramUrl?: NullableStringFieldUpdateOperationsInput | string | null
    tiktokUrl?: NullableStringFieldUpdateOperationsInput | string | null
    businessPhone?: NullableStringFieldUpdateOperationsInput | string | null
    ownerName?: NullableStringFieldUpdateOperationsInput | string | null
    ownerNationalId?: NullableStringFieldUpdateOperationsInput | string | null
    ownerPhone?: NullableStringFieldUpdateOperationsInput | string | null
    crn?: NullableStringFieldUpdateOperationsInput | string | null
    taxId?: NullableStringFieldUpdateOperationsInput | string | null
    paymentMethods?: BrandUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    update: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
    create: XOR<ProductImageCreateWithoutProductInput, ProductImageUncheckedCreateWithoutProductInput>
  }

  export type ProductImageUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageWhereUniqueInput
    data: XOR<ProductImageUpdateWithoutProductInput, ProductImageUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageScalarWhereInput
    data: XOR<ProductImageUpdateManyMutationInput, ProductImageUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageScalarWhereInput = {
    AND?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    OR?: ProductImageScalarWhereInput[]
    NOT?: ProductImageScalarWhereInput | ProductImageScalarWhereInput[]
    id?: StringFilter<"ProductImage"> | string
    productId?: StringFilter<"ProductImage"> | string
    url?: StringFilter<"ProductImage"> | string
    altText?: StringNullableFilter<"ProductImage"> | string | null
    meta?: JsonNullableFilter<"ProductImage">
    sortOrder?: IntFilter<"ProductImage"> | number
    createdAt?: DateTimeFilter<"ProductImage"> | Date | string
  }

  export type VariantUpsertWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    update: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
    create: XOR<VariantCreateWithoutProductInput, VariantUncheckedCreateWithoutProductInput>
  }

  export type VariantUpdateWithWhereUniqueWithoutProductInput = {
    where: VariantWhereUniqueInput
    data: XOR<VariantUpdateWithoutProductInput, VariantUncheckedUpdateWithoutProductInput>
  }

  export type VariantUpdateManyWithWhereWithoutProductInput = {
    where: VariantScalarWhereInput
    data: XOR<VariantUpdateManyMutationInput, VariantUncheckedUpdateManyWithoutProductInput>
  }

  export type VariantScalarWhereInput = {
    AND?: VariantScalarWhereInput | VariantScalarWhereInput[]
    OR?: VariantScalarWhereInput[]
    NOT?: VariantScalarWhereInput | VariantScalarWhereInput[]
    id?: StringFilter<"Variant"> | string
    productId?: StringFilter<"Variant"> | string
    sku?: StringFilter<"Variant"> | string
    price?: DecimalFilter<"Variant"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Variant"> | string
    stock?: IntFilter<"Variant"> | number
    weight?: DecimalNullableFilter<"Variant"> | Decimal | DecimalJsLike | number | string | null
    dimensions?: JsonNullableFilter<"Variant">
    createdAt?: DateTimeFilter<"Variant"> | Date | string
    updatedAt?: DateTimeFilter<"Variant"> | Date | string
  }

  export type ProductOptionUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    update: XOR<ProductOptionUpdateWithoutProductInput, ProductOptionUncheckedUpdateWithoutProductInput>
    create: XOR<ProductOptionCreateWithoutProductInput, ProductOptionUncheckedCreateWithoutProductInput>
  }

  export type ProductOptionUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductOptionWhereUniqueInput
    data: XOR<ProductOptionUpdateWithoutProductInput, ProductOptionUncheckedUpdateWithoutProductInput>
  }

  export type ProductOptionUpdateManyWithWhereWithoutProductInput = {
    where: ProductOptionScalarWhereInput
    data: XOR<ProductOptionUpdateManyMutationInput, ProductOptionUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductOptionScalarWhereInput = {
    AND?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
    OR?: ProductOptionScalarWhereInput[]
    NOT?: ProductOptionScalarWhereInput | ProductOptionScalarWhereInput[]
    id?: StringFilter<"ProductOption"> | string
    productId?: StringFilter<"ProductOption"> | string
    name?: StringFilter<"ProductOption"> | string
    label?: StringNullableFilter<"ProductOption"> | string | null
    sortOrder?: IntFilter<"ProductOption"> | number
  }

  export type ProductTagUpsertWithWhereUniqueWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    update: XOR<ProductTagUpdateWithoutProductInput, ProductTagUncheckedUpdateWithoutProductInput>
    create: XOR<ProductTagCreateWithoutProductInput, ProductTagUncheckedCreateWithoutProductInput>
  }

  export type ProductTagUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductTagWhereUniqueInput
    data: XOR<ProductTagUpdateWithoutProductInput, ProductTagUncheckedUpdateWithoutProductInput>
  }

  export type ProductTagUpdateManyWithWhereWithoutProductInput = {
    where: ProductTagScalarWhereInput
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductTagScalarWhereInput = {
    AND?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
    OR?: ProductTagScalarWhereInput[]
    NOT?: ProductTagScalarWhereInput | ProductTagScalarWhereInput[]
    productId?: StringFilter<"ProductTag"> | string
    tagId?: StringFilter<"ProductTag"> | string
    pinned?: BoolFilter<"ProductTag"> | boolean
    addedAt?: DateTimeFilter<"ProductTag"> | Date | string
  }

  export type ReviewUpsertWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    update: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
    create: XOR<ReviewCreateWithoutProductInput, ReviewUncheckedCreateWithoutProductInput>
  }

  export type ReviewUpdateWithWhereUniqueWithoutProductInput = {
    where: ReviewWhereUniqueInput
    data: XOR<ReviewUpdateWithoutProductInput, ReviewUncheckedUpdateWithoutProductInput>
  }

  export type ReviewUpdateManyWithWhereWithoutProductInput = {
    where: ReviewScalarWhereInput
    data: XOR<ReviewUpdateManyMutationInput, ReviewUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageEmbeddingUpdateWithWhereUniqueWithoutProductInput = {
    where: ProductImageEmbeddingWhereUniqueInput
    data: XOR<ProductImageEmbeddingUpdateWithoutProductInput, ProductImageEmbeddingUncheckedUpdateWithoutProductInput>
  }

  export type ProductImageEmbeddingUpdateManyWithWhereWithoutProductInput = {
    where: ProductImageEmbeddingScalarWhereInput
    data: XOR<ProductImageEmbeddingUpdateManyMutationInput, ProductImageEmbeddingUncheckedUpdateManyWithoutProductInput>
  }

  export type ProductImageEmbeddingScalarWhereInput = {
    AND?: ProductImageEmbeddingScalarWhereInput | ProductImageEmbeddingScalarWhereInput[]
    OR?: ProductImageEmbeddingScalarWhereInput[]
    NOT?: ProductImageEmbeddingScalarWhereInput | ProductImageEmbeddingScalarWhereInput[]
    id?: StringFilter<"ProductImageEmbedding"> | string
    productImageId?: StringFilter<"ProductImageEmbedding"> | string
    productId?: StringFilter<"ProductImageEmbedding"> | string
    model?: StringFilter<"ProductImageEmbedding"> | string
    dim?: IntFilter<"ProductImageEmbedding"> | number
    updatedAt?: DateTimeFilter<"ProductImageEmbedding"> | Date | string
  }

  export type ProductCreateWithoutImagesInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImagesInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImagesInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
  }

  export type ProductUpsertWithoutImagesInput = {
    update: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
    create: XOR<ProductCreateWithoutImagesInput, ProductUncheckedCreateWithoutImagesInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImagesInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImagesInput, ProductUncheckedUpdateWithoutImagesInput>
  }

  export type ProductUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductImageEmbeddingUpdateToOneWithWhereWithoutImageInput = {
    where?: ProductImageEmbeddingWhereInput
    data: XOR<ProductImageEmbeddingUpdateWithoutImageInput, ProductImageEmbeddingUncheckedUpdateWithoutImageInput>
  }

  export type ProductImageEmbeddingUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutImageVectorsNestedInput
  }

  export type ProductImageEmbeddingUncheckedUpdateWithoutImageInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutOptionsInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutOptionsInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutOptionsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
  }

  export type ProductOptionValueCreateWithoutOptionInput = {
    id?: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
    variantLinks?: VariantOptionCreateNestedManyWithoutValueInput
  }

  export type ProductOptionValueUncheckedCreateWithoutOptionInput = {
    id?: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
    variantLinks?: VariantOptionUncheckedCreateNestedManyWithoutValueInput
  }

  export type ProductOptionValueCreateOrConnectWithoutOptionInput = {
    where: ProductOptionValueWhereUniqueInput
    create: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput>
  }

  export type ProductOptionValueCreateManyOptionInputEnvelope = {
    data: ProductOptionValueCreateManyOptionInput | ProductOptionValueCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type VariantOptionCreateWithoutOptionInput = {
    id?: string
    variant: VariantCreateNestedOneWithoutOptionsInput
    value: ProductOptionValueCreateNestedOneWithoutVariantLinksInput
  }

  export type VariantOptionUncheckedCreateWithoutOptionInput = {
    id?: string
    variantId: string
    productOptionValueId: string
  }

  export type VariantOptionCreateOrConnectWithoutOptionInput = {
    where: VariantOptionWhereUniqueInput
    create: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput>
  }

  export type VariantOptionCreateManyOptionInputEnvelope = {
    data: VariantOptionCreateManyOptionInput | VariantOptionCreateManyOptionInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutOptionsInput = {
    update: XOR<ProductUpdateWithoutOptionsInput, ProductUncheckedUpdateWithoutOptionsInput>
    create: XOR<ProductCreateWithoutOptionsInput, ProductUncheckedCreateWithoutOptionsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutOptionsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutOptionsInput, ProductUncheckedUpdateWithoutOptionsInput>
  }

  export type ProductUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductOptionValueUpsertWithWhereUniqueWithoutOptionInput = {
    where: ProductOptionValueWhereUniqueInput
    update: XOR<ProductOptionValueUpdateWithoutOptionInput, ProductOptionValueUncheckedUpdateWithoutOptionInput>
    create: XOR<ProductOptionValueCreateWithoutOptionInput, ProductOptionValueUncheckedCreateWithoutOptionInput>
  }

  export type ProductOptionValueUpdateWithWhereUniqueWithoutOptionInput = {
    where: ProductOptionValueWhereUniqueInput
    data: XOR<ProductOptionValueUpdateWithoutOptionInput, ProductOptionValueUncheckedUpdateWithoutOptionInput>
  }

  export type ProductOptionValueUpdateManyWithWhereWithoutOptionInput = {
    where: ProductOptionValueScalarWhereInput
    data: XOR<ProductOptionValueUpdateManyMutationInput, ProductOptionValueUncheckedUpdateManyWithoutOptionInput>
  }

  export type ProductOptionValueScalarWhereInput = {
    AND?: ProductOptionValueScalarWhereInput | ProductOptionValueScalarWhereInput[]
    OR?: ProductOptionValueScalarWhereInput[]
    NOT?: ProductOptionValueScalarWhereInput | ProductOptionValueScalarWhereInput[]
    id?: StringFilter<"ProductOptionValue"> | string
    productOptionId?: StringFilter<"ProductOptionValue"> | string
    value?: StringFilter<"ProductOptionValue"> | string
    label?: StringNullableFilter<"ProductOptionValue"> | string | null
    colorHex?: StringNullableFilter<"ProductOptionValue"> | string | null
    sortOrder?: IntFilter<"ProductOptionValue"> | number
  }

  export type VariantOptionUpsertWithWhereUniqueWithoutOptionInput = {
    where: VariantOptionWhereUniqueInput
    update: XOR<VariantOptionUpdateWithoutOptionInput, VariantOptionUncheckedUpdateWithoutOptionInput>
    create: XOR<VariantOptionCreateWithoutOptionInput, VariantOptionUncheckedCreateWithoutOptionInput>
  }

  export type VariantOptionUpdateWithWhereUniqueWithoutOptionInput = {
    where: VariantOptionWhereUniqueInput
    data: XOR<VariantOptionUpdateWithoutOptionInput, VariantOptionUncheckedUpdateWithoutOptionInput>
  }

  export type VariantOptionUpdateManyWithWhereWithoutOptionInput = {
    where: VariantOptionScalarWhereInput
    data: XOR<VariantOptionUpdateManyMutationInput, VariantOptionUncheckedUpdateManyWithoutOptionInput>
  }

  export type VariantOptionScalarWhereInput = {
    AND?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
    OR?: VariantOptionScalarWhereInput[]
    NOT?: VariantOptionScalarWhereInput | VariantOptionScalarWhereInput[]
    id?: StringFilter<"VariantOption"> | string
    variantId?: StringFilter<"VariantOption"> | string
    productOptionId?: StringFilter<"VariantOption"> | string
    productOptionValueId?: StringFilter<"VariantOption"> | string
  }

  export type ProductOptionCreateWithoutValuesInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
    product: ProductCreateNestedOneWithoutOptionsInput
    VariantOption?: VariantOptionCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutValuesInput = {
    id?: string
    productId: string
    name: string
    label?: string | null
    sortOrder?: number
    VariantOption?: VariantOptionUncheckedCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutValuesInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutValuesInput, ProductOptionUncheckedCreateWithoutValuesInput>
  }

  export type VariantOptionCreateWithoutValueInput = {
    id?: string
    variant: VariantCreateNestedOneWithoutOptionsInput
    option: ProductOptionCreateNestedOneWithoutVariantOptionInput
  }

  export type VariantOptionUncheckedCreateWithoutValueInput = {
    id?: string
    variantId: string
    productOptionId: string
  }

  export type VariantOptionCreateOrConnectWithoutValueInput = {
    where: VariantOptionWhereUniqueInput
    create: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput>
  }

  export type VariantOptionCreateManyValueInputEnvelope = {
    data: VariantOptionCreateManyValueInput | VariantOptionCreateManyValueInput[]
    skipDuplicates?: boolean
  }

  export type ProductOptionUpsertWithoutValuesInput = {
    update: XOR<ProductOptionUpdateWithoutValuesInput, ProductOptionUncheckedUpdateWithoutValuesInput>
    create: XOR<ProductOptionCreateWithoutValuesInput, ProductOptionUncheckedCreateWithoutValuesInput>
    where?: ProductOptionWhereInput
  }

  export type ProductOptionUpdateToOneWithWhereWithoutValuesInput = {
    where?: ProductOptionWhereInput
    data: XOR<ProductOptionUpdateWithoutValuesInput, ProductOptionUncheckedUpdateWithoutValuesInput>
  }

  export type ProductOptionUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    VariantOption?: VariantOptionUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutValuesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    VariantOption?: VariantOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type VariantOptionUpsertWithWhereUniqueWithoutValueInput = {
    where: VariantOptionWhereUniqueInput
    update: XOR<VariantOptionUpdateWithoutValueInput, VariantOptionUncheckedUpdateWithoutValueInput>
    create: XOR<VariantOptionCreateWithoutValueInput, VariantOptionUncheckedCreateWithoutValueInput>
  }

  export type VariantOptionUpdateWithWhereUniqueWithoutValueInput = {
    where: VariantOptionWhereUniqueInput
    data: XOR<VariantOptionUpdateWithoutValueInput, VariantOptionUncheckedUpdateWithoutValueInput>
  }

  export type VariantOptionUpdateManyWithWhereWithoutValueInput = {
    where: VariantOptionScalarWhereInput
    data: XOR<VariantOptionUpdateManyMutationInput, VariantOptionUncheckedUpdateManyWithoutValueInput>
  }

  export type VariantCreateWithoutOptionsInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    images?: VariantImageCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutOptionsInput = {
    id?: string
    productId: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: VariantImageUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutOptionsInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutOptionsInput, VariantUncheckedCreateWithoutOptionsInput>
  }

  export type ProductOptionCreateWithoutVariantOptionInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
    product: ProductCreateNestedOneWithoutOptionsInput
    values?: ProductOptionValueCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionUncheckedCreateWithoutVariantOptionInput = {
    id?: string
    productId: string
    name: string
    label?: string | null
    sortOrder?: number
    values?: ProductOptionValueUncheckedCreateNestedManyWithoutOptionInput
  }

  export type ProductOptionCreateOrConnectWithoutVariantOptionInput = {
    where: ProductOptionWhereUniqueInput
    create: XOR<ProductOptionCreateWithoutVariantOptionInput, ProductOptionUncheckedCreateWithoutVariantOptionInput>
  }

  export type ProductOptionValueCreateWithoutVariantLinksInput = {
    id?: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
    option: ProductOptionCreateNestedOneWithoutValuesInput
  }

  export type ProductOptionValueUncheckedCreateWithoutVariantLinksInput = {
    id?: string
    productOptionId: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
  }

  export type ProductOptionValueCreateOrConnectWithoutVariantLinksInput = {
    where: ProductOptionValueWhereUniqueInput
    create: XOR<ProductOptionValueCreateWithoutVariantLinksInput, ProductOptionValueUncheckedCreateWithoutVariantLinksInput>
  }

  export type VariantUpsertWithoutOptionsInput = {
    update: XOR<VariantUpdateWithoutOptionsInput, VariantUncheckedUpdateWithoutOptionsInput>
    create: XOR<VariantCreateWithoutOptionsInput, VariantUncheckedCreateWithoutOptionsInput>
    where?: VariantWhereInput
  }

  export type VariantUpdateToOneWithWhereWithoutOptionsInput = {
    where?: VariantWhereInput
    data: XOR<VariantUpdateWithoutOptionsInput, VariantUncheckedUpdateWithoutOptionsInput>
  }

  export type VariantUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    images?: VariantImageUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutOptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VariantImageUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductOptionUpsertWithoutVariantOptionInput = {
    update: XOR<ProductOptionUpdateWithoutVariantOptionInput, ProductOptionUncheckedUpdateWithoutVariantOptionInput>
    create: XOR<ProductOptionCreateWithoutVariantOptionInput, ProductOptionUncheckedCreateWithoutVariantOptionInput>
    where?: ProductOptionWhereInput
  }

  export type ProductOptionUpdateToOneWithWhereWithoutVariantOptionInput = {
    where?: ProductOptionWhereInput
    data: XOR<ProductOptionUpdateWithoutVariantOptionInput, ProductOptionUncheckedUpdateWithoutVariantOptionInput>
  }

  export type ProductOptionUpdateWithoutVariantOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    product?: ProductUpdateOneRequiredWithoutOptionsNestedInput
    values?: ProductOptionValueUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutVariantOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    values?: ProductOptionValueUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionValueUpsertWithoutVariantLinksInput = {
    update: XOR<ProductOptionValueUpdateWithoutVariantLinksInput, ProductOptionValueUncheckedUpdateWithoutVariantLinksInput>
    create: XOR<ProductOptionValueCreateWithoutVariantLinksInput, ProductOptionValueUncheckedCreateWithoutVariantLinksInput>
    where?: ProductOptionValueWhereInput
  }

  export type ProductOptionValueUpdateToOneWithWhereWithoutVariantLinksInput = {
    where?: ProductOptionValueWhereInput
    data: XOR<ProductOptionValueUpdateWithoutVariantLinksInput, ProductOptionValueUncheckedUpdateWithoutVariantLinksInput>
  }

  export type ProductOptionValueUpdateWithoutVariantLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    option?: ProductOptionUpdateOneRequiredWithoutValuesNestedInput
  }

  export type ProductOptionValueUncheckedUpdateWithoutVariantLinksInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateWithoutVariantsInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutVariantsInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutVariantsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
  }

  export type VariantImageCreateWithoutVariantInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantImageUncheckedCreateWithoutVariantInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantImageCreateOrConnectWithoutVariantInput = {
    where: VariantImageWhereUniqueInput
    create: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput>
  }

  export type VariantImageCreateManyVariantInputEnvelope = {
    data: VariantImageCreateManyVariantInput | VariantImageCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type VariantOptionCreateWithoutVariantInput = {
    id?: string
    option: ProductOptionCreateNestedOneWithoutVariantOptionInput
    value: ProductOptionValueCreateNestedOneWithoutVariantLinksInput
  }

  export type VariantOptionUncheckedCreateWithoutVariantInput = {
    id?: string
    productOptionId: string
    productOptionValueId: string
  }

  export type VariantOptionCreateOrConnectWithoutVariantInput = {
    where: VariantOptionWhereUniqueInput
    create: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput>
  }

  export type VariantOptionCreateManyVariantInputEnvelope = {
    data: VariantOptionCreateManyVariantInput | VariantOptionCreateManyVariantInput[]
    skipDuplicates?: boolean
  }

  export type ProductUpsertWithoutVariantsInput = {
    update: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
    create: XOR<ProductCreateWithoutVariantsInput, ProductUncheckedCreateWithoutVariantsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutVariantsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutVariantsInput, ProductUncheckedUpdateWithoutVariantsInput>
  }

  export type ProductUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutVariantsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type VariantImageUpsertWithWhereUniqueWithoutVariantInput = {
    where: VariantImageWhereUniqueInput
    update: XOR<VariantImageUpdateWithoutVariantInput, VariantImageUncheckedUpdateWithoutVariantInput>
    create: XOR<VariantImageCreateWithoutVariantInput, VariantImageUncheckedCreateWithoutVariantInput>
  }

  export type VariantImageUpdateWithWhereUniqueWithoutVariantInput = {
    where: VariantImageWhereUniqueInput
    data: XOR<VariantImageUpdateWithoutVariantInput, VariantImageUncheckedUpdateWithoutVariantInput>
  }

  export type VariantImageUpdateManyWithWhereWithoutVariantInput = {
    where: VariantImageScalarWhereInput
    data: XOR<VariantImageUpdateManyMutationInput, VariantImageUncheckedUpdateManyWithoutVariantInput>
  }

  export type VariantImageScalarWhereInput = {
    AND?: VariantImageScalarWhereInput | VariantImageScalarWhereInput[]
    OR?: VariantImageScalarWhereInput[]
    NOT?: VariantImageScalarWhereInput | VariantImageScalarWhereInput[]
    id?: StringFilter<"VariantImage"> | string
    variantId?: StringFilter<"VariantImage"> | string
    url?: StringFilter<"VariantImage"> | string
    altText?: StringNullableFilter<"VariantImage"> | string | null
    sortOrder?: IntFilter<"VariantImage"> | number
    createdAt?: DateTimeFilter<"VariantImage"> | Date | string
  }

  export type VariantOptionUpsertWithWhereUniqueWithoutVariantInput = {
    where: VariantOptionWhereUniqueInput
    update: XOR<VariantOptionUpdateWithoutVariantInput, VariantOptionUncheckedUpdateWithoutVariantInput>
    create: XOR<VariantOptionCreateWithoutVariantInput, VariantOptionUncheckedCreateWithoutVariantInput>
  }

  export type VariantOptionUpdateWithWhereUniqueWithoutVariantInput = {
    where: VariantOptionWhereUniqueInput
    data: XOR<VariantOptionUpdateWithoutVariantInput, VariantOptionUncheckedUpdateWithoutVariantInput>
  }

  export type VariantOptionUpdateManyWithWhereWithoutVariantInput = {
    where: VariantOptionScalarWhereInput
    data: XOR<VariantOptionUpdateManyMutationInput, VariantOptionUncheckedUpdateManyWithoutVariantInput>
  }

  export type VariantCreateWithoutImagesInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    product: ProductCreateNestedOneWithoutVariantsInput
    options?: VariantOptionCreateNestedManyWithoutVariantInput
  }

  export type VariantUncheckedCreateWithoutImagesInput = {
    id?: string
    productId: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: VariantOptionUncheckedCreateNestedManyWithoutVariantInput
  }

  export type VariantCreateOrConnectWithoutImagesInput = {
    where: VariantWhereUniqueInput
    create: XOR<VariantCreateWithoutImagesInput, VariantUncheckedCreateWithoutImagesInput>
  }

  export type VariantUpsertWithoutImagesInput = {
    update: XOR<VariantUpdateWithoutImagesInput, VariantUncheckedUpdateWithoutImagesInput>
    create: XOR<VariantCreateWithoutImagesInput, VariantUncheckedCreateWithoutImagesInput>
    where?: VariantWhereInput
  }

  export type VariantUpdateToOneWithWhereWithoutImagesInput = {
    where?: VariantWhereInput
    data: XOR<VariantUpdateWithoutImagesInput, VariantUncheckedUpdateWithoutImagesInput>
  }

  export type VariantUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutVariantsNestedInput
    options?: VariantOptionUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: VariantOptionUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type ProductTagCreateWithoutTagInput = {
    pinned?: boolean
    addedAt?: Date | string
    product: ProductCreateNestedOneWithoutTagsInput
  }

  export type ProductTagUncheckedCreateWithoutTagInput = {
    productId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ProductTagCreateOrConnectWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    create: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput>
  }

  export type ProductTagCreateManyTagInputEnvelope = {
    data: ProductTagCreateManyTagInput | ProductTagCreateManyTagInput[]
    skipDuplicates?: boolean
  }

  export type ProductTagUpsertWithWhereUniqueWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    update: XOR<ProductTagUpdateWithoutTagInput, ProductTagUncheckedUpdateWithoutTagInput>
    create: XOR<ProductTagCreateWithoutTagInput, ProductTagUncheckedCreateWithoutTagInput>
  }

  export type ProductTagUpdateWithWhereUniqueWithoutTagInput = {
    where: ProductTagWhereUniqueInput
    data: XOR<ProductTagUpdateWithoutTagInput, ProductTagUncheckedUpdateWithoutTagInput>
  }

  export type ProductTagUpdateManyWithWhereWithoutTagInput = {
    where: ProductTagScalarWhereInput
    data: XOR<ProductTagUpdateManyMutationInput, ProductTagUncheckedUpdateManyWithoutTagInput>
  }

  export type ProductCreateWithoutTagsInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutTagsInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutTagsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
  }

  export type TagCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagUncheckedCreateWithoutProductsInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TagCreateOrConnectWithoutProductsInput = {
    where: TagWhereUniqueInput
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
  }

  export type ProductUpsertWithoutTagsInput = {
    update: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
    create: XOR<ProductCreateWithoutTagsInput, ProductUncheckedCreateWithoutTagsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutTagsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutTagsInput, ProductUncheckedUpdateWithoutTagsInput>
  }

  export type ProductUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutTagsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type TagUpsertWithoutProductsInput = {
    update: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
    create: XOR<TagCreateWithoutProductsInput, TagUncheckedCreateWithoutProductsInput>
    where?: TagWhereInput
  }

  export type TagUpdateToOneWithWhereWithoutProductsInput = {
    where?: TagWhereInput
    data: XOR<TagUpdateWithoutProductsInput, TagUncheckedUpdateWithoutProductsInput>
  }

  export type TagUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TagUncheckedUpdateWithoutProductsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateWithoutEmbeddingInput = {
    id?: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
    product: ProductCreateNestedOneWithoutImagesInput
  }

  export type ProductImageUncheckedCreateWithoutEmbeddingInput = {
    id?: string
    productId: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ProductImageCreateOrConnectWithoutEmbeddingInput = {
    where: ProductImageWhereUniqueInput
    create: XOR<ProductImageCreateWithoutEmbeddingInput, ProductImageUncheckedCreateWithoutEmbeddingInput>
  }

  export type ProductImageUpsertWithoutEmbeddingInput = {
    update: XOR<ProductImageUpdateWithoutEmbeddingInput, ProductImageUncheckedUpdateWithoutEmbeddingInput>
    create: XOR<ProductImageCreateWithoutEmbeddingInput, ProductImageUncheckedCreateWithoutEmbeddingInput>
    where?: ProductImageWhereInput
  }

  export type ProductImageUpdateToOneWithWhereWithoutEmbeddingInput = {
    where?: ProductImageWhereInput
    data: XOR<ProductImageUpdateWithoutEmbeddingInput, ProductImageUncheckedUpdateWithoutEmbeddingInput>
  }

  export type ProductImageUpdateWithoutEmbeddingInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutImagesNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutEmbeddingInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateWithoutImageVectorsInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    reviews?: ReviewCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutImageVectorsInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutImageVectorsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutImageVectorsInput, ProductUncheckedCreateWithoutImageVectorsInput>
  }

  export type ProductUpsertWithoutImageVectorsInput = {
    update: XOR<ProductUpdateWithoutImageVectorsInput, ProductUncheckedUpdateWithoutImageVectorsInput>
    create: XOR<ProductCreateWithoutImageVectorsInput, ProductUncheckedCreateWithoutImageVectorsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutImageVectorsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutImageVectorsInput, ProductUncheckedUpdateWithoutImageVectorsInput>
  }

  export type ProductUpdateWithoutImageVectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutImageVectorsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ReviewImageCreateWithoutReviewInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ReviewImageUncheckedCreateWithoutReviewInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ReviewImageCreateOrConnectWithoutReviewInput = {
    where: ReviewImageWhereUniqueInput
    create: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput>
  }

  export type ReviewImageCreateManyReviewInputEnvelope = {
    data: ReviewImageCreateManyReviewInput | ReviewImageCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewVoteCreateWithoutReviewInput = {
    id?: string
    type: $Enums.VoteType
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewVotesInput
  }

  export type ReviewVoteUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewVoteCreateOrConnectWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteCreateManyReviewInputEnvelope = {
    data: ReviewVoteCreateManyReviewInput | ReviewVoteCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReportCreateWithoutReviewInput = {
    id?: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutReviewReportsInput
  }

  export type ReviewReportUncheckedCreateWithoutReviewInput = {
    id?: string
    userId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReportCreateOrConnectWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    create: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReportCreateManyReviewInputEnvelope = {
    data: ReviewReportCreateManyReviewInput | ReviewReportCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type ReviewReplyCreateWithoutReviewInput = {
    id?: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
    author: UserCreateNestedOneWithoutReviewReplaysInput
  }

  export type ReviewReplyUncheckedCreateWithoutReviewInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewReplyCreateOrConnectWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    create: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReplyCreateManyReviewInputEnvelope = {
    data: ReviewReplyCreateManyReviewInput | ReviewReplyCreateManyReviewInput[]
    skipDuplicates?: boolean
  }

  export type UserCreateWithoutReviewsInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReviewsInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReviewsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
  }

  export type ProductCreateWithoutReviewsInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: BrandCreateNestedOneWithoutProductsInput
    images?: ProductImageCreateNestedManyWithoutProductInput
    variants?: VariantCreateNestedManyWithoutProductInput
    options?: ProductOptionCreateNestedManyWithoutProductInput
    tags?: ProductTagCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingCreateNestedManyWithoutProductInput
  }

  export type ProductUncheckedCreateWithoutReviewsInput = {
    id?: string
    brandId: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ProductImageUncheckedCreateNestedManyWithoutProductInput
    variants?: VariantUncheckedCreateNestedManyWithoutProductInput
    options?: ProductOptionUncheckedCreateNestedManyWithoutProductInput
    tags?: ProductTagUncheckedCreateNestedManyWithoutProductInput
    imageVectors?: ProductImageEmbeddingUncheckedCreateNestedManyWithoutProductInput
  }

  export type ProductCreateOrConnectWithoutReviewsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
  }

  export type ReviewImageUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewImageWhereUniqueInput
    update: XOR<ReviewImageUpdateWithoutReviewInput, ReviewImageUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewImageCreateWithoutReviewInput, ReviewImageUncheckedCreateWithoutReviewInput>
  }

  export type ReviewImageUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewImageWhereUniqueInput
    data: XOR<ReviewImageUpdateWithoutReviewInput, ReviewImageUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewImageUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewImageScalarWhereInput
    data: XOR<ReviewImageUpdateManyMutationInput, ReviewImageUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewImageScalarWhereInput = {
    AND?: ReviewImageScalarWhereInput | ReviewImageScalarWhereInput[]
    OR?: ReviewImageScalarWhereInput[]
    NOT?: ReviewImageScalarWhereInput | ReviewImageScalarWhereInput[]
    id?: StringFilter<"ReviewImage"> | string
    reviewId?: StringFilter<"ReviewImage"> | string
    url?: StringFilter<"ReviewImage"> | string
    altText?: StringNullableFilter<"ReviewImage"> | string | null
    sortOrder?: IntFilter<"ReviewImage"> | number
    createdAt?: DateTimeFilter<"ReviewImage"> | Date | string
  }

  export type ReviewVoteUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    update: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewVoteCreateWithoutReviewInput, ReviewVoteUncheckedCreateWithoutReviewInput>
  }

  export type ReviewVoteUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewVoteWhereUniqueInput
    data: XOR<ReviewVoteUpdateWithoutReviewInput, ReviewVoteUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewVoteUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewVoteScalarWhereInput
    data: XOR<ReviewVoteUpdateManyMutationInput, ReviewVoteUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewReportUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    update: XOR<ReviewReportUpdateWithoutReviewInput, ReviewReportUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewReportCreateWithoutReviewInput, ReviewReportUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReportUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewReportWhereUniqueInput
    data: XOR<ReviewReportUpdateWithoutReviewInput, ReviewReportUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewReportUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewReportScalarWhereInput
    data: XOR<ReviewReportUpdateManyMutationInput, ReviewReportUncheckedUpdateManyWithoutReviewInput>
  }

  export type ReviewReplyUpsertWithWhereUniqueWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    update: XOR<ReviewReplyUpdateWithoutReviewInput, ReviewReplyUncheckedUpdateWithoutReviewInput>
    create: XOR<ReviewReplyCreateWithoutReviewInput, ReviewReplyUncheckedCreateWithoutReviewInput>
  }

  export type ReviewReplyUpdateWithWhereUniqueWithoutReviewInput = {
    where: ReviewReplyWhereUniqueInput
    data: XOR<ReviewReplyUpdateWithoutReviewInput, ReviewReplyUncheckedUpdateWithoutReviewInput>
  }

  export type ReviewReplyUpdateManyWithWhereWithoutReviewInput = {
    where: ReviewReplyScalarWhereInput
    data: XOR<ReviewReplyUpdateManyMutationInput, ReviewReplyUncheckedUpdateManyWithoutReviewInput>
  }

  export type UserUpsertWithoutReviewsInput = {
    update: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
    create: XOR<UserCreateWithoutReviewsInput, UserUncheckedCreateWithoutReviewsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewsInput, UserUncheckedUpdateWithoutReviewsInput>
  }

  export type UserUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ProductUpsertWithoutReviewsInput = {
    update: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
    create: XOR<ProductCreateWithoutReviewsInput, ProductUncheckedCreateWithoutReviewsInput>
    where?: ProductWhereInput
  }

  export type ProductUpdateToOneWithWhereWithoutReviewsInput = {
    where?: ProductWhereInput
    data: XOR<ProductUpdateWithoutReviewsInput, ProductUncheckedUpdateWithoutReviewsInput>
  }

  export type ProductUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: BrandUpdateOneRequiredWithoutProductsNestedInput
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutReviewsInput = {
    id?: StringFieldUpdateOperationsInput | string
    brandId?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ReviewCreateWithoutImagesInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutImagesInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutImagesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
  }

  export type ReviewUpsertWithoutImagesInput = {
    update: XOR<ReviewUpdateWithoutImagesInput, ReviewUncheckedUpdateWithoutImagesInput>
    create: XOR<ReviewCreateWithoutImagesInput, ReviewUncheckedCreateWithoutImagesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutImagesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutImagesInput, ReviewUncheckedUpdateWithoutImagesInput>
  }

  export type ReviewUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutImagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewCreateWithoutVotesInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutVotesInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutVotesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
  }

  export type UserCreateWithoutReviewVotesInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReviewVotesInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReviewVotesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
  }

  export type ReviewUpsertWithoutVotesInput = {
    update: XOR<ReviewUpdateWithoutVotesInput, ReviewUncheckedUpdateWithoutVotesInput>
    create: XOR<ReviewCreateWithoutVotesInput, ReviewUncheckedCreateWithoutVotesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutVotesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutVotesInput, ReviewUncheckedUpdateWithoutVotesInput>
  }

  export type ReviewUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewVotesInput = {
    update: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
    create: XOR<UserCreateWithoutReviewVotesInput, UserUncheckedCreateWithoutReviewVotesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewVotesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewVotesInput, UserUncheckedUpdateWithoutReviewVotesInput>
  }

  export type UserUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewVotesInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ReviewCreateWithoutReportsInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutReportsInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    replies?: ReviewReplyUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutReportsInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutReportsInput, ReviewUncheckedCreateWithoutReportsInput>
  }

  export type UserCreateWithoutReviewReportsInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyCreateNestedManyWithoutAuthorInput
  }

  export type UserUncheckedCreateWithoutReviewReportsInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReplays?: ReviewReplyUncheckedCreateNestedManyWithoutAuthorInput
  }

  export type UserCreateOrConnectWithoutReviewReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
  }

  export type ReviewUpsertWithoutReportsInput = {
    update: XOR<ReviewUpdateWithoutReportsInput, ReviewUncheckedUpdateWithoutReportsInput>
    create: XOR<ReviewCreateWithoutReportsInput, ReviewUncheckedCreateWithoutReportsInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutReportsInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutReportsInput, ReviewUncheckedUpdateWithoutReportsInput>
  }

  export type ReviewUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewReportsInput = {
    update: XOR<UserUpdateWithoutReviewReportsInput, UserUncheckedUpdateWithoutReviewReportsInput>
    create: XOR<UserCreateWithoutReviewReportsInput, UserUncheckedCreateWithoutReviewReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewReportsInput, UserUncheckedUpdateWithoutReviewReportsInput>
  }

  export type UserUpdateWithoutReviewReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUpdateManyWithoutAuthorNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReplays?: ReviewReplyUncheckedUpdateManyWithoutAuthorNestedInput
  }

  export type ReviewCreateWithoutRepliesInput = {
    id?: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteCreateNestedManyWithoutReviewInput
    reports?: ReviewReportCreateNestedManyWithoutReviewInput
    user: UserCreateNestedOneWithoutReviewsInput
    product: ProductCreateNestedOneWithoutReviewsInput
  }

  export type ReviewUncheckedCreateWithoutRepliesInput = {
    id?: string
    productId: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: ReviewImageUncheckedCreateNestedManyWithoutReviewInput
    votes?: ReviewVoteUncheckedCreateNestedManyWithoutReviewInput
    reports?: ReviewReportUncheckedCreateNestedManyWithoutReviewInput
  }

  export type ReviewCreateOrConnectWithoutRepliesInput = {
    where: ReviewWhereUniqueInput
    create: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
  }

  export type UserCreateWithoutReviewReplaysInput = {
    id?: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    account: AccountCreateNestedOneWithoutUserInput
    addresses?: AddressCreateNestedManyWithoutUserInput
    reviews?: ReviewCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutReviewReplaysInput = {
    id?: string
    accountId: string
    userName: string
    photo?: string | null
    phone?: string | null
    photoPublicId?: string | null
    gender?: $Enums.Gender | null
    birthDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    paymentMethods?: UserCreatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedCreateNestedManyWithoutUserInput
    reviews?: ReviewUncheckedCreateNestedManyWithoutUserInput
    reviewVotes?: ReviewVoteUncheckedCreateNestedManyWithoutUserInput
    reviewReports?: ReviewReportUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutReviewReplaysInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReviewReplaysInput, UserUncheckedCreateWithoutReviewReplaysInput>
  }

  export type ReviewUpsertWithoutRepliesInput = {
    update: XOR<ReviewUpdateWithoutRepliesInput, ReviewUncheckedUpdateWithoutRepliesInput>
    create: XOR<ReviewCreateWithoutRepliesInput, ReviewUncheckedCreateWithoutRepliesInput>
    where?: ReviewWhereInput
  }

  export type ReviewUpdateToOneWithWhereWithoutRepliesInput = {
    where?: ReviewWhereInput
    data: XOR<ReviewUpdateWithoutRepliesInput, ReviewUncheckedUpdateWithoutRepliesInput>
  }

  export type ReviewUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutRepliesInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type UserUpsertWithoutReviewReplaysInput = {
    update: XOR<UserUpdateWithoutReviewReplaysInput, UserUncheckedUpdateWithoutReviewReplaysInput>
    create: XOR<UserCreateWithoutReviewReplaysInput, UserUncheckedCreateWithoutReviewReplaysInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReviewReplaysInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReviewReplaysInput, UserUncheckedUpdateWithoutReviewReplaysInput>
  }

  export type UserUpdateWithoutReviewReplaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    account?: AccountUpdateOneRequiredWithoutUserNestedInput
    addresses?: AddressUpdateManyWithoutUserNestedInput
    reviews?: ReviewUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutReviewReplaysInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    userName?: StringFieldUpdateOperationsInput | string
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photoPublicId?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableEnumGenderFieldUpdateOperationsInput | $Enums.Gender | null
    birthDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    paymentMethods?: UserUpdatepaymentMethodsInput | $Enums.PaymentMethod[]
    addresses?: AddressUncheckedUpdateManyWithoutUserNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutUserNestedInput
    reviewVotes?: ReviewVoteUncheckedUpdateManyWithoutUserNestedInput
    reviewReports?: ReviewReportUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AccountCreateWithoutNotificationInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    NotificationRecipient?: NotificationRecipientCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutNotificationInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    NotificationRecipient?: NotificationRecipientUncheckedCreateNestedManyWithoutAccountInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutNotificationInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationRecipientCreateWithoutNotificationInput = {
    id?: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    account: AccountCreateNestedOneWithoutNotificationRecipientInput
  }

  export type NotificationRecipientUncheckedCreateWithoutNotificationInput = {
    id?: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientCreateOrConnectWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    create: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationRecipientCreateManyNotificationInputEnvelope = {
    data: NotificationRecipientCreateManyNotificationInput | NotificationRecipientCreateManyNotificationInput[]
    skipDuplicates?: boolean
  }

  export type AccountUpsertWithoutNotificationInput = {
    update: XOR<AccountUpdateWithoutNotificationInput, AccountUncheckedUpdateWithoutNotificationInput>
    create: XOR<AccountCreateWithoutNotificationInput, AccountUncheckedCreateWithoutNotificationInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNotificationInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNotificationInput, AccountUncheckedUpdateWithoutNotificationInput>
  }

  export type AccountUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    NotificationRecipient?: NotificationRecipientUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    NotificationRecipient?: NotificationRecipientUncheckedUpdateManyWithoutAccountNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type NotificationRecipientUpsertWithWhereUniqueWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    update: XOR<NotificationRecipientUpdateWithoutNotificationInput, NotificationRecipientUncheckedUpdateWithoutNotificationInput>
    create: XOR<NotificationRecipientCreateWithoutNotificationInput, NotificationRecipientUncheckedCreateWithoutNotificationInput>
  }

  export type NotificationRecipientUpdateWithWhereUniqueWithoutNotificationInput = {
    where: NotificationRecipientWhereUniqueInput
    data: XOR<NotificationRecipientUpdateWithoutNotificationInput, NotificationRecipientUncheckedUpdateWithoutNotificationInput>
  }

  export type NotificationRecipientUpdateManyWithWhereWithoutNotificationInput = {
    where: NotificationRecipientScalarWhereInput
    data: XOR<NotificationRecipientUpdateManyMutationInput, NotificationRecipientUncheckedUpdateManyWithoutNotificationInput>
  }

  export type NotificationCreateWithoutRecipientsInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    actor?: AccountCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateWithoutRecipientsInput = {
    id?: string
    actorId?: string | null
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutRecipientsInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
  }

  export type AccountCreateWithoutNotificationRecipientInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenCreateNestedManyWithoutAccountInput
    user?: UserCreateNestedOneWithoutAccountInput
    brand?: BrandCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityCreateNestedManyWithoutAccountInput
    Notification?: NotificationCreateNestedManyWithoutActorInput
    deviceTokens?: DeviceTokenCreateNestedManyWithoutAccountInput
  }

  export type AccountUncheckedCreateWithoutNotificationRecipientInput = {
    id?: string
    name: string
    email: string
    password: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
    status?: $Enums.Status
    verificationCode?: string | null
    verificationCodeExpiresAt?: Date | string | null
    passwordResetCode?: string | null
    passwordResetCodeExpiresAt?: Date | string | null
    provider?: $Enums.Provider
    providerId?: string | null
    refreshTokens?: RefreshTokenUncheckedCreateNestedManyWithoutAccountInput
    user?: UserUncheckedCreateNestedOneWithoutAccountInput
    brand?: BrandUncheckedCreateNestedOneWithoutAccountInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedCreateNestedManyWithoutAccountInput
    sentPrivateMessages?: PrivateMessageUncheckedCreateNestedManyWithoutSenderInput
    reactedMessages?: PrivateMessageUncheckedCreateNestedManyWithoutReactedByInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedCreateNestedManyWithoutAccountInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutActorInput
    deviceTokens?: DeviceTokenUncheckedCreateNestedManyWithoutAccountInput
  }

  export type AccountCreateOrConnectWithoutNotificationRecipientInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutNotificationRecipientInput, AccountUncheckedCreateWithoutNotificationRecipientInput>
  }

  export type NotificationUpsertWithoutRecipientsInput = {
    update: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
    create: XOR<NotificationCreateWithoutRecipientsInput, NotificationUncheckedCreateWithoutRecipientsInput>
    where?: NotificationWhereInput
  }

  export type NotificationUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: NotificationWhereInput
    data: XOR<NotificationUpdateWithoutRecipientsInput, NotificationUncheckedUpdateWithoutRecipientsInput>
  }

  export type NotificationUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    actor?: AccountUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    actorId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountUpsertWithoutNotificationRecipientInput = {
    update: XOR<AccountUpdateWithoutNotificationRecipientInput, AccountUncheckedUpdateWithoutNotificationRecipientInput>
    create: XOR<AccountCreateWithoutNotificationRecipientInput, AccountUncheckedCreateWithoutNotificationRecipientInput>
    where?: AccountWhereInput
  }

  export type AccountUpdateToOneWithWhereWithoutNotificationRecipientInput = {
    where?: AccountWhereInput
    data: XOR<AccountUpdateWithoutNotificationRecipientInput, AccountUncheckedUpdateWithoutNotificationRecipientInput>
  }

  export type AccountUpdateWithoutNotificationRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUpdateManyWithoutAccountNestedInput
    user?: UserUpdateOneWithoutAccountNestedInput
    brand?: BrandUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUpdateManyWithoutActorNestedInput
    deviceTokens?: DeviceTokenUpdateManyWithoutAccountNestedInput
  }

  export type AccountUncheckedUpdateWithoutNotificationRecipientInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumStatusFieldUpdateOperationsInput | $Enums.Status
    verificationCode?: NullableStringFieldUpdateOperationsInput | string | null
    verificationCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passwordResetCode?: NullableStringFieldUpdateOperationsInput | string | null
    passwordResetCodeExpiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: EnumProviderFieldUpdateOperationsInput | $Enums.Provider
    providerId?: NullableStringFieldUpdateOperationsInput | string | null
    refreshTokens?: RefreshTokenUncheckedUpdateManyWithoutAccountNestedInput
    user?: UserUncheckedUpdateOneWithoutAccountNestedInput
    brand?: BrandUncheckedUpdateOneWithoutAccountNestedInput
    ConversationParticipant?: PrivateConversationParticipantUncheckedUpdateManyWithoutAccountNestedInput
    sentPrivateMessages?: PrivateMessageUncheckedUpdateManyWithoutSenderNestedInput
    reactedMessages?: PrivateMessageUncheckedUpdateManyWithoutReactedByNestedInput
    privateMessageVisibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutActorNestedInput
    deviceTokens?: DeviceTokenUncheckedUpdateManyWithoutAccountNestedInput
  }

  export type RefreshTokenCreateManyAccountInput = {
    id?: string
    token: string
    expiresAt: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    revokedAt?: Date | string | null
    revokedReason?: $Enums.RevokedReason | null
    jti: string
  }

  export type PrivateConversationParticipantCreateManyAccountInput = {
    id?: string
    conversationId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageCreateManySenderInput = {
    id?: string
    conversationId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
  }

  export type PrivateMessageCreateManyReactedByInput = {
    id?: string
    conversationId: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
  }

  export type PrivateMessageVisibilityCreateManyAccountInput = {
    id?: string
    messageId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyActorInput = {
    id?: string
    type: $Enums.NotificationType
    title: string
    body: string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type NotificationRecipientCreateManyAccountInput = {
    id?: string
    notificationId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DeviceTokenCreateManyAccountInput = {
    id?: string
    token: string
    createdAt?: Date | string
    updatedAt?: Date | string
    isActive?: boolean
    lastSeenAt?: Date | string
  }

  export type RefreshTokenUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type RefreshTokenUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedReason?: NullableEnumRevokedReasonFieldUpdateOperationsInput | $Enums.RevokedReason | null
    jti?: StringFieldUpdateOperationsInput | string
  }

  export type PrivateConversationParticipantUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    conversation?: PrivateConversationUpdateOneRequiredWithoutParticipantsNestedInput
  }

  export type PrivateConversationParticipantUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateConversationParticipantUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    conversation?: PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput
    attachments?: PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput
    reactedBy?: AccountUpdateOneWithoutReactedMessagesNestedInput
    visibilities?: PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    visibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivateMessageUpdateWithoutReactedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    conversation?: PrivateConversationUpdateOneRequiredWithoutMessagesNestedInput
    sender?: AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput
    attachments?: PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput
    visibilities?: PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateWithoutReactedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    attachments?: PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    visibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateManyWithoutReactedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    conversationId?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
  }

  export type PrivateMessageVisibilityUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    message?: PrivateMessageUpdateOneRequiredWithoutVisibilitiesNestedInput
  }

  export type PrivateMessageVisibilityUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: NotificationRecipientUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    recipients?: NotificationRecipientUncheckedUpdateManyWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateManyWithoutActorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notification?: NotificationUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type NotificationRecipientUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    notificationId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceTokenUncheckedUpdateManyWithoutAccountInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    lastSeenAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressCreateManyUserInput = {
    id?: string
    government?: string | null
    city?: string | null
    addressLine?: string | null
    landmark?: string | null
    isPrimary?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewCreateManyUserInput = {
    id?: string
    productId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewVoteCreateManyUserInput = {
    id?: string
    reviewId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewReportCreateManyUserInput = {
    id?: string
    reviewId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReplyCreateManyAuthorInput = {
    id?: string
    reviewId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AddressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AddressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    government?: NullableStringFieldUpdateOperationsInput | string | null
    city?: NullableStringFieldUpdateOperationsInput | string | null
    addressLine?: NullableStringFieldUpdateOperationsInput | string | null
    landmark?: NullableStringFieldUpdateOperationsInput | string | null
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    product?: ProductUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    productId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    review?: ReviewUpdateOneRequiredWithoutRepliesNestedInput
  }

  export type ReviewReplyUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    reviewId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductCreateManyBrandInput = {
    id?: string
    category: $Enums.Category
    title: string
    slug: string
    description?: string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.ProductStatus
    material?: string | null
    avgRating?: Decimal | DecimalJsLike | number | string
    ratingsCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUpdateManyWithoutProductNestedInput
    variants?: VariantUpdateManyWithoutProductNestedInput
    options?: ProductOptionUpdateManyWithoutProductNestedInput
    tags?: ProductTagUpdateManyWithoutProductNestedInput
    reviews?: ReviewUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ProductImageUncheckedUpdateManyWithoutProductNestedInput
    variants?: VariantUncheckedUpdateManyWithoutProductNestedInput
    options?: ProductOptionUncheckedUpdateManyWithoutProductNestedInput
    tags?: ProductTagUncheckedUpdateManyWithoutProductNestedInput
    reviews?: ReviewUncheckedUpdateManyWithoutProductNestedInput
    imageVectors?: ProductImageEmbeddingUncheckedUpdateManyWithoutProductNestedInput
  }

  export type ProductUncheckedUpdateManyWithoutBrandInput = {
    id?: StringFieldUpdateOperationsInput | string
    category?: EnumCategoryFieldUpdateOperationsInput | $Enums.Category
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    attributes?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumProductStatusFieldUpdateOperationsInput | $Enums.ProductStatus
    material?: NullableStringFieldUpdateOperationsInput | string | null
    avgRating?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    ratingsCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateConversationParticipantCreateManyConversationInput = {
    id?: string
    accountId: string
    unreadCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageCreateManyConversationInput = {
    id?: string
    senderId: string
    content: string
    contentType: $Enums.ContentType
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    reactionType?: $Enums.ReactionType | null
    reactedById?: string | null
  }

  export type PrivateConversationParticipantUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutConversationParticipantNestedInput
  }

  export type PrivateConversationParticipantUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateConversationParticipantUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    unreadCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    sender?: AccountUpdateOneRequiredWithoutSentPrivateMessagesNestedInput
    attachments?: PrivateMessageAttachmentUpdateManyWithoutMessageNestedInput
    reactedBy?: AccountUpdateOneWithoutReactedMessagesNestedInput
    visibilities?: PrivateMessageVisibilityUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
    attachments?: PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageNestedInput
    visibilities?: PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type PrivateMessageUncheckedUpdateManyWithoutConversationInput = {
    id?: StringFieldUpdateOperationsInput | string
    senderId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    contentType?: EnumContentTypeFieldUpdateOperationsInput | $Enums.ContentType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactionType?: NullableEnumReactionTypeFieldUpdateOperationsInput | $Enums.ReactionType | null
    reactedById?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PrivateMessageAttachmentCreateManyMessageInput = {
    id?: string
    url: string
    mimeType?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageVisibilityCreateManyMessageInput = {
    id?: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PrivateMessageAttachmentUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageAttachmentUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageAttachmentUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    mimeType?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutPrivateMessageVisibilitiesNestedInput
  }

  export type PrivateMessageVisibilityUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PrivateMessageVisibilityUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageCreateManyProductInput = {
    id?: string
    url: string
    altText?: string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantCreateManyProductInput = {
    id?: string
    sku: string
    price: Decimal | DecimalJsLike | number | string
    currency: string
    stock?: number
    weight?: Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductOptionCreateManyProductInput = {
    id?: string
    name: string
    label?: string | null
    sortOrder?: number
  }

  export type ProductTagCreateManyProductInput = {
    tagId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ReviewCreateManyProductInput = {
    id?: string
    userId: string
    rating: number
    title: string
    content: string
    isVerified?: boolean
    visibility?: $Enums.ReviewVisibility
    reported?: boolean
    helpfulCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProductImageUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embedding?: ProductImageEmbeddingUpdateOneWithoutImageNestedInput
  }

  export type ProductImageUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    embedding?: ProductImageEmbeddingUncheckedUpdateOneWithoutImageNestedInput
  }

  export type ProductImageUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    meta?: NullableJsonNullValueInput | InputJsonValue
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VariantImageUpdateManyWithoutVariantNestedInput
    options?: VariantOptionUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: VariantImageUncheckedUpdateManyWithoutVariantNestedInput
    options?: VariantOptionUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type VariantUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    sku?: StringFieldUpdateOperationsInput | string
    price?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    stock?: IntFieldUpdateOperationsInput | number
    weight?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    dimensions?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    values?: ProductOptionValueUpdateManyWithoutOptionNestedInput
    VariantOption?: VariantOptionUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    values?: ProductOptionValueUncheckedUpdateManyWithoutOptionNestedInput
    VariantOption?: VariantOptionUncheckedUpdateManyWithoutOptionNestedInput
  }

  export type ProductOptionUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type ProductTagUpdateWithoutProductInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tag?: TagUpdateOneRequiredWithoutProductsNestedInput
  }

  export type ProductTagUncheckedUpdateWithoutProductInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTagUncheckedUpdateManyWithoutProductInput = {
    tagId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUpdateManyWithoutReviewNestedInput
    user?: UserUpdateOneRequiredWithoutReviewsNestedInput
  }

  export type ReviewUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: ReviewImageUncheckedUpdateManyWithoutReviewNestedInput
    votes?: ReviewVoteUncheckedUpdateManyWithoutReviewNestedInput
    reports?: ReviewReportUncheckedUpdateManyWithoutReviewNestedInput
    replies?: ReviewReplyUncheckedUpdateManyWithoutReviewNestedInput
  }

  export type ReviewUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    rating?: FloatFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    visibility?: EnumReviewVisibilityFieldUpdateOperationsInput | $Enums.ReviewVisibility
    reported?: BoolFieldUpdateOperationsInput | boolean
    helpfulCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageEmbeddingUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    image?: ProductImageUpdateOneRequiredWithoutEmbeddingNestedInput
  }

  export type ProductImageEmbeddingUncheckedUpdateWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productImageId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductImageEmbeddingUncheckedUpdateManyWithoutProductInput = {
    id?: StringFieldUpdateOperationsInput | string
    productImageId?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    dim?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductOptionValueCreateManyOptionInput = {
    id?: string
    value: string
    label?: string | null
    colorHex?: string | null
    sortOrder?: number
  }

  export type VariantOptionCreateManyOptionInput = {
    id?: string
    variantId: string
    productOptionValueId: string
  }

  export type ProductOptionValueUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    variantLinks?: VariantOptionUpdateManyWithoutValueNestedInput
  }

  export type ProductOptionValueUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    variantLinks?: VariantOptionUncheckedUpdateManyWithoutValueNestedInput
  }

  export type ProductOptionValueUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    label?: NullableStringFieldUpdateOperationsInput | string | null
    colorHex?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
  }

  export type VariantOptionUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    variant?: VariantUpdateOneRequiredWithoutOptionsNestedInput
    value?: ProductOptionValueUpdateOneRequiredWithoutVariantLinksNestedInput
  }

  export type VariantOptionUncheckedUpdateWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionUncheckedUpdateManyWithoutOptionInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionCreateManyValueInput = {
    id?: string
    variantId: string
    productOptionId: string
  }

  export type VariantOptionUpdateWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    variant?: VariantUpdateOneRequiredWithoutOptionsNestedInput
    option?: ProductOptionUpdateOneRequiredWithoutVariantOptionNestedInput
  }

  export type VariantOptionUncheckedUpdateWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionUncheckedUpdateManyWithoutValueInput = {
    id?: StringFieldUpdateOperationsInput | string
    variantId?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantImageCreateManyVariantInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type VariantOptionCreateManyVariantInput = {
    id?: string
    productOptionId: string
    productOptionValueId: string
  }

  export type VariantImageUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantImageUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantImageUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VariantOptionUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    option?: ProductOptionUpdateOneRequiredWithoutVariantOptionNestedInput
    value?: ProductOptionValueUpdateOneRequiredWithoutVariantLinksNestedInput
  }

  export type VariantOptionUncheckedUpdateWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type VariantOptionUncheckedUpdateManyWithoutVariantInput = {
    id?: StringFieldUpdateOperationsInput | string
    productOptionId?: StringFieldUpdateOperationsInput | string
    productOptionValueId?: StringFieldUpdateOperationsInput | string
  }

  export type ProductTagCreateManyTagInput = {
    productId: string
    pinned?: boolean
    addedAt?: Date | string
  }

  export type ProductTagUpdateWithoutTagInput = {
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    product?: ProductUpdateOneRequiredWithoutTagsNestedInput
  }

  export type ProductTagUncheckedUpdateWithoutTagInput = {
    productId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProductTagUncheckedUpdateManyWithoutTagInput = {
    productId?: StringFieldUpdateOperationsInput | string
    pinned?: BoolFieldUpdateOperationsInput | boolean
    addedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageCreateManyReviewInput = {
    id?: string
    url: string
    altText?: string | null
    sortOrder?: number
    createdAt?: Date | string
  }

  export type ReviewVoteCreateManyReviewInput = {
    id?: string
    userId: string
    type: $Enums.VoteType
    createdAt?: Date | string
  }

  export type ReviewReportCreateManyReviewInput = {
    id?: string
    userId: string
    reason: $Enums.ReportReason
    details?: string | null
    createdAt?: Date | string
  }

  export type ReviewReplyCreateManyReviewInput = {
    id?: string
    authorId: string
    content: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ReviewImageUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewImageUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    altText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewVotesNestedInput
  }

  export type ReviewVoteUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewVoteUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: EnumVoteTypeFieldUpdateOperationsInput | $Enums.VoteType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutReviewReportsNestedInput
  }

  export type ReviewReportUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReportUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    reason?: EnumReportReasonFieldUpdateOperationsInput | $Enums.ReportReason
    details?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutReviewReplaysNestedInput
  }

  export type ReviewReplyUncheckedUpdateWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReviewReplyUncheckedUpdateManyWithoutReviewInput = {
    id?: StringFieldUpdateOperationsInput | string
    authorId?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientCreateManyNotificationInput = {
    id?: string
    accountId: string
    readAt?: Date | string | null
    deletedAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationRecipientUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    account?: AccountUpdateOneRequiredWithoutNotificationRecipientNestedInput
  }

  export type NotificationRecipientUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationRecipientUncheckedUpdateManyWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accountId?: StringFieldUpdateOperationsInput | string
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}